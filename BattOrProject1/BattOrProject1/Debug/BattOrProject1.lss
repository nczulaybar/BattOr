
BattOrProject1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000468  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00802000  00802000  000004dc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000015  00802000  00802000  000004dc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000004dc  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000050c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000080  00000000  00000000  0000054c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000f71  00000000  00000000  000005cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000027b  00000000  00000000  0000153d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000025e  00000000  00000000  000017b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000160  00000000  00000000  00001a18  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006de  00000000  00000000  00001b78  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000262  00000000  00000000  00002256  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000088  00000000  00000000  000024b8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
   8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
   c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  10:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  14:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  18:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  1c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  20:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  24:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  28:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  2c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  30:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  34:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  38:	0c 94 2d 01 	jmp	0x25a	; 0x25a <__vector_14>
  3c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  40:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  44:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  48:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  4c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  50:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  54:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  58:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  5c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  60:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  64:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  68:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  6c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  70:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  74:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  78:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  7c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  80:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  84:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  88:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  8c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  90:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  94:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  98:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  9c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  a0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  a4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  a8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  ac:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  b0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  b4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  b8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  bc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  c0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  c4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  c8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  cc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  d0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  d4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  d8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  dc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  e0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  e4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  e8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  ec:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  f0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  f4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  f8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  fc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 100:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 104:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 108:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 10c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 110:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 114:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 118:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 11c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 120:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 124:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 128:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 12c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 130:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 134:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 138:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 13c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 140:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 144:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 148:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 14c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 150:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 154:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 158:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 15c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 160:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 164:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 168:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 16c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 170:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 174:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 178:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 17c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 180:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 184:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 188:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 18c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 190:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 194:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 198:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 19c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1a0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1a4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1a8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1ac:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1b0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1b4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1b8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1bc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1c0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1c4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1c8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1cc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1d0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1d4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1d8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1dc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1e0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1e4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1e8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1ec:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1f0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1f4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1f8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e5       	ldi	r29, 0x5F	; 95
 206:	de bf       	out	0x3e, r29	; 62
 208:	00 e0       	ldi	r16, 0x00	; 0
 20a:	0c bf       	out	0x3c, r16	; 60

0000020c <__do_clear_bss>:
 20c:	20 e2       	ldi	r18, 0x20	; 32
 20e:	a0 e0       	ldi	r26, 0x00	; 0
 210:	b0 e2       	ldi	r27, 0x20	; 32
 212:	01 c0       	rjmp	.+2      	; 0x216 <.do_clear_bss_start>

00000214 <.do_clear_bss_loop>:
 214:	1d 92       	st	X+, r1

00000216 <.do_clear_bss_start>:
 216:	a5 31       	cpi	r26, 0x15	; 21
 218:	b2 07       	cpc	r27, r18
 21a:	e1 f7       	brne	.-8      	; 0x214 <.do_clear_bss_loop>
 21c:	0e 94 ef 01 	call	0x3de	; 0x3de <main>
 220:	0c 94 32 02 	jmp	0x464	; 0x464 <_exit>

00000224 <__bad_interrupt>:
 224:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000228 <led_init>:
//Set the specified pin on the specified port to be in output (1) or input (0) mode.
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in){
  if(out_or_in) port->DIRSET = pin;
 228:	e0 e4       	ldi	r30, 0x40	; 64
 22a:	f6 e0       	ldi	r31, 0x06	; 6
 22c:	21 e0       	ldi	r18, 0x01	; 1
 22e:	21 83       	std	Z+1, r18	; 0x01
 230:	92 e0       	ldi	r25, 0x02	; 2
 232:	91 83       	std	Z+1, r25	; 0x01
 234:	84 e0       	ldi	r24, 0x04	; 4
 236:	81 83       	std	Z+1, r24	; 0x01
  else port->DIRCLR = pin;
}

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
  if(on_or_off) port->OUTSET = pin;
 238:	25 83       	std	Z+5, r18	; 0x05
 23a:	95 83       	std	Z+5, r25	; 0x05
 23c:	85 83       	std	Z+5, r24	; 0x05
 23e:	08 95       	ret

00000240 <blink_init>:
//Setup the specified timer peripheral. Clear out any timer state and reset all counters. Set it to have the specified interrupt_level.
void timer_init(TC0_t* timer, uint8_t int_level){
	timer->CTRLFSET = timer->CTRLFSET | 0b1000; //Executes reset command on CTRLFSet, see p179
 240:	e0 e0       	ldi	r30, 0x00	; 0
 242:	f8 e0       	ldi	r31, 0x08	; 8
 244:	81 85       	ldd	r24, Z+9	; 0x09
 246:	88 60       	ori	r24, 0x08	; 8
 248:	81 87       	std	Z+9, r24	; 0x09
	timer->INTCTRLA = 0b1 & int_level; //Enables overflow interrupt. See p134.
 24a:	81 e0       	ldi	r24, 0x01	; 1
 24c:	86 83       	std	Z+6, r24	; 0x06
	setBit(timer->CTRLFSET, 0b1000, 1); //Executes restart command on CTRLFSet, see p179
}

//Takes in period as time in microseconds between every overflow interrupt.
void timer_set(TC0_t* timer, uint8_t prescaler, uint16_t period){
	timer->CTRLA = (0b00000111 & prescaler); //Set prescaler by setting lower 3 bits of CLKSel;
 24e:	80 83       	st	Z, r24
	timer->PER = period;
 250:	80 ed       	ldi	r24, 0xD0	; 208
 252:	97 e0       	ldi	r25, 0x07	; 7
 254:	86 a3       	std	Z+38, r24	; 0x26
 256:	97 a3       	std	Z+39, r25	; 0x27
 258:	08 95       	ret

0000025a <__vector_14>:
void blink_init(){
	timer_init(&TCC0, 0b11); //high interrupt level
	timer_set(&TCC0, 0b1, 2000); //2000 ticks corresponds to 1ms, as of 10/15 10:32pm
}

ISR(TCC0_OVF_vect){
 25a:	1f 92       	push	r1
 25c:	0f 92       	push	r0
 25e:	0f b6       	in	r0, 0x3f	; 63
 260:	0f 92       	push	r0
 262:	11 24       	eor	r1, r1
 264:	0b b6       	in	r0, 0x3b	; 59
 266:	0f 92       	push	r0
 268:	2f 93       	push	r18
 26a:	3f 93       	push	r19
 26c:	4f 93       	push	r20
 26e:	5f 93       	push	r21
 270:	6f 93       	push	r22
 272:	7f 93       	push	r23
 274:	8f 93       	push	r24
 276:	9f 93       	push	r25
 278:	af 93       	push	r26
 27a:	bf 93       	push	r27
 27c:	ef 93       	push	r30
 27e:	ff 93       	push	r31
	globalTime++;
 280:	80 91 0d 20 	lds	r24, 0x200D
 284:	90 91 0e 20 	lds	r25, 0x200E
 288:	a0 91 0f 20 	lds	r26, 0x200F
 28c:	b0 91 10 20 	lds	r27, 0x2010
 290:	01 96       	adiw	r24, 0x01	; 1
 292:	a1 1d       	adc	r26, r1
 294:	b1 1d       	adc	r27, r1
 296:	80 93 0d 20 	sts	0x200D, r24
 29a:	90 93 0e 20 	sts	0x200E, r25
 29e:	a0 93 0f 20 	sts	0x200F, r26
 2a2:	b0 93 10 20 	sts	0x2010, r27
	if (globalTime%5 == 0) {
 2a6:	60 91 0d 20 	lds	r22, 0x200D
 2aa:	70 91 0e 20 	lds	r23, 0x200E
 2ae:	80 91 0f 20 	lds	r24, 0x200F
 2b2:	90 91 10 20 	lds	r25, 0x2010
 2b6:	25 e0       	ldi	r18, 0x05	; 5
 2b8:	30 e0       	ldi	r19, 0x00	; 0
 2ba:	40 e0       	ldi	r20, 0x00	; 0
 2bc:	50 e0       	ldi	r21, 0x00	; 0
 2be:	0e 94 10 02 	call	0x420	; 0x420 <__udivmodsi4>
 2c2:	67 2b       	or	r22, r23
 2c4:	68 2b       	or	r22, r24
 2c6:	69 2b       	or	r22, r25
 2c8:	19 f4       	brne	.+6      	; 0x2d0 <__vector_14+0x76>
		checkBlink = 1;
 2ca:	81 e0       	ldi	r24, 0x01	; 1
 2cc:	80 93 0c 20 	sts	0x200C, r24
	}
}
 2d0:	ff 91       	pop	r31
 2d2:	ef 91       	pop	r30
 2d4:	bf 91       	pop	r27
 2d6:	af 91       	pop	r26
 2d8:	9f 91       	pop	r25
 2da:	8f 91       	pop	r24
 2dc:	7f 91       	pop	r23
 2de:	6f 91       	pop	r22
 2e0:	5f 91       	pop	r21
 2e2:	4f 91       	pop	r20
 2e4:	3f 91       	pop	r19
 2e6:	2f 91       	pop	r18
 2e8:	0f 90       	pop	r0
 2ea:	0b be       	out	0x3b, r0	; 59
 2ec:	0f 90       	pop	r0
 2ee:	0f be       	out	0x3f, r0	; 63
 2f0:	0f 90       	pop	r0
 2f2:	1f 90       	pop	r1
 2f4:	18 95       	reti

000002f6 <blink_ms_timer_update>:
void blink_set(uint8_t led, uint16_t interval_ms) {
	LEDArray[led].blinkInterval = interval_ms;
}

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
 2f6:	8f 92       	push	r8
 2f8:	9f 92       	push	r9
 2fa:	af 92       	push	r10
 2fc:	bf 92       	push	r11
 2fe:	ef 92       	push	r14
 300:	ff 92       	push	r15
 302:	0f 93       	push	r16
 304:	1f 93       	push	r17
 306:	cf 93       	push	r28
 308:	df 93       	push	r29
	for (int i = 0; i < 3; i++) {
		if (LEDArray[i].blinkInterval != 0) {
			if (lastTime < globalTime) {
 30a:	80 90 11 20 	lds	r8, 0x2011
 30e:	90 90 12 20 	lds	r9, 0x2012
 312:	a0 90 13 20 	lds	r10, 0x2013
 316:	b0 90 14 20 	lds	r11, 0x2014
 31a:	e0 e0       	ldi	r30, 0x00	; 0
 31c:	f0 e2       	ldi	r31, 0x20	; 32
	LEDArray[led].blinkInterval = interval_ms;
}

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
	for (int i = 0; i < 3; i++) {
 31e:	80 e0       	ldi	r24, 0x00	; 0
 320:	90 e0       	ldi	r25, 0x00	; 0
			if (lastTime < globalTime) {
				LEDArray[i].counter += (globalTime - lastTime); 
				}
			if (LEDArray[i].counter >= LEDArray[i].blinkInterval) {
				LEDArray[i].counter = LEDArray[i].counter-LEDArray[i].blinkInterval;
				led_toggle(0b1 << (i));
 322:	01 e0       	ldi	r16, 0x01	; 1
 324:	10 e0       	ldi	r17, 0x00	; 0
  else port->OUTCLR = pin;
}

//If the specified pin on the specified port is in output mode, toggle the pinâ€™s state (if 1 then 0, if 0 then 1).
inline void gpio_toggle_out(PORT_t* port, uint8_t pin){
	port->OUTTGL=pin;
 326:	c0 e4       	ldi	r28, 0x40	; 64
 328:	d6 e0       	ldi	r29, 0x06	; 6
 32a:	df 01       	movw	r26, r30
}

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
	for (int i = 0; i < 3; i++) {
		if (LEDArray[i].blinkInterval != 0) {
 32c:	20 81       	ld	r18, Z
 32e:	31 81       	ldd	r19, Z+1	; 0x01
 330:	21 15       	cp	r18, r1
 332:	31 05       	cpc	r19, r1
 334:	a1 f1       	breq	.+104    	; 0x39e <blink_ms_timer_update+0xa8>
			if (lastTime < globalTime) {
 336:	40 91 0d 20 	lds	r20, 0x200D
 33a:	50 91 0e 20 	lds	r21, 0x200E
 33e:	60 91 0f 20 	lds	r22, 0x200F
 342:	70 91 10 20 	lds	r23, 0x2010
 346:	84 16       	cp	r8, r20
 348:	95 06       	cpc	r9, r21
 34a:	a6 06       	cpc	r10, r22
 34c:	b7 06       	cpc	r11, r23
 34e:	90 f4       	brcc	.+36     	; 0x374 <blink_ms_timer_update+0x7e>
				LEDArray[i].counter += (globalTime - lastTime); 
 350:	40 91 0d 20 	lds	r20, 0x200D
 354:	50 91 0e 20 	lds	r21, 0x200E
 358:	60 91 0f 20 	lds	r22, 0x200F
 35c:	70 91 10 20 	lds	r23, 0x2010
 360:	48 19       	sub	r20, r8
 362:	59 09       	sbc	r21, r9
 364:	6a 09       	sbc	r22, r10
 366:	7b 09       	sbc	r23, r11
 368:	e2 80       	ldd	r14, Z+2	; 0x02
 36a:	f3 80       	ldd	r15, Z+3	; 0x03
 36c:	4e 0d       	add	r20, r14
 36e:	5f 1d       	adc	r21, r15
 370:	42 83       	std	Z+2, r20	; 0x02
 372:	53 83       	std	Z+3, r21	; 0x03
				}
			if (LEDArray[i].counter >= LEDArray[i].blinkInterval) {
 374:	12 96       	adiw	r26, 0x02	; 2
 376:	4d 91       	ld	r20, X+
 378:	5c 91       	ld	r21, X
 37a:	13 97       	sbiw	r26, 0x03	; 3
 37c:	42 17       	cp	r20, r18
 37e:	53 07       	cpc	r21, r19
 380:	70 f0       	brcs	.+28     	; 0x39e <blink_ms_timer_update+0xa8>
				LEDArray[i].counter = LEDArray[i].counter-LEDArray[i].blinkInterval;
 382:	42 1b       	sub	r20, r18
 384:	53 0b       	sbc	r21, r19
 386:	12 96       	adiw	r26, 0x02	; 2
 388:	4d 93       	st	X+, r20
 38a:	5c 93       	st	X, r21
 38c:	13 97       	sbiw	r26, 0x03	; 3
				led_toggle(0b1 << (i));
 38e:	98 01       	movw	r18, r16
 390:	08 2e       	mov	r0, r24
 392:	02 c0       	rjmp	.+4      	; 0x398 <blink_ms_timer_update+0xa2>
 394:	22 0f       	add	r18, r18
 396:	33 1f       	adc	r19, r19
 398:	0a 94       	dec	r0
 39a:	e2 f7       	brpl	.-8      	; 0x394 <blink_ms_timer_update+0x9e>
 39c:	2f 83       	std	Y+7, r18	; 0x07
	LEDArray[led].blinkInterval = interval_ms;
}

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
	for (int i = 0; i < 3; i++) {
 39e:	01 96       	adiw	r24, 0x01	; 1
 3a0:	34 96       	adiw	r30, 0x04	; 4
 3a2:	83 30       	cpi	r24, 0x03	; 3
 3a4:	91 05       	cpc	r25, r1
 3a6:	09 f6       	brne	.-126    	; 0x32a <blink_ms_timer_update+0x34>
				LEDArray[i].counter = LEDArray[i].counter-LEDArray[i].blinkInterval;
				led_toggle(0b1 << (i));
			}
		}
	}
	lastTime = globalTime;
 3a8:	80 91 0d 20 	lds	r24, 0x200D
 3ac:	90 91 0e 20 	lds	r25, 0x200E
 3b0:	a0 91 0f 20 	lds	r26, 0x200F
 3b4:	b0 91 10 20 	lds	r27, 0x2010
 3b8:	80 93 11 20 	sts	0x2011, r24
 3bc:	90 93 12 20 	sts	0x2012, r25
 3c0:	a0 93 13 20 	sts	0x2013, r26
 3c4:	b0 93 14 20 	sts	0x2014, r27
}
 3c8:	df 91       	pop	r29
 3ca:	cf 91       	pop	r28
 3cc:	1f 91       	pop	r17
 3ce:	0f 91       	pop	r16
 3d0:	ff 90       	pop	r15
 3d2:	ef 90       	pop	r14
 3d4:	bf 90       	pop	r11
 3d6:	af 90       	pop	r10
 3d8:	9f 90       	pop	r9
 3da:	8f 90       	pop	r8
 3dc:	08 95       	ret

000003de <main>:
#include "../../timer.c"
#include "../../blink.c"

int main(void)
{
	sei();
 3de:	78 94       	sei
	PMIC.CTRL = PMIC.CTRL | 0b111;
 3e0:	e0 ea       	ldi	r30, 0xA0	; 160
 3e2:	f0 e0       	ldi	r31, 0x00	; 0
 3e4:	82 81       	ldd	r24, Z+2	; 0x02
 3e6:	87 60       	ori	r24, 0x07	; 7
 3e8:	82 83       	std	Z+2, r24	; 0x02
	
	led_init();
 3ea:	0e 94 14 01 	call	0x228	; 0x228 <led_init>
	blink_init();
 3ee:	0e 94 20 01 	call	0x240	; 0x240 <blink_init>
	}
}

//Set the specified led to blink at the specified interval_ms.
void blink_set(uint8_t led, uint16_t interval_ms) {
	LEDArray[led].blinkInterval = interval_ms;
 3f2:	e0 e0       	ldi	r30, 0x00	; 0
 3f4:	f0 e2       	ldi	r31, 0x20	; 32
 3f6:	82 e3       	ldi	r24, 0x32	; 50
 3f8:	90 e0       	ldi	r25, 0x00	; 0
 3fa:	80 83       	st	Z, r24
 3fc:	91 83       	std	Z+1, r25	; 0x01
 3fe:	8d e7       	ldi	r24, 0x7D	; 125
 400:	90 e0       	ldi	r25, 0x00	; 0
 402:	84 83       	std	Z+4, r24	; 0x04
 404:	95 83       	std	Z+5, r25	; 0x05
 406:	8a ef       	ldi	r24, 0xFA	; 250
 408:	90 e0       	ldi	r25, 0x00	; 0
 40a:	80 87       	std	Z+8, r24	; 0x08
 40c:	91 87       	std	Z+9, r25	; 0x09
	blink_set(1, 250/2);
	blink_set(2, 500/2);

    while (1) 
    {
		if(checkBlink == 1) {
 40e:	80 91 0c 20 	lds	r24, 0x200C
 412:	81 30       	cpi	r24, 0x01	; 1
 414:	e1 f7       	brne	.-8      	; 0x40e <main+0x30>
			blink_ms_timer_update();
 416:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <blink_ms_timer_update>
			checkBlink = 0;
 41a:	10 92 0c 20 	sts	0x200C, r1
 41e:	f7 cf       	rjmp	.-18     	; 0x40e <main+0x30>

00000420 <__udivmodsi4>:
 420:	a1 e2       	ldi	r26, 0x21	; 33
 422:	1a 2e       	mov	r1, r26
 424:	aa 1b       	sub	r26, r26
 426:	bb 1b       	sub	r27, r27
 428:	fd 01       	movw	r30, r26
 42a:	0d c0       	rjmp	.+26     	; 0x446 <__udivmodsi4_ep>

0000042c <__udivmodsi4_loop>:
 42c:	aa 1f       	adc	r26, r26
 42e:	bb 1f       	adc	r27, r27
 430:	ee 1f       	adc	r30, r30
 432:	ff 1f       	adc	r31, r31
 434:	a2 17       	cp	r26, r18
 436:	b3 07       	cpc	r27, r19
 438:	e4 07       	cpc	r30, r20
 43a:	f5 07       	cpc	r31, r21
 43c:	20 f0       	brcs	.+8      	; 0x446 <__udivmodsi4_ep>
 43e:	a2 1b       	sub	r26, r18
 440:	b3 0b       	sbc	r27, r19
 442:	e4 0b       	sbc	r30, r20
 444:	f5 0b       	sbc	r31, r21

00000446 <__udivmodsi4_ep>:
 446:	66 1f       	adc	r22, r22
 448:	77 1f       	adc	r23, r23
 44a:	88 1f       	adc	r24, r24
 44c:	99 1f       	adc	r25, r25
 44e:	1a 94       	dec	r1
 450:	69 f7       	brne	.-38     	; 0x42c <__udivmodsi4_loop>
 452:	60 95       	com	r22
 454:	70 95       	com	r23
 456:	80 95       	com	r24
 458:	90 95       	com	r25
 45a:	9b 01       	movw	r18, r22
 45c:	ac 01       	movw	r20, r24
 45e:	bd 01       	movw	r22, r26
 460:	cf 01       	movw	r24, r30
 462:	08 95       	ret

00000464 <_exit>:
 464:	f8 94       	cli

00000466 <__stop_program>:
 466:	ff cf       	rjmp	.-2      	; 0x466 <__stop_program>
