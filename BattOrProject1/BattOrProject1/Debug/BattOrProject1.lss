
BattOrProject1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004f2  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00802000  00802000  00000566  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000016  00802000  00802000  00000566  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000566  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000598  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000100  00000000  00000000  000005d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001b73  00000000  00000000  000006d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000750  00000000  00000000  0000224b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000710  00000000  00000000  0000299b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001d4  00000000  00000000  000030ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000007c9  00000000  00000000  00003280  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000025e  00000000  00000000  00003a49  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000a0  00000000  00000000  00003ca7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
   8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
   c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  10:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  14:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  18:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  1c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  20:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  24:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  28:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  2c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  30:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  34:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  38:	0c 94 21 01 	jmp	0x242	; 0x242 <__vector_14>
  3c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  40:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  44:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  48:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  4c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  50:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  54:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  58:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  5c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  60:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  64:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  68:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  6c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  70:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  74:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  78:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  7c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  80:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  84:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  88:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  8c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  90:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  94:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  98:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  9c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  a0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  a4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  a8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  ac:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  b0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  b4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  b8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  bc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  c0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  c4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  c8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  cc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  d0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  d4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  d8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  dc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  e0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  e4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  e8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  ec:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  f0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  f4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  f8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  fc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 100:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 104:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 108:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 10c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 110:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 114:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 118:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 11c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 120:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 124:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 128:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 12c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 130:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 134:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 138:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 13c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 140:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 144:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 148:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 14c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 150:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 154:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 158:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 15c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 160:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 164:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 168:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 16c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 170:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 174:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 178:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 17c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 180:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 184:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 188:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 18c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 190:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 194:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 198:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 19c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1a0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1a4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1a8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1ac:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1b0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1b4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1b8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1bc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1c0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1c4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1c8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1cc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1d0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1d4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1d8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1dc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1e0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1e4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1e8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1ec:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1f0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1f4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1f8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e5       	ldi	r29, 0x5F	; 95
 206:	de bf       	out	0x3e, r29	; 62
 208:	00 e0       	ldi	r16, 0x00	; 0
 20a:	0c bf       	out	0x3c, r16	; 60

0000020c <__do_clear_bss>:
 20c:	20 e2       	ldi	r18, 0x20	; 32
 20e:	a0 e0       	ldi	r26, 0x00	; 0
 210:	b0 e2       	ldi	r27, 0x20	; 32
 212:	01 c0       	rjmp	.+2      	; 0x216 <.do_clear_bss_start>

00000214 <.do_clear_bss_loop>:
 214:	1d 92       	st	X+, r1

00000216 <.do_clear_bss_start>:
 216:	a6 31       	cpi	r26, 0x16	; 22
 218:	b2 07       	cpc	r27, r18
 21a:	e1 f7       	brne	.-8      	; 0x214 <.do_clear_bss_loop>
 21c:	0e 94 24 02 	call	0x448	; 0x448 <main>
 220:	0c 94 77 02 	jmp	0x4ee	; 0x4ee <_exit>

00000224 <__bad_interrupt>:
 224:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000228 <blink_init>:
uint32_t lastTime;
volatile uint8_t fivemscounter;

//Initialize the state of all of the LEDs in local state of the blink library to have their blinks disabled. Also, setup a timer that will fire an interrupt once every millisecond. Note that the timer is clocked off of the peripheral clock, and the peripheral clock is clocked off of the system clock.
void blink_init(){
	timer_init(&TCC0, 0b11); //high interrupt level
 228:	63 e0       	ldi	r22, 0x03	; 3
 22a:	80 e0       	ldi	r24, 0x00	; 0
 22c:	98 e0       	ldi	r25, 0x08	; 8
 22e:	0e 94 48 02 	call	0x490	; 0x490 <timer_init>
	timer_set(&TCC0, 0b1, 2000); //2000 ticks corresponds to 1ms, as of 10/15 10:32pm
 232:	40 ed       	ldi	r20, 0xD0	; 208
 234:	57 e0       	ldi	r21, 0x07	; 7
 236:	61 e0       	ldi	r22, 0x01	; 1
 238:	80 e0       	ldi	r24, 0x00	; 0
 23a:	98 e0       	ldi	r25, 0x08	; 8
 23c:	0e 94 4f 02 	call	0x49e	; 0x49e <timer_set>
 240:	08 95       	ret

00000242 <__vector_14>:
}

ISR(TCC0_OVF_vect){
 242:	1f 92       	push	r1
 244:	0f 92       	push	r0
 246:	0f b6       	in	r0, 0x3f	; 63
 248:	0f 92       	push	r0
 24a:	11 24       	eor	r1, r1
 24c:	0b b6       	in	r0, 0x3b	; 59
 24e:	0f 92       	push	r0
 250:	2f 93       	push	r18
 252:	3f 93       	push	r19
 254:	4f 93       	push	r20
 256:	5f 93       	push	r21
 258:	6f 93       	push	r22
 25a:	7f 93       	push	r23
 25c:	8f 93       	push	r24
 25e:	9f 93       	push	r25
 260:	af 93       	push	r26
 262:	bf 93       	push	r27
 264:	ef 93       	push	r30
 266:	ff 93       	push	r31
	globalTime++;
 268:	80 91 0d 20 	lds	r24, 0x200D
 26c:	90 91 0e 20 	lds	r25, 0x200E
 270:	a0 91 0f 20 	lds	r26, 0x200F
 274:	b0 91 10 20 	lds	r27, 0x2010
 278:	01 96       	adiw	r24, 0x01	; 1
 27a:	a1 1d       	adc	r26, r1
 27c:	b1 1d       	adc	r27, r1
 27e:	80 93 0d 20 	sts	0x200D, r24
 282:	90 93 0e 20 	sts	0x200E, r25
 286:	a0 93 0f 20 	sts	0x200F, r26
 28a:	b0 93 10 20 	sts	0x2010, r27
	//fivemscounter++;
	if (/*fivemscounter >= 5*/
	globalTime%5==0
 28e:	60 91 0d 20 	lds	r22, 0x200D
 292:	70 91 0e 20 	lds	r23, 0x200E
 296:	80 91 0f 20 	lds	r24, 0x200F
 29a:	90 91 10 20 	lds	r25, 0x2010
 29e:	25 e0       	ldi	r18, 0x05	; 5
 2a0:	30 e0       	ldi	r19, 0x00	; 0
 2a2:	40 e0       	ldi	r20, 0x00	; 0
 2a4:	50 e0       	ldi	r21, 0x00	; 0
 2a6:	0e 94 55 02 	call	0x4aa	; 0x4aa <__udivmodsi4>
}

ISR(TCC0_OVF_vect){
	globalTime++;
	//fivemscounter++;
	if (/*fivemscounter >= 5*/
 2aa:	67 2b       	or	r22, r23
 2ac:	68 2b       	or	r22, r24
 2ae:	69 2b       	or	r22, r25
 2b0:	19 f4       	brne	.+6      	; 0x2b8 <__vector_14+0x76>
	globalTime%5==0
	) {
		checkBlink = 1;
 2b2:	81 e0       	ldi	r24, 0x01	; 1
 2b4:	80 93 0c 20 	sts	0x200C, r24
		//fivemscounter = 0;
	}
}
 2b8:	ff 91       	pop	r31
 2ba:	ef 91       	pop	r30
 2bc:	bf 91       	pop	r27
 2be:	af 91       	pop	r26
 2c0:	9f 91       	pop	r25
 2c2:	8f 91       	pop	r24
 2c4:	7f 91       	pop	r23
 2c6:	6f 91       	pop	r22
 2c8:	5f 91       	pop	r21
 2ca:	4f 91       	pop	r20
 2cc:	3f 91       	pop	r19
 2ce:	2f 91       	pop	r18
 2d0:	0f 90       	pop	r0
 2d2:	0b be       	out	0x3b, r0	; 59
 2d4:	0f 90       	pop	r0
 2d6:	0f be       	out	0x3f, r0	; 63
 2d8:	0f 90       	pop	r0
 2da:	1f 90       	pop	r1
 2dc:	18 95       	reti

000002de <blink_set>:

//Set the specified led to blink at the specified interval_ms.
void blink_set(uint8_t led, uint16_t interval_ms) {
 2de:	e0 e0       	ldi	r30, 0x00	; 0
 2e0:	f0 e2       	ldi	r31, 0x20	; 32
 2e2:	4c e0       	ldi	r20, 0x0C	; 12
 2e4:	50 e2       	ldi	r21, 0x20	; 32
	uint8_t i = 0;
	for (uint8_t pos = 0b1; pos < 0b1000; pos = pos << 1) {
 2e6:	91 e0       	ldi	r25, 0x01	; 1
		if(pos & led) LEDArray[i].blinkInterval = interval_ms;
 2e8:	29 2f       	mov	r18, r25
 2ea:	28 23       	and	r18, r24
 2ec:	11 f0       	breq	.+4      	; 0x2f2 <blink_set+0x14>
 2ee:	60 83       	st	Z, r22
 2f0:	71 83       	std	Z+1, r23	; 0x01
}

//Set the specified led to blink at the specified interval_ms.
void blink_set(uint8_t led, uint16_t interval_ms) {
	uint8_t i = 0;
	for (uint8_t pos = 0b1; pos < 0b1000; pos = pos << 1) {
 2f2:	99 0f       	add	r25, r25
 2f4:	34 96       	adiw	r30, 0x04	; 4
 2f6:	e4 17       	cp	r30, r20
 2f8:	f5 07       	cpc	r31, r21
 2fa:	b1 f7       	brne	.-20     	; 0x2e8 <blink_set+0xa>
		if(pos & led) LEDArray[i].blinkInterval = interval_ms;
		i++;
	}
}
 2fc:	08 95       	ret

000002fe <blink_ms_timer_update>:

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
 2fe:	8f 92       	push	r8
 300:	9f 92       	push	r9
 302:	af 92       	push	r10
 304:	bf 92       	push	r11
 306:	ef 92       	push	r14
 308:	ff 92       	push	r15
 30a:	0f 93       	push	r16
 30c:	1f 93       	push	r17
 30e:	cf 93       	push	r28
 310:	df 93       	push	r29
 312:	00 e0       	ldi	r16, 0x00	; 0
 314:	10 e2       	ldi	r17, 0x20	; 32
 316:	c0 e0       	ldi	r28, 0x00	; 0
 318:	d0 e0       	ldi	r29, 0x00	; 0
			if (lastTime < globalTime) {
				LEDArray[i].counter += (globalTime - lastTime); 
				}
			if (LEDArray[i].counter >= LEDArray[i].blinkInterval) {
				LEDArray[i].counter = LEDArray[i].counter-LEDArray[i].blinkInterval;
				led_toggle(0b1 << (i));
 31a:	ff 24       	eor	r15, r15
 31c:	f3 94       	inc	r15
}

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
	for (uint8_t i = 0; i < 3; i++) {
		if (LEDArray[i].blinkInterval != 0) {
 31e:	ec 2e       	mov	r14, r28
 320:	f8 01       	movw	r30, r16
 322:	80 81       	ld	r24, Z
 324:	91 81       	ldd	r25, Z+1	; 0x01
 326:	00 97       	sbiw	r24, 0x00	; 0
 328:	b9 f1       	breq	.+110    	; 0x398 <blink_ms_timer_update+0x9a>
			if (lastTime < globalTime) {
 32a:	80 90 11 20 	lds	r8, 0x2011
 32e:	90 90 12 20 	lds	r9, 0x2012
 332:	a0 90 13 20 	lds	r10, 0x2013
 336:	b0 90 14 20 	lds	r11, 0x2014
 33a:	40 91 0d 20 	lds	r20, 0x200D
 33e:	50 91 0e 20 	lds	r21, 0x200E
 342:	60 91 0f 20 	lds	r22, 0x200F
 346:	70 91 10 20 	lds	r23, 0x2010
 34a:	84 16       	cp	r8, r20
 34c:	95 06       	cpc	r9, r21
 34e:	a6 06       	cpc	r10, r22
 350:	b7 06       	cpc	r11, r23
 352:	90 f4       	brcc	.+36     	; 0x378 <blink_ms_timer_update+0x7a>
				LEDArray[i].counter += (globalTime - lastTime); 
 354:	40 91 0d 20 	lds	r20, 0x200D
 358:	50 91 0e 20 	lds	r21, 0x200E
 35c:	60 91 0f 20 	lds	r22, 0x200F
 360:	70 91 10 20 	lds	r23, 0x2010
 364:	48 19       	sub	r20, r8
 366:	59 09       	sbc	r21, r9
 368:	6a 09       	sbc	r22, r10
 36a:	7b 09       	sbc	r23, r11
 36c:	22 81       	ldd	r18, Z+2	; 0x02
 36e:	33 81       	ldd	r19, Z+3	; 0x03
 370:	42 0f       	add	r20, r18
 372:	53 1f       	adc	r21, r19
 374:	42 83       	std	Z+2, r20	; 0x02
 376:	53 83       	std	Z+3, r21	; 0x03
				}
			if (LEDArray[i].counter >= LEDArray[i].blinkInterval) {
 378:	22 81       	ldd	r18, Z+2	; 0x02
 37a:	33 81       	ldd	r19, Z+3	; 0x03
 37c:	28 17       	cp	r18, r24
 37e:	39 07       	cpc	r19, r25
 380:	58 f0       	brcs	.+22     	; 0x398 <blink_ms_timer_update+0x9a>
				LEDArray[i].counter = LEDArray[i].counter-LEDArray[i].blinkInterval;
 382:	28 1b       	sub	r18, r24
 384:	39 0b       	sbc	r19, r25
 386:	22 83       	std	Z+2, r18	; 0x02
 388:	33 83       	std	Z+3, r19	; 0x03
				led_toggle(0b1 << (i));
 38a:	8f 2d       	mov	r24, r15
 38c:	01 c0       	rjmp	.+2      	; 0x390 <blink_ms_timer_update+0x92>
 38e:	88 0f       	add	r24, r24
 390:	ea 94       	dec	r14
 392:	ea f7       	brpl	.-6      	; 0x38e <blink_ms_timer_update+0x90>
 394:	0e 94 21 02 	call	0x442	; 0x442 <led_toggle>
 398:	21 96       	adiw	r28, 0x01	; 1
 39a:	0c 5f       	subi	r16, 0xFC	; 252
 39c:	1f 4f       	sbci	r17, 0xFF	; 255
	}
}

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
	for (uint8_t i = 0; i < 3; i++) {
 39e:	c3 30       	cpi	r28, 0x03	; 3
 3a0:	d1 05       	cpc	r29, r1
 3a2:	09 f0       	breq	.+2      	; 0x3a6 <blink_ms_timer_update+0xa8>
 3a4:	bc cf       	rjmp	.-136    	; 0x31e <blink_ms_timer_update+0x20>
				LEDArray[i].counter = LEDArray[i].counter-LEDArray[i].blinkInterval;
				led_toggle(0b1 << (i));
			}
		}
	}
	lastTime = globalTime;
 3a6:	80 91 0d 20 	lds	r24, 0x200D
 3aa:	90 91 0e 20 	lds	r25, 0x200E
 3ae:	a0 91 0f 20 	lds	r26, 0x200F
 3b2:	b0 91 10 20 	lds	r27, 0x2010
 3b6:	80 93 11 20 	sts	0x2011, r24
 3ba:	90 93 12 20 	sts	0x2012, r25
 3be:	a0 93 13 20 	sts	0x2013, r26
 3c2:	b0 93 14 20 	sts	0x2014, r27
 3c6:	df 91       	pop	r29
 3c8:	cf 91       	pop	r28
 3ca:	1f 91       	pop	r17
 3cc:	0f 91       	pop	r16
 3ce:	ff 90       	pop	r15
 3d0:	ef 90       	pop	r14
 3d2:	bf 90       	pop	r11
 3d4:	af 90       	pop	r10
 3d6:	9f 90       	pop	r9
 3d8:	8f 90       	pop	r8
 3da:	08 95       	ret

000003dc <clock_switch_to_ext_crystal>:
#include "timer.h"
#include "blink.h"

void clock_switch_to_ext_crystal(){
	
	OSC.XOSCCTRL = 0b11001011;
 3dc:	e0 e5       	ldi	r30, 0x50	; 80
 3de:	f0 e0       	ldi	r31, 0x00	; 0
 3e0:	8b ec       	ldi	r24, 0xCB	; 203
 3e2:	82 83       	std	Z+2, r24	; 0x02
	OSC.CTRL = OSC.CTRL | 0b1000;
 3e4:	80 81       	ld	r24, Z
 3e6:	88 60       	ori	r24, 0x08	; 8
 3e8:	80 83       	st	Z, r24
	while(!(OSC.STATUS & 0b1000)){
 3ea:	81 81       	ldd	r24, Z+1	; 0x01
 3ec:	83 ff       	sbrs	r24, 3
 3ee:	fd cf       	rjmp	.-6      	; 0x3ea <clock_switch_to_ext_crystal+0xe>
	}
	CPU_CCP = CCP_IOREG_gc;
 3f0:	88 ed       	ldi	r24, 0xD8	; 216
 3f2:	84 bf       	out	0x34, r24	; 52
	CLK.CTRL = 0b11; //Changes multiplexer to set source to external oscillator
 3f4:	83 e0       	ldi	r24, 0x03	; 3
 3f6:	80 93 40 00 	sts	0x0040, r24
 3fa:	08 95       	ret

000003fc <gpio_set_mode>:
#include <stdint.h>
#include <avr/io.h>

//Set the specified pin on the specified port to be in output (1) or input (0) mode.
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in){
  if(out_or_in) port->DIRSET = pin;
 3fc:	44 23       	and	r20, r20
 3fe:	19 f0       	breq	.+6      	; 0x406 <gpio_set_mode+0xa>
 400:	fc 01       	movw	r30, r24
 402:	61 83       	std	Z+1, r22	; 0x01
 404:	08 95       	ret
  else port->DIRCLR = pin;
 406:	fc 01       	movw	r30, r24
 408:	62 83       	std	Z+2, r22	; 0x02
 40a:	08 95       	ret

0000040c <led_init>:
	}
};

//Setup all of the LEDs so they are in output mode and off.
void led_init(){
	gpio_set_mode(&PORTC, LED_GREEN_bm, 1);
 40c:	41 e0       	ldi	r20, 0x01	; 1
 40e:	61 e0       	ldi	r22, 0x01	; 1
 410:	80 e4       	ldi	r24, 0x40	; 64
 412:	96 e0       	ldi	r25, 0x06	; 6
 414:	0e 94 fe 01 	call	0x3fc	; 0x3fc <gpio_set_mode>
	gpio_set_mode(&PORTC, LED_YELLOW_bm, 1);
 418:	41 e0       	ldi	r20, 0x01	; 1
 41a:	62 e0       	ldi	r22, 0x02	; 2
 41c:	80 e4       	ldi	r24, 0x40	; 64
 41e:	96 e0       	ldi	r25, 0x06	; 6
 420:	0e 94 fe 01 	call	0x3fc	; 0x3fc <gpio_set_mode>
	gpio_set_mode(&PORTC, LED_RED_bm, 1);
 424:	41 e0       	ldi	r20, 0x01	; 1
 426:	64 e0       	ldi	r22, 0x04	; 4
 428:	80 e4       	ldi	r24, 0x40	; 64
 42a:	96 e0       	ldi	r25, 0x06	; 6
 42c:	0e 94 fe 01 	call	0x3fc	; 0x3fc <gpio_set_mode>
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in);
//Set the specified pin on the specified port to be in output (1) or input (0) mode.

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
	if(on_or_off) port->OUTSET = pin;
 430:	e0 e4       	ldi	r30, 0x40	; 64
 432:	f6 e0       	ldi	r31, 0x06	; 6
 434:	81 e0       	ldi	r24, 0x01	; 1
 436:	85 83       	std	Z+5, r24	; 0x05
 438:	82 e0       	ldi	r24, 0x02	; 2
 43a:	85 83       	std	Z+5, r24	; 0x05
 43c:	84 e0       	ldi	r24, 0x04	; 4
 43e:	85 83       	std	Z+5, r24	; 0x05
 440:	08 95       	ret

00000442 <led_toggle>:
	else port->OUTCLR = pin;
}

//If the specified pin on the specified port is in output mode, toggle the pinâ€™s state (if 1 then 0, if 0 then 1).
inline void gpio_toggle_out(PORT_t* port, uint8_t pin){
	port->OUTTGL=pin;
 442:	80 93 47 06 	sts	0x0647, r24
 446:	08 95       	ret

00000448 <main>:
volatile uint8_t checkBlink;
uint32_t lastTime;

int main(void)
{
	sei();
 448:	78 94       	sei
	PMIC.CTRL = PMIC.CTRL | 0b111;
 44a:	e0 ea       	ldi	r30, 0xA0	; 160
 44c:	f0 e0       	ldi	r31, 0x00	; 0
 44e:	82 81       	ldd	r24, Z+2	; 0x02
 450:	87 60       	ori	r24, 0x07	; 7
 452:	82 83       	std	Z+2, r24	; 0x02

	led_init();
 454:	0e 94 06 02 	call	0x40c	; 0x40c <led_init>
	blink_init();
 458:	0e 94 14 01 	call	0x228	; 0x228 <blink_init>
	blink_set(LED_GREEN_bm, 100);
 45c:	64 e6       	ldi	r22, 0x64	; 100
 45e:	70 e0       	ldi	r23, 0x00	; 0
 460:	81 e0       	ldi	r24, 0x01	; 1
 462:	0e 94 6f 01 	call	0x2de	; 0x2de <blink_set>
	blink_set(LED_YELLOW_bm, 250);
 466:	6a ef       	ldi	r22, 0xFA	; 250
 468:	70 e0       	ldi	r23, 0x00	; 0
 46a:	82 e0       	ldi	r24, 0x02	; 2
 46c:	0e 94 6f 01 	call	0x2de	; 0x2de <blink_set>
	blink_set(LED_RED_bm, 500);
 470:	64 ef       	ldi	r22, 0xF4	; 244
 472:	71 e0       	ldi	r23, 0x01	; 1
 474:	84 e0       	ldi	r24, 0x04	; 4
 476:	0e 94 6f 01 	call	0x2de	; 0x2de <blink_set>

	clock_switch_to_ext_crystal();
 47a:	0e 94 ee 01 	call	0x3dc	; 0x3dc <clock_switch_to_ext_crystal>
	
    while (1)
    {
		if(checkBlink == 1) {
 47e:	80 91 0c 20 	lds	r24, 0x200C
 482:	81 30       	cpi	r24, 0x01	; 1
 484:	e1 f7       	brne	.-8      	; 0x47e <main+0x36>
			blink_ms_timer_update();
 486:	0e 94 7f 01 	call	0x2fe	; 0x2fe <blink_ms_timer_update>
			checkBlink = 0;
 48a:	10 92 0c 20 	sts	0x200C, r1
 48e:	f7 cf       	rjmp	.-18     	; 0x47e <main+0x36>

00000490 <timer_init>:
#include <stdint.h>
#include <avr/io.h>
#include "gpio.h"

//Setup the specified timer peripheral. Clear out any timer state and reset all counters. Set it to have the specified interrupt_level.
void timer_init(TC0_t* timer, uint8_t int_level){
 490:	fc 01       	movw	r30, r24
	timer->CTRLFSET = timer->CTRLFSET | 0b1000; //Executes reset command on CTRLFSet, see p179
 492:	81 85       	ldd	r24, Z+9	; 0x09
 494:	88 60       	ori	r24, 0x08	; 8
 496:	81 87       	std	Z+9, r24	; 0x09
	timer->INTCTRLA = 0b1 & int_level; //Enables overflow interrupt. See p134.
 498:	61 70       	andi	r22, 0x01	; 1
 49a:	66 83       	std	Z+6, r22	; 0x06
 49c:	08 95       	ret

0000049e <timer_set>:
	setBit(timer->CTRLFSET, 0b1000, 1); //Executes restart command on CTRLFSet, see p179
}

//Takes in period as time in microseconds between every overflow interrupt.
void timer_set(TC0_t* timer, uint8_t prescaler, uint16_t period){
	timer->CTRLA = (0b00000111 & prescaler); //Set prescaler by setting lower 3 bits of CLKSel;
 49e:	67 70       	andi	r22, 0x07	; 7
 4a0:	fc 01       	movw	r30, r24
 4a2:	60 83       	st	Z, r22
	timer->PER = period;
 4a4:	46 a3       	std	Z+38, r20	; 0x26
 4a6:	57 a3       	std	Z+39, r21	; 0x27
 4a8:	08 95       	ret

000004aa <__udivmodsi4>:
 4aa:	a1 e2       	ldi	r26, 0x21	; 33
 4ac:	1a 2e       	mov	r1, r26
 4ae:	aa 1b       	sub	r26, r26
 4b0:	bb 1b       	sub	r27, r27
 4b2:	fd 01       	movw	r30, r26
 4b4:	0d c0       	rjmp	.+26     	; 0x4d0 <__udivmodsi4_ep>

000004b6 <__udivmodsi4_loop>:
 4b6:	aa 1f       	adc	r26, r26
 4b8:	bb 1f       	adc	r27, r27
 4ba:	ee 1f       	adc	r30, r30
 4bc:	ff 1f       	adc	r31, r31
 4be:	a2 17       	cp	r26, r18
 4c0:	b3 07       	cpc	r27, r19
 4c2:	e4 07       	cpc	r30, r20
 4c4:	f5 07       	cpc	r31, r21
 4c6:	20 f0       	brcs	.+8      	; 0x4d0 <__udivmodsi4_ep>
 4c8:	a2 1b       	sub	r26, r18
 4ca:	b3 0b       	sbc	r27, r19
 4cc:	e4 0b       	sbc	r30, r20
 4ce:	f5 0b       	sbc	r31, r21

000004d0 <__udivmodsi4_ep>:
 4d0:	66 1f       	adc	r22, r22
 4d2:	77 1f       	adc	r23, r23
 4d4:	88 1f       	adc	r24, r24
 4d6:	99 1f       	adc	r25, r25
 4d8:	1a 94       	dec	r1
 4da:	69 f7       	brne	.-38     	; 0x4b6 <__udivmodsi4_loop>
 4dc:	60 95       	com	r22
 4de:	70 95       	com	r23
 4e0:	80 95       	com	r24
 4e2:	90 95       	com	r25
 4e4:	9b 01       	movw	r18, r22
 4e6:	ac 01       	movw	r20, r24
 4e8:	bd 01       	movw	r22, r26
 4ea:	cf 01       	movw	r24, r30
 4ec:	08 95       	ret

000004ee <_exit>:
 4ee:	f8 94       	cli

000004f0 <__stop_program>:
 4f0:	ff cf       	rjmp	.-2      	; 0x4f0 <__stop_program>
