
BattOrProject1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000035c  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00802000  00802000  000003d0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  00802000  00802000  000003d0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000003d0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000400  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000080  00000000  00000000  00000440  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001047  00000000  00000000  000004c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000287  00000000  00000000  00001507  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000026f  00000000  00000000  0000178e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000104  00000000  00000000  00001a00  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006cf  00000000  00000000  00001b04  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000003f5  00000000  00000000  000021d3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000070  00000000  00000000  000025c8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
   8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
   c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  10:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  14:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  18:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  1c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  20:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  24:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  28:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  2c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  30:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  34:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  38:	0c 94 61 01 	jmp	0x2c2	; 0x2c2 <__vector_14>
  3c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  40:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  44:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  48:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  4c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  50:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  54:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  58:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  5c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  60:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  64:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  68:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  6c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  70:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  74:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  78:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  7c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  80:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  84:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  88:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  8c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  90:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  94:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  98:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  9c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  a0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  a4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  a8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  ac:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  b0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  b4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  b8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  bc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  c0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  c4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  c8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  cc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  d0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  d4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  d8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  dc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  e0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  e4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  e8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  ec:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  f0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  f4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  f8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  fc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 100:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 104:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 108:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 10c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 110:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 114:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 118:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 11c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 120:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 124:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 128:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 12c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 130:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 134:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 138:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 13c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 140:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 144:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 148:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 14c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 150:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 154:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 158:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 15c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 160:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 164:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 168:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 16c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 170:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 174:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 178:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 17c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 180:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 184:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 188:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 18c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 190:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 194:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 198:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 19c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1a0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1a4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1a8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1ac:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1b0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1b4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1b8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1bc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1c0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1c4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1c8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1cc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1d0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1d4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1d8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1dc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1e0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1e4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1e8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1ec:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1f0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1f4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1f8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e5       	ldi	r29, 0x5F	; 95
 206:	de bf       	out	0x3e, r29	; 62
 208:	00 e0       	ldi	r16, 0x00	; 0
 20a:	0c bf       	out	0x3c, r16	; 60

0000020c <__do_copy_data>:
 20c:	10 e2       	ldi	r17, 0x20	; 32
 20e:	a0 e0       	ldi	r26, 0x00	; 0
 210:	b0 e2       	ldi	r27, 0x20	; 32
 212:	ec e5       	ldi	r30, 0x5C	; 92
 214:	f3 e0       	ldi	r31, 0x03	; 3
 216:	00 e0       	ldi	r16, 0x00	; 0
 218:	0b bf       	out	0x3b, r16	; 59
 21a:	02 c0       	rjmp	.+4      	; 0x220 <__do_copy_data+0x14>
 21c:	07 90       	elpm	r0, Z+
 21e:	0d 92       	st	X+, r0
 220:	a0 30       	cpi	r26, 0x00	; 0
 222:	b1 07       	cpc	r27, r17
 224:	d9 f7       	brne	.-10     	; 0x21c <__do_copy_data+0x10>

00000226 <__do_clear_bss>:
 226:	20 e2       	ldi	r18, 0x20	; 32
 228:	a0 e0       	ldi	r26, 0x00	; 0
 22a:	b0 e2       	ldi	r27, 0x20	; 32
 22c:	01 c0       	rjmp	.+2      	; 0x230 <.do_clear_bss_start>

0000022e <.do_clear_bss_loop>:
 22e:	1d 92       	st	X+, r1

00000230 <.do_clear_bss_start>:
 230:	a4 30       	cpi	r26, 0x04	; 4
 232:	b2 07       	cpc	r27, r18
 234:	e1 f7       	brne	.-8      	; 0x22e <.do_clear_bss_loop>
 236:	0e 94 9f 01 	call	0x33e	; 0x33e <main>
 23a:	0c 94 ac 01 	jmp	0x358	; 0x358 <_exit>

0000023e <__bad_interrupt>:
 23e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000242 <led_off>:
  port->DIR =  setBit(port->DIR, pin, out_or_in);
}

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
  if(getBit(port->DIR, pin))
 242:	90 91 40 06 	lds	r25, 0x0640
  }
}

//returns value of bit at a specified position in a specified uint8_t
inline uint8_t getBit(uint8_t target, uint8_t requestedBit){
  return (target & requestedBit);
 246:	98 23       	and	r25, r24
  port->DIR =  setBit(port->DIR, pin, out_or_in);
}

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
  if(getBit(port->DIR, pin))
 248:	29 f0       	breq	.+10     	; 0x254 <led_off+0x12>
    port->OUT = setBit(port->OUT, pin, on_or_off);
 24a:	e0 e4       	ldi	r30, 0x40	; 64
 24c:	f6 e0       	ldi	r31, 0x06	; 6
 24e:	94 81       	ldd	r25, Z+4	; 0x04
}

//sets value of bit at a specified position in a specified uint8_t and returns changed uint8_t
inline uint8_t setBit(uint8_t target, uint8_t requestedBit, uint8_t requestedValue){
	uint8_t setValue = (requestedValue == 0) ? requestedBit : 0;
  return (target | requestedBit) & (0b11111111 ^ setValue); //could we do ~setValue
 250:	89 2b       	or	r24, r25
}

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
  if(getBit(port->DIR, pin))
    port->OUT = setBit(port->OUT, pin, on_or_off);
 252:	84 83       	std	Z+4, r24	; 0x04
 254:	08 95       	ret

00000256 <led_init>:
//Set the specified pin on the specified port to be in output (1) or input (0) mode.
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in){
  port->DIR =  setBit(port->DIR, pin, out_or_in);
 256:	e0 e4       	ldi	r30, 0x40	; 64
 258:	f6 e0       	ldi	r31, 0x06	; 6
 25a:	80 81       	ld	r24, Z
}

//sets value of bit at a specified position in a specified uint8_t and returns changed uint8_t
inline uint8_t setBit(uint8_t target, uint8_t requestedBit, uint8_t requestedValue){
	uint8_t setValue = (requestedValue == 0) ? requestedBit : 0;
  return (target | requestedBit) & (0b11111111 ^ setValue); //could we do ~setValue
 25c:	81 60       	ori	r24, 0x01	; 1
//Set the specified pin on the specified port to be in output (1) or input (0) mode.
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in){
  port->DIR =  setBit(port->DIR, pin, out_or_in);
 25e:	80 83       	st	Z, r24
 260:	80 81       	ld	r24, Z
}

//sets value of bit at a specified position in a specified uint8_t and returns changed uint8_t
inline uint8_t setBit(uint8_t target, uint8_t requestedBit, uint8_t requestedValue){
	uint8_t setValue = (requestedValue == 0) ? requestedBit : 0;
  return (target | requestedBit) & (0b11111111 ^ setValue); //could we do ~setValue
 262:	82 60       	ori	r24, 0x02	; 2
//Set the specified pin on the specified port to be in output (1) or input (0) mode.
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in){
  port->DIR =  setBit(port->DIR, pin, out_or_in);
 264:	80 83       	st	Z, r24
 266:	80 81       	ld	r24, Z
}

//sets value of bit at a specified position in a specified uint8_t and returns changed uint8_t
inline uint8_t setBit(uint8_t target, uint8_t requestedBit, uint8_t requestedValue){
	uint8_t setValue = (requestedValue == 0) ? requestedBit : 0;
  return (target | requestedBit) & (0b11111111 ^ setValue); //could we do ~setValue
 268:	84 60       	ori	r24, 0x04	; 4
//Set the specified pin on the specified port to be in output (1) or input (0) mode.
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in){
  port->DIR =  setBit(port->DIR, pin, out_or_in);
 26a:	80 83       	st	Z, r24
//Setup all of the LEDs so they are in output mode and off.
void led_init(){
	gpio_set_mode(&PORTC, LED_GREEN_bm, 1);
	gpio_set_mode(&PORTC, LED_YELLOW_bm, 1);
	gpio_set_mode(&PORTC, LED_RED_bm, 1);
	led_off(LED_GREEN_bm);
 26c:	81 e0       	ldi	r24, 0x01	; 1
 26e:	0e 94 21 01 	call	0x242	; 0x242 <led_off>
	led_off(LED_YELLOW_bm);
 272:	82 e0       	ldi	r24, 0x02	; 2
 274:	0e 94 21 01 	call	0x242	; 0x242 <led_off>
	led_off(LED_RED_bm);
 278:	84 e0       	ldi	r24, 0x04	; 4
 27a:	0e 94 21 01 	call	0x242	; 0x242 <led_off>
 27e:	08 95       	ret

00000280 <led_toggle>:
    port->OUT = setBit(port->OUT, pin, on_or_off);
}

//If the specified pin on the specified port is in output mode, toggle the pin’s state (if 1 then 0, if 0 then 1).
inline void gpio_toggle_out(PORT_t* port, uint8_t pin){
  if(getBit(port->DIR, pin)) {
 280:	90 91 40 06 	lds	r25, 0x0640
  }
}

//returns value of bit at a specified position in a specified uint8_t
inline uint8_t getBit(uint8_t target, uint8_t requestedBit){
  return (target & requestedBit);
 284:	98 23       	and	r25, r24
    port->OUT = setBit(port->OUT, pin, on_or_off);
}

//If the specified pin on the specified port is in output mode, toggle the pin’s state (if 1 then 0, if 0 then 1).
inline void gpio_toggle_out(PORT_t* port, uint8_t pin){
  if(getBit(port->DIR, pin)) {
 286:	71 f0       	breq	.+28     	; 0x2a4 <led_toggle+0x24>
    port->OUT = setBit(port->OUT, pin, !getBit(port->OUT, pin));
 288:	e0 e4       	ldi	r30, 0x40	; 64
 28a:	f6 e0       	ldi	r31, 0x06	; 6
 28c:	24 81       	ldd	r18, Z+4	; 0x04
 28e:	94 81       	ldd	r25, Z+4	; 0x04
  }
}

//returns value of bit at a specified position in a specified uint8_t
inline uint8_t getBit(uint8_t target, uint8_t requestedBit){
  return (target & requestedBit);
 290:	28 23       	and	r18, r24
}

//sets value of bit at a specified position in a specified uint8_t and returns changed uint8_t
inline uint8_t setBit(uint8_t target, uint8_t requestedBit, uint8_t requestedValue){
	uint8_t setValue = (requestedValue == 0) ? requestedBit : 0;
 292:	11 f0       	breq	.+4      	; 0x298 <led_toggle+0x18>
 294:	28 2f       	mov	r18, r24
 296:	01 c0       	rjmp	.+2      	; 0x29a <led_toggle+0x1a>
 298:	20 e0       	ldi	r18, 0x00	; 0
  return (target | requestedBit) & (0b11111111 ^ setValue); //could we do ~setValue
 29a:	20 95       	com	r18
 29c:	89 2b       	or	r24, r25
 29e:	82 23       	and	r24, r18
}

//If the specified pin on the specified port is in output mode, toggle the pin’s state (if 1 then 0, if 0 then 1).
inline void gpio_toggle_out(PORT_t* port, uint8_t pin){
  if(getBit(port->DIR, pin)) {
    port->OUT = setBit(port->OUT, pin, !getBit(port->OUT, pin));
 2a0:	80 93 44 06 	sts	0x0644, r24
 2a4:	08 95       	ret

000002a6 <blink_init>:
//Setup the specified timer peripheral. Clear out any timer state and reset all counters. Set it to have the specified interrupt_level.
void timer_init(TC0_t* timer, uint8_t int_level){
	timer->CTRLFSET = timer->CTRLFSET | 0b1000; //Executes reset command on CTRLFSet, see p179
 2a6:	e0 e0       	ldi	r30, 0x00	; 0
 2a8:	f8 e0       	ldi	r31, 0x08	; 8
 2aa:	81 85       	ldd	r24, Z+9	; 0x09
 2ac:	88 60       	ori	r24, 0x08	; 8
 2ae:	81 87       	std	Z+9, r24	; 0x09
	timer->INTCTRLA = 0b11 & int_level; //Enables overflow interrupt. Sets to high. See p134.
 2b0:	83 e0       	ldi	r24, 0x03	; 3
 2b2:	86 83       	std	Z+6, r24	; 0x06
	setBit(timer->CTRLFSET, 0b1000, 1); //Executes restart command on CTRLFSet, see p179
}

//Takes in period as time in microseconds between every overflow interrupt.
void timer_set(TC0_t* timer, uint8_t prescaler, uint16_t period){
	timer->CTRLA = (0b00000111 & prescaler); //Set prescaler by setting lower 3 bits of CLKSel;
 2b4:	81 e0       	ldi	r24, 0x01	; 1
 2b6:	80 83       	st	Z, r24
	//timer->PERH = period >> 8; //Sets the period.
	//timer->PERL = 0b11111111 & period;
	timer->PER = period;
 2b8:	88 ee       	ldi	r24, 0xE8	; 232
 2ba:	93 e0       	ldi	r25, 0x03	; 3
 2bc:	86 a3       	std	Z+38, r24	; 0x26
 2be:	97 a3       	std	Z+39, r25	; 0x27
 2c0:	08 95       	ret

000002c2 <__vector_14>:
	//Disable blinks
	timer_init(&TCC0, 0b11);
	timer_set(&TCC0, 0b001, 1000);
}

ISR(TCC0_OVF_vect){
 2c2:	1f 92       	push	r1
 2c4:	0f 92       	push	r0
 2c6:	0f b6       	in	r0, 0x3f	; 63
 2c8:	0f 92       	push	r0
 2ca:	11 24       	eor	r1, r1
 2cc:	8f 93       	push	r24
 2ce:	9f 93       	push	r25
 2d0:	af 93       	push	r26
 2d2:	bf 93       	push	r27
	globalTime++;
 2d4:	80 91 00 20 	lds	r24, 0x2000
 2d8:	90 91 01 20 	lds	r25, 0x2001
 2dc:	a0 91 02 20 	lds	r26, 0x2002
 2e0:	b0 91 03 20 	lds	r27, 0x2003
 2e4:	01 96       	adiw	r24, 0x01	; 1
 2e6:	a1 1d       	adc	r26, r1
 2e8:	b1 1d       	adc	r27, r1
 2ea:	80 93 00 20 	sts	0x2000, r24
 2ee:	90 93 01 20 	sts	0x2001, r25
 2f2:	a0 93 02 20 	sts	0x2002, r26
 2f6:	b0 93 03 20 	sts	0x2003, r27
}
 2fa:	bf 91       	pop	r27
 2fc:	af 91       	pop	r26
 2fe:	9f 91       	pop	r25
 300:	8f 91       	pop	r24
 302:	0f 90       	pop	r0
 304:	0f be       	out	0x3f, r0	; 63
 306:	0f 90       	pop	r0
 308:	1f 90       	pop	r1
 30a:	18 95       	reti

0000030c <blink_ms_timer_update>:
	
}

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
	if (globalTime > 1000) {
 30c:	80 91 00 20 	lds	r24, 0x2000
 310:	90 91 01 20 	lds	r25, 0x2001
 314:	a0 91 02 20 	lds	r26, 0x2002
 318:	b0 91 03 20 	lds	r27, 0x2003
 31c:	89 3e       	cpi	r24, 0xE9	; 233
 31e:	93 40       	sbci	r25, 0x03	; 3
 320:	a1 05       	cpc	r26, r1
 322:	b1 05       	cpc	r27, r1
 324:	58 f0       	brcs	.+22     	; 0x33c <blink_ms_timer_update+0x30>
		led_toggle(LED_RED_bm);
 326:	84 e0       	ldi	r24, 0x04	; 4
 328:	0e 94 40 01 	call	0x280	; 0x280 <led_toggle>
		globalTime = 0;
 32c:	10 92 00 20 	sts	0x2000, r1
 330:	10 92 01 20 	sts	0x2001, r1
 334:	10 92 02 20 	sts	0x2002, r1
 338:	10 92 03 20 	sts	0x2003, r1
 33c:	08 95       	ret

0000033e <main>:
#include "../../blink.c"

int main(void)
{
	//SREG = SREG | 0b10000000;
	sei(); //Enables interrupts
 33e:	78 94       	sei
	PMIC.CTRL = PMIC.CTRL | 0b111;
 340:	e0 ea       	ldi	r30, 0xA0	; 160
 342:	f0 e0       	ldi	r31, 0x00	; 0
 344:	82 81       	ldd	r24, Z+2	; 0x02
 346:	87 60       	ori	r24, 0x07	; 7
 348:	82 83       	std	Z+2, r24	; 0x02
	
	led_init();
 34a:	0e 94 2b 01 	call	0x256	; 0x256 <led_init>
	
	//led_on(LED_RED_bm);
	//led_on(LED_GREEN_bm);
	//led_on(LED_YELLOW_bm);
	
	blink_init();
 34e:	0e 94 53 01 	call	0x2a6	; 0x2a6 <blink_init>
	
    while (1) 
    {
		blink_ms_timer_update();
 352:	0e 94 86 01 	call	0x30c	; 0x30c <blink_ms_timer_update>
    }
 356:	fd cf       	rjmp	.-6      	; 0x352 <main+0x14>

00000358 <_exit>:
 358:	f8 94       	cli

0000035a <__stop_program>:
 35a:	ff cf       	rjmp	.-2      	; 0x35a <__stop_program>
