
BattOrProject1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000048e  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00802000  00802000  00000502  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000015  00802000  00802000  00000502  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000502  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000534  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000080  00000000  00000000  00000574  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000f7b  00000000  00000000  000005f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000002a3  00000000  00000000  0000156f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000263  00000000  00000000  00001812  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000164  00000000  00000000  00001a78  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006de  00000000  00000000  00001bdc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000294  00000000  00000000  000022ba  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000088  00000000  00000000  0000254e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
   8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
   c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  10:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  14:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  18:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  1c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  20:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  24:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  28:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  2c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  30:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  34:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  38:	0c 94 2d 01 	jmp	0x25a	; 0x25a <__vector_14>
  3c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  40:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  44:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  48:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  4c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  50:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  54:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  58:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  5c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  60:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  64:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  68:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  6c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  70:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  74:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  78:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  7c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  80:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  84:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  88:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  8c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  90:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  94:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  98:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  9c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  a0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  a4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  a8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  ac:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  b0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  b4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  b8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  bc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  c0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  c4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  c8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  cc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  d0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  d4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  d8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  dc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  e0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  e4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  e8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  ec:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  f0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  f4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  f8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  fc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 100:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 104:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 108:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 10c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 110:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 114:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 118:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 11c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 120:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 124:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 128:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 12c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 130:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 134:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 138:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 13c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 140:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 144:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 148:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 14c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 150:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 154:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 158:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 15c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 160:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 164:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 168:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 16c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 170:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 174:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 178:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 17c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 180:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 184:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 188:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 18c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 190:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 194:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 198:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 19c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1a0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1a4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1a8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1ac:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1b0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1b4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1b8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1bc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1c0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1c4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1c8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1cc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1d0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1d4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1d8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1dc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1e0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1e4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1e8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1ec:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1f0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1f4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1f8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e5       	ldi	r29, 0x5F	; 95
 206:	de bf       	out	0x3e, r29	; 62
 208:	00 e0       	ldi	r16, 0x00	; 0
 20a:	0c bf       	out	0x3c, r16	; 60

0000020c <__do_clear_bss>:
 20c:	20 e2       	ldi	r18, 0x20	; 32
 20e:	a0 e0       	ldi	r26, 0x00	; 0
 210:	b0 e2       	ldi	r27, 0x20	; 32
 212:	01 c0       	rjmp	.+2      	; 0x216 <.do_clear_bss_start>

00000214 <.do_clear_bss_loop>:
 214:	1d 92       	st	X+, r1

00000216 <.do_clear_bss_start>:
 216:	a5 31       	cpi	r26, 0x15	; 21
 218:	b2 07       	cpc	r27, r18
 21a:	e1 f7       	brne	.-8      	; 0x214 <.do_clear_bss_loop>
 21c:	0e 94 01 02 	call	0x402	; 0x402 <main>
 220:	0c 94 45 02 	jmp	0x48a	; 0x48a <_exit>

00000224 <__bad_interrupt>:
 224:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000228 <led_init>:
//Set the specified pin on the specified port to be in output (1) or input (0) mode.
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in){
  if(out_or_in) port->DIRSET = pin;
 228:	e0 e4       	ldi	r30, 0x40	; 64
 22a:	f6 e0       	ldi	r31, 0x06	; 6
 22c:	21 e0       	ldi	r18, 0x01	; 1
 22e:	21 83       	std	Z+1, r18	; 0x01
 230:	92 e0       	ldi	r25, 0x02	; 2
 232:	91 83       	std	Z+1, r25	; 0x01
 234:	84 e0       	ldi	r24, 0x04	; 4
 236:	81 83       	std	Z+1, r24	; 0x01
  else port->DIRCLR = pin;
}

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
  if(on_or_off) port->OUTSET = pin;
 238:	25 83       	std	Z+5, r18	; 0x05
 23a:	95 83       	std	Z+5, r25	; 0x05
 23c:	85 83       	std	Z+5, r24	; 0x05
 23e:	08 95       	ret

00000240 <blink_init>:
//Setup the specified timer peripheral. Clear out any timer state and reset all counters. Set it to have the specified interrupt_level.
void timer_init(TC0_t* timer, uint8_t int_level){
	timer->CTRLFSET = timer->CTRLFSET | 0b1000; //Executes reset command on CTRLFSet, see p179
 240:	e0 e0       	ldi	r30, 0x00	; 0
 242:	f8 e0       	ldi	r31, 0x08	; 8
 244:	81 85       	ldd	r24, Z+9	; 0x09
 246:	88 60       	ori	r24, 0x08	; 8
 248:	81 87       	std	Z+9, r24	; 0x09
	timer->INTCTRLA = 0b1 & int_level; //Enables overflow interrupt. See p134.
 24a:	81 e0       	ldi	r24, 0x01	; 1
 24c:	86 83       	std	Z+6, r24	; 0x06
	setBit(timer->CTRLFSET, 0b1000, 1); //Executes restart command on CTRLFSet, see p179
}

//Takes in period as time in microseconds between every overflow interrupt.
void timer_set(TC0_t* timer, uint8_t prescaler, uint16_t period){
	timer->CTRLA = (0b00000111 & prescaler); //Set prescaler by setting lower 3 bits of CLKSel;
 24e:	80 83       	st	Z, r24
	timer->PER = period;
 250:	80 ed       	ldi	r24, 0xD0	; 208
 252:	97 e0       	ldi	r25, 0x07	; 7
 254:	86 a3       	std	Z+38, r24	; 0x26
 256:	97 a3       	std	Z+39, r25	; 0x27
 258:	08 95       	ret

0000025a <__vector_14>:
void blink_init(){
	timer_init(&TCC0, 0b11); //high interrupt level
	timer_set(&TCC0, 0b1, 2000); //2000 ticks corresponds to 1ms, as of 10/15 10:32pm
}

ISR(TCC0_OVF_vect){
 25a:	1f 92       	push	r1
 25c:	0f 92       	push	r0
 25e:	0f b6       	in	r0, 0x3f	; 63
 260:	0f 92       	push	r0
 262:	11 24       	eor	r1, r1
 264:	0b b6       	in	r0, 0x3b	; 59
 266:	0f 92       	push	r0
 268:	2f 93       	push	r18
 26a:	3f 93       	push	r19
 26c:	4f 93       	push	r20
 26e:	5f 93       	push	r21
 270:	6f 93       	push	r22
 272:	7f 93       	push	r23
 274:	8f 93       	push	r24
 276:	9f 93       	push	r25
 278:	af 93       	push	r26
 27a:	bf 93       	push	r27
 27c:	ef 93       	push	r30
 27e:	ff 93       	push	r31
	globalTime++;
 280:	80 91 0d 20 	lds	r24, 0x200D
 284:	90 91 0e 20 	lds	r25, 0x200E
 288:	a0 91 0f 20 	lds	r26, 0x200F
 28c:	b0 91 10 20 	lds	r27, 0x2010
 290:	01 96       	adiw	r24, 0x01	; 1
 292:	a1 1d       	adc	r26, r1
 294:	b1 1d       	adc	r27, r1
 296:	80 93 0d 20 	sts	0x200D, r24
 29a:	90 93 0e 20 	sts	0x200E, r25
 29e:	a0 93 0f 20 	sts	0x200F, r26
 2a2:	b0 93 10 20 	sts	0x2010, r27
	if (globalTime%5 == 0) {
 2a6:	60 91 0d 20 	lds	r22, 0x200D
 2aa:	70 91 0e 20 	lds	r23, 0x200E
 2ae:	80 91 0f 20 	lds	r24, 0x200F
 2b2:	90 91 10 20 	lds	r25, 0x2010
 2b6:	25 e0       	ldi	r18, 0x05	; 5
 2b8:	30 e0       	ldi	r19, 0x00	; 0
 2ba:	40 e0       	ldi	r20, 0x00	; 0
 2bc:	50 e0       	ldi	r21, 0x00	; 0
 2be:	0e 94 23 02 	call	0x446	; 0x446 <__udivmodsi4>
 2c2:	67 2b       	or	r22, r23
 2c4:	68 2b       	or	r22, r24
 2c6:	69 2b       	or	r22, r25
 2c8:	19 f4       	brne	.+6      	; 0x2d0 <__vector_14+0x76>
		checkBlink = 1;
 2ca:	81 e0       	ldi	r24, 0x01	; 1
 2cc:	80 93 0c 20 	sts	0x200C, r24
	}
}
 2d0:	ff 91       	pop	r31
 2d2:	ef 91       	pop	r30
 2d4:	bf 91       	pop	r27
 2d6:	af 91       	pop	r26
 2d8:	9f 91       	pop	r25
 2da:	8f 91       	pop	r24
 2dc:	7f 91       	pop	r23
 2de:	6f 91       	pop	r22
 2e0:	5f 91       	pop	r21
 2e2:	4f 91       	pop	r20
 2e4:	3f 91       	pop	r19
 2e6:	2f 91       	pop	r18
 2e8:	0f 90       	pop	r0
 2ea:	0b be       	out	0x3b, r0	; 59
 2ec:	0f 90       	pop	r0
 2ee:	0f be       	out	0x3f, r0	; 63
 2f0:	0f 90       	pop	r0
 2f2:	1f 90       	pop	r1
 2f4:	18 95       	reti

000002f6 <blink_set>:

//Set the specified led to blink at the specified interval_ms.
void blink_set(uint8_t led, uint16_t interval_ms) {
 2f6:	e0 e0       	ldi	r30, 0x00	; 0
 2f8:	f0 e2       	ldi	r31, 0x20	; 32
 2fa:	4c e0       	ldi	r20, 0x0C	; 12
 2fc:	50 e2       	ldi	r21, 0x20	; 32
	uint8_t i = 0;
	for (uint8_t pos = 0b1; pos < 0b1000; pos = pos << 1) {
 2fe:	91 e0       	ldi	r25, 0x01	; 1
		if(pos & led) LEDArray[i].blinkInterval = interval_ms;
 300:	29 2f       	mov	r18, r25
 302:	28 23       	and	r18, r24
 304:	11 f0       	breq	.+4      	; 0x30a <blink_set+0x14>
 306:	60 83       	st	Z, r22
 308:	71 83       	std	Z+1, r23	; 0x01
}

//Set the specified led to blink at the specified interval_ms.
void blink_set(uint8_t led, uint16_t interval_ms) {
	uint8_t i = 0;
	for (uint8_t pos = 0b1; pos < 0b1000; pos = pos << 1) {
 30a:	99 0f       	add	r25, r25
 30c:	34 96       	adiw	r30, 0x04	; 4
 30e:	e4 17       	cp	r30, r20
 310:	f5 07       	cpc	r31, r21
 312:	b1 f7       	brne	.-20     	; 0x300 <blink_set+0xa>
		if(pos & led) LEDArray[i].blinkInterval = interval_ms;
		i++;
	}
}
 314:	08 95       	ret

00000316 <blink_ms_timer_update>:

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
 316:	8f 92       	push	r8
 318:	9f 92       	push	r9
 31a:	af 92       	push	r10
 31c:	bf 92       	push	r11
 31e:	df 92       	push	r13
 320:	ef 92       	push	r14
 322:	ff 92       	push	r15
 324:	0f 93       	push	r16
 326:	1f 93       	push	r17
 328:	cf 93       	push	r28
 32a:	df 93       	push	r29
	for (uint8_t i = 0; i < 3; i++) {
		if (LEDArray[i].blinkInterval != 0) {
			if (lastTime < globalTime) {
 32c:	80 90 11 20 	lds	r8, 0x2011
 330:	90 90 12 20 	lds	r9, 0x2012
 334:	a0 90 13 20 	lds	r10, 0x2013
 338:	b0 90 14 20 	lds	r11, 0x2014
 33c:	e0 e0       	ldi	r30, 0x00	; 0
 33e:	f0 e2       	ldi	r31, 0x20	; 32
 340:	80 e0       	ldi	r24, 0x00	; 0
 342:	90 e0       	ldi	r25, 0x00	; 0
				LEDArray[i].counter += (globalTime - lastTime); 
				}
			if (LEDArray[i].counter >= LEDArray[i].blinkInterval) {
				LEDArray[i].counter = LEDArray[i].counter-LEDArray[i].blinkInterval;
				led_toggle(0b1 << (i));
 344:	01 e0       	ldi	r16, 0x01	; 1
 346:	10 e0       	ldi	r17, 0x00	; 0
  else port->OUTCLR = pin;
}

//If the specified pin on the specified port is in output mode, toggle the pin’s state (if 1 then 0, if 0 then 1).
inline void gpio_toggle_out(PORT_t* port, uint8_t pin){
	port->OUTTGL=pin;
 348:	c0 e4       	ldi	r28, 0x40	; 64
 34a:	d6 e0       	ldi	r29, 0x06	; 6
}

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
	for (uint8_t i = 0; i < 3; i++) {
		if (LEDArray[i].blinkInterval != 0) {
 34c:	d8 2e       	mov	r13, r24
 34e:	df 01       	movw	r26, r30
 350:	20 81       	ld	r18, Z
 352:	31 81       	ldd	r19, Z+1	; 0x01
 354:	21 15       	cp	r18, r1
 356:	31 05       	cpc	r19, r1
 358:	99 f1       	breq	.+102    	; 0x3c0 <blink_ms_timer_update+0xaa>
			if (lastTime < globalTime) {
 35a:	40 91 0d 20 	lds	r20, 0x200D
 35e:	50 91 0e 20 	lds	r21, 0x200E
 362:	60 91 0f 20 	lds	r22, 0x200F
 366:	70 91 10 20 	lds	r23, 0x2010
 36a:	84 16       	cp	r8, r20
 36c:	95 06       	cpc	r9, r21
 36e:	a6 06       	cpc	r10, r22
 370:	b7 06       	cpc	r11, r23
 372:	90 f4       	brcc	.+36     	; 0x398 <blink_ms_timer_update+0x82>
				LEDArray[i].counter += (globalTime - lastTime); 
 374:	40 91 0d 20 	lds	r20, 0x200D
 378:	50 91 0e 20 	lds	r21, 0x200E
 37c:	60 91 0f 20 	lds	r22, 0x200F
 380:	70 91 10 20 	lds	r23, 0x2010
 384:	48 19       	sub	r20, r8
 386:	59 09       	sbc	r21, r9
 388:	6a 09       	sbc	r22, r10
 38a:	7b 09       	sbc	r23, r11
 38c:	e2 80       	ldd	r14, Z+2	; 0x02
 38e:	f3 80       	ldd	r15, Z+3	; 0x03
 390:	4e 0d       	add	r20, r14
 392:	5f 1d       	adc	r21, r15
 394:	42 83       	std	Z+2, r20	; 0x02
 396:	53 83       	std	Z+3, r21	; 0x03
				}
			if (LEDArray[i].counter >= LEDArray[i].blinkInterval) {
 398:	12 96       	adiw	r26, 0x02	; 2
 39a:	4d 91       	ld	r20, X+
 39c:	5c 91       	ld	r21, X
 39e:	13 97       	sbiw	r26, 0x03	; 3
 3a0:	42 17       	cp	r20, r18
 3a2:	53 07       	cpc	r21, r19
 3a4:	68 f0       	brcs	.+26     	; 0x3c0 <blink_ms_timer_update+0xaa>
				LEDArray[i].counter = LEDArray[i].counter-LEDArray[i].blinkInterval;
 3a6:	42 1b       	sub	r20, r18
 3a8:	53 0b       	sbc	r21, r19
 3aa:	12 96       	adiw	r26, 0x02	; 2
 3ac:	4d 93       	st	X+, r20
 3ae:	5c 93       	st	X, r21
 3b0:	13 97       	sbiw	r26, 0x03	; 3
				led_toggle(0b1 << (i));
 3b2:	98 01       	movw	r18, r16
 3b4:	02 c0       	rjmp	.+4      	; 0x3ba <blink_ms_timer_update+0xa4>
 3b6:	22 0f       	add	r18, r18
 3b8:	33 1f       	adc	r19, r19
 3ba:	da 94       	dec	r13
 3bc:	e2 f7       	brpl	.-8      	; 0x3b6 <blink_ms_timer_update+0xa0>
 3be:	2f 83       	std	Y+7, r18	; 0x07
 3c0:	01 96       	adiw	r24, 0x01	; 1
 3c2:	34 96       	adiw	r30, 0x04	; 4
	}
}

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
	for (uint8_t i = 0; i < 3; i++) {
 3c4:	83 30       	cpi	r24, 0x03	; 3
 3c6:	91 05       	cpc	r25, r1
 3c8:	09 f6       	brne	.-126    	; 0x34c <blink_ms_timer_update+0x36>
				LEDArray[i].counter = LEDArray[i].counter-LEDArray[i].blinkInterval;
				led_toggle(0b1 << (i));
			}
		}
	}
	lastTime = globalTime;
 3ca:	80 91 0d 20 	lds	r24, 0x200D
 3ce:	90 91 0e 20 	lds	r25, 0x200E
 3d2:	a0 91 0f 20 	lds	r26, 0x200F
 3d6:	b0 91 10 20 	lds	r27, 0x2010
 3da:	80 93 11 20 	sts	0x2011, r24
 3de:	90 93 12 20 	sts	0x2012, r25
 3e2:	a0 93 13 20 	sts	0x2013, r26
 3e6:	b0 93 14 20 	sts	0x2014, r27
 3ea:	df 91       	pop	r29
 3ec:	cf 91       	pop	r28
 3ee:	1f 91       	pop	r17
 3f0:	0f 91       	pop	r16
 3f2:	ff 90       	pop	r15
 3f4:	ef 90       	pop	r14
 3f6:	df 90       	pop	r13
 3f8:	bf 90       	pop	r11
 3fa:	af 90       	pop	r10
 3fc:	9f 90       	pop	r9
 3fe:	8f 90       	pop	r8
 400:	08 95       	ret

00000402 <main>:
#include "../../timer.c"
#include "../../blink.c"

int main(void)
{
	sei();
 402:	78 94       	sei
	PMIC.CTRL = PMIC.CTRL | 0b111;
 404:	e0 ea       	ldi	r30, 0xA0	; 160
 406:	f0 e0       	ldi	r31, 0x00	; 0
 408:	82 81       	ldd	r24, Z+2	; 0x02
 40a:	87 60       	ori	r24, 0x07	; 7
 40c:	82 83       	std	Z+2, r24	; 0x02
	
	led_init();
 40e:	0e 94 14 01 	call	0x228	; 0x228 <led_init>
	blink_init();
 412:	0e 94 20 01 	call	0x240	; 0x240 <blink_init>
	blink_set(LED_GREEN_bm, 100);
 416:	64 e6       	ldi	r22, 0x64	; 100
 418:	70 e0       	ldi	r23, 0x00	; 0
 41a:	81 e0       	ldi	r24, 0x01	; 1
 41c:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <blink_set>
	blink_set(LED_YELLOW_bm, 250);
 420:	6a ef       	ldi	r22, 0xFA	; 250
 422:	70 e0       	ldi	r23, 0x00	; 0
 424:	82 e0       	ldi	r24, 0x02	; 2
 426:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <blink_set>
	blink_set(LED_RED_bm, 500);
 42a:	64 ef       	ldi	r22, 0xF4	; 244
 42c:	71 e0       	ldi	r23, 0x01	; 1
 42e:	84 e0       	ldi	r24, 0x04	; 4
 430:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <blink_set>

    while (1) 
    {
		if(checkBlink == 1) {
 434:	80 91 0c 20 	lds	r24, 0x200C
 438:	81 30       	cpi	r24, 0x01	; 1
 43a:	e1 f7       	brne	.-8      	; 0x434 <main+0x32>
			blink_ms_timer_update();
 43c:	0e 94 8b 01 	call	0x316	; 0x316 <blink_ms_timer_update>
			checkBlink = 0;
 440:	10 92 0c 20 	sts	0x200C, r1
 444:	f7 cf       	rjmp	.-18     	; 0x434 <main+0x32>

00000446 <__udivmodsi4>:
 446:	a1 e2       	ldi	r26, 0x21	; 33
 448:	1a 2e       	mov	r1, r26
 44a:	aa 1b       	sub	r26, r26
 44c:	bb 1b       	sub	r27, r27
 44e:	fd 01       	movw	r30, r26
 450:	0d c0       	rjmp	.+26     	; 0x46c <__udivmodsi4_ep>

00000452 <__udivmodsi4_loop>:
 452:	aa 1f       	adc	r26, r26
 454:	bb 1f       	adc	r27, r27
 456:	ee 1f       	adc	r30, r30
 458:	ff 1f       	adc	r31, r31
 45a:	a2 17       	cp	r26, r18
 45c:	b3 07       	cpc	r27, r19
 45e:	e4 07       	cpc	r30, r20
 460:	f5 07       	cpc	r31, r21
 462:	20 f0       	brcs	.+8      	; 0x46c <__udivmodsi4_ep>
 464:	a2 1b       	sub	r26, r18
 466:	b3 0b       	sbc	r27, r19
 468:	e4 0b       	sbc	r30, r20
 46a:	f5 0b       	sbc	r31, r21

0000046c <__udivmodsi4_ep>:
 46c:	66 1f       	adc	r22, r22
 46e:	77 1f       	adc	r23, r23
 470:	88 1f       	adc	r24, r24
 472:	99 1f       	adc	r25, r25
 474:	1a 94       	dec	r1
 476:	69 f7       	brne	.-38     	; 0x452 <__udivmodsi4_loop>
 478:	60 95       	com	r22
 47a:	70 95       	com	r23
 47c:	80 95       	com	r24
 47e:	90 95       	com	r25
 480:	9b 01       	movw	r18, r22
 482:	ac 01       	movw	r20, r24
 484:	bd 01       	movw	r22, r26
 486:	cf 01       	movw	r24, r30
 488:	08 95       	ret

0000048a <_exit>:
 48a:	f8 94       	cli

0000048c <__stop_program>:
 48c:	ff cf       	rjmp	.-2      	; 0x48c <__stop_program>
