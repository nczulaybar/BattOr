
BattOrProject1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000041a  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00802000  00802000  0000048e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000015  00802000  00802000  0000048e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000048e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000004c0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000f0  00000000  00000000  00000500  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000019a2  00000000  00000000  000005f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000654  00000000  00000000  00001f92  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000060e  00000000  00000000  000025e6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000188  00000000  00000000  00002bf4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006e3  00000000  00000000  00002d7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000024b  00000000  00000000  0000345f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000a0  00000000  00000000  000036aa  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
   8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
   c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  10:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  14:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  18:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  1c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  20:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  24:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  28:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  2c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  30:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  34:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  38:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  3c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  40:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  44:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  48:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  4c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  50:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  54:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  58:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  5c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  60:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  64:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  68:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  6c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  70:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  74:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  78:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  7c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  80:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  84:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  88:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  8c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  90:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  94:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  98:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  9c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  a0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  a4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  a8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  ac:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  b0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  b4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  b8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  bc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  c0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  c4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  c8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  cc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  d0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  d4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  d8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  dc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  e0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  e4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  e8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  ec:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  f0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  f4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  f8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  fc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 100:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 104:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 108:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 10c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 110:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 114:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 118:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 11c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 120:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 124:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 128:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 12c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 130:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 134:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 138:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 13c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 140:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 144:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 148:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 14c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 150:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 154:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 158:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 15c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 160:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 164:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 168:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 16c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 170:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 174:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 178:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 17c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 180:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 184:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 188:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 18c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 190:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 194:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 198:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 19c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1a0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1a4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1a8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1ac:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1b0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1b4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1b8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1bc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1c0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1c4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1c8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1cc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1d0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1d4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1d8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1dc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1e0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1e4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1e8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1ec:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1f0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1f4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1f8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e5       	ldi	r29, 0x5F	; 95
 206:	de bf       	out	0x3e, r29	; 62
 208:	00 e0       	ldi	r16, 0x00	; 0
 20a:	0c bf       	out	0x3c, r16	; 60

0000020c <__do_clear_bss>:
 20c:	20 e2       	ldi	r18, 0x20	; 32
 20e:	a0 e0       	ldi	r26, 0x00	; 0
 210:	b0 e2       	ldi	r27, 0x20	; 32
 212:	01 c0       	rjmp	.+2      	; 0x216 <.do_clear_bss_start>

00000214 <.do_clear_bss_loop>:
 214:	1d 92       	st	X+, r1

00000216 <.do_clear_bss_start>:
 216:	a5 31       	cpi	r26, 0x15	; 21
 218:	b2 07       	cpc	r27, r18
 21a:	e1 f7       	brne	.-8      	; 0x214 <.do_clear_bss_loop>
 21c:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <main>
 220:	0c 94 0b 02 	jmp	0x416	; 0x416 <_exit>

00000224 <__bad_interrupt>:
 224:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000228 <blink_init>:
volatile uint8_t checkBlink;
uint32_t lastTime;

//Initialize the state of all of the LEDs in local state of the blink library to have their blinks disabled. Also, setup a timer that will fire an interrupt once every millisecond. Note that the timer is clocked off of the peripheral clock, and the peripheral clock is clocked off of the system clock.
void blink_init(){
	timer_init(&TCC0, 0b11); //high interrupt level
 228:	63 e0       	ldi	r22, 0x03	; 3
 22a:	80 e0       	ldi	r24, 0x00	; 0
 22c:	98 e0       	ldi	r25, 0x08	; 8
 22e:	0e 94 fe 01 	call	0x3fc	; 0x3fc <timer_init>
	timer_set(&TCC0, 0b1, 2000); //2000 ticks corresponds to 1ms, as of 10/15 10:32pm
 232:	40 ed       	ldi	r20, 0xD0	; 208
 234:	57 e0       	ldi	r21, 0x07	; 7
 236:	61 e0       	ldi	r22, 0x01	; 1
 238:	80 e0       	ldi	r24, 0x00	; 0
 23a:	98 e0       	ldi	r25, 0x08	; 8
 23c:	0e 94 05 02 	call	0x40a	; 0x40a <timer_set>
 240:	08 95       	ret

00000242 <blink_set>:
	}
	return 0;
}

//Set the specified led to blink at the specified interval_ms.
void blink_set(uint8_t led, uint16_t interval_ms) {
 242:	e0 e0       	ldi	r30, 0x00	; 0
 244:	f0 e2       	ldi	r31, 0x20	; 32
 246:	4c e0       	ldi	r20, 0x0C	; 12
 248:	50 e2       	ldi	r21, 0x20	; 32
	uint8_t i = 0;
	for (uint8_t pos = 0b1; pos < 0b1000; pos = pos << 1) {
 24a:	91 e0       	ldi	r25, 0x01	; 1
		if(pos & led) LEDArray[i].blinkInterval = interval_ms;
 24c:	29 2f       	mov	r18, r25
 24e:	28 23       	and	r18, r24
 250:	11 f0       	breq	.+4      	; 0x256 <blink_set+0x14>
 252:	60 83       	st	Z, r22
 254:	71 83       	std	Z+1, r23	; 0x01
}

//Set the specified led to blink at the specified interval_ms.
void blink_set(uint8_t led, uint16_t interval_ms) {
	uint8_t i = 0;
	for (uint8_t pos = 0b1; pos < 0b1000; pos = pos << 1) {
 256:	99 0f       	add	r25, r25
 258:	34 96       	adiw	r30, 0x04	; 4
 25a:	e4 17       	cp	r30, r20
 25c:	f5 07       	cpc	r31, r21
 25e:	b1 f7       	brne	.-20     	; 0x24c <blink_set+0xa>
		if(pos & led) LEDArray[i].blinkInterval = interval_ms;
		i++;
	}
}
 260:	08 95       	ret

00000262 <blink_ms_timer_update>:

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
 262:	8f 92       	push	r8
 264:	9f 92       	push	r9
 266:	af 92       	push	r10
 268:	bf 92       	push	r11
 26a:	ef 92       	push	r14
 26c:	ff 92       	push	r15
 26e:	0f 93       	push	r16
 270:	1f 93       	push	r17
 272:	cf 93       	push	r28
 274:	df 93       	push	r29
 276:	00 e0       	ldi	r16, 0x00	; 0
 278:	10 e2       	ldi	r17, 0x20	; 32
 27a:	c0 e0       	ldi	r28, 0x00	; 0
 27c:	d0 e0       	ldi	r29, 0x00	; 0
			if (lastTime < globalTime) {
				LEDArray[i].counter += (globalTime - lastTime); 
				}
			if (LEDArray[i].counter >= LEDArray[i].blinkInterval) {
				LEDArray[i].counter = LEDArray[i].counter-LEDArray[i].blinkInterval;
				led_toggle(0b1 << (i));
 27e:	ff 24       	eor	r15, r15
 280:	f3 94       	inc	r15
}

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
	for (uint8_t i = 0; i < 3; i++) {
		if (LEDArray[i].blinkInterval != 0) {
 282:	ec 2e       	mov	r14, r28
 284:	f8 01       	movw	r30, r16
 286:	80 81       	ld	r24, Z
 288:	91 81       	ldd	r25, Z+1	; 0x01
 28a:	00 97       	sbiw	r24, 0x00	; 0
 28c:	b9 f1       	breq	.+110    	; 0x2fc <blink_ms_timer_update+0x9a>
			if (lastTime < globalTime) {
 28e:	80 90 11 20 	lds	r8, 0x2011
 292:	90 90 12 20 	lds	r9, 0x2012
 296:	a0 90 13 20 	lds	r10, 0x2013
 29a:	b0 90 14 20 	lds	r11, 0x2014
 29e:	40 91 0d 20 	lds	r20, 0x200D
 2a2:	50 91 0e 20 	lds	r21, 0x200E
 2a6:	60 91 0f 20 	lds	r22, 0x200F
 2aa:	70 91 10 20 	lds	r23, 0x2010
 2ae:	84 16       	cp	r8, r20
 2b0:	95 06       	cpc	r9, r21
 2b2:	a6 06       	cpc	r10, r22
 2b4:	b7 06       	cpc	r11, r23
 2b6:	90 f4       	brcc	.+36     	; 0x2dc <blink_ms_timer_update+0x7a>
				LEDArray[i].counter += (globalTime - lastTime); 
 2b8:	40 91 0d 20 	lds	r20, 0x200D
 2bc:	50 91 0e 20 	lds	r21, 0x200E
 2c0:	60 91 0f 20 	lds	r22, 0x200F
 2c4:	70 91 10 20 	lds	r23, 0x2010
 2c8:	48 19       	sub	r20, r8
 2ca:	59 09       	sbc	r21, r9
 2cc:	6a 09       	sbc	r22, r10
 2ce:	7b 09       	sbc	r23, r11
 2d0:	22 81       	ldd	r18, Z+2	; 0x02
 2d2:	33 81       	ldd	r19, Z+3	; 0x03
 2d4:	42 0f       	add	r20, r18
 2d6:	53 1f       	adc	r21, r19
 2d8:	42 83       	std	Z+2, r20	; 0x02
 2da:	53 83       	std	Z+3, r21	; 0x03
				}
			if (LEDArray[i].counter >= LEDArray[i].blinkInterval) {
 2dc:	22 81       	ldd	r18, Z+2	; 0x02
 2de:	33 81       	ldd	r19, Z+3	; 0x03
 2e0:	28 17       	cp	r18, r24
 2e2:	39 07       	cpc	r19, r25
 2e4:	58 f0       	brcs	.+22     	; 0x2fc <blink_ms_timer_update+0x9a>
				LEDArray[i].counter = LEDArray[i].counter-LEDArray[i].blinkInterval;
 2e6:	28 1b       	sub	r18, r24
 2e8:	39 0b       	sbc	r19, r25
 2ea:	22 83       	std	Z+2, r18	; 0x02
 2ec:	33 83       	std	Z+3, r19	; 0x03
				led_toggle(0b1 << (i));
 2ee:	8f 2d       	mov	r24, r15
 2f0:	01 c0       	rjmp	.+2      	; 0x2f4 <blink_ms_timer_update+0x92>
 2f2:	88 0f       	add	r24, r24
 2f4:	ea 94       	dec	r14
 2f6:	ea f7       	brpl	.-6      	; 0x2f2 <blink_ms_timer_update+0x90>
 2f8:	0e 94 d6 01 	call	0x3ac	; 0x3ac <led_toggle>
 2fc:	21 96       	adiw	r28, 0x01	; 1
 2fe:	0c 5f       	subi	r16, 0xFC	; 252
 300:	1f 4f       	sbci	r17, 0xFF	; 255
	}
}

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
	for (uint8_t i = 0; i < 3; i++) {
 302:	c3 30       	cpi	r28, 0x03	; 3
 304:	d1 05       	cpc	r29, r1
 306:	09 f0       	breq	.+2      	; 0x30a <blink_ms_timer_update+0xa8>
 308:	bc cf       	rjmp	.-136    	; 0x282 <blink_ms_timer_update+0x20>
				LEDArray[i].counter = LEDArray[i].counter-LEDArray[i].blinkInterval;
				led_toggle(0b1 << (i));
			}
		}
	}
	lastTime = globalTime;
 30a:	80 91 0d 20 	lds	r24, 0x200D
 30e:	90 91 0e 20 	lds	r25, 0x200E
 312:	a0 91 0f 20 	lds	r26, 0x200F
 316:	b0 91 10 20 	lds	r27, 0x2010
 31a:	80 93 11 20 	sts	0x2011, r24
 31e:	90 93 12 20 	sts	0x2012, r25
 322:	a0 93 13 20 	sts	0x2013, r26
 326:	b0 93 14 20 	sts	0x2014, r27
 32a:	df 91       	pop	r29
 32c:	cf 91       	pop	r28
 32e:	1f 91       	pop	r17
 330:	0f 91       	pop	r16
 332:	ff 90       	pop	r15
 334:	ef 90       	pop	r14
 336:	bf 90       	pop	r11
 338:	af 90       	pop	r10
 33a:	9f 90       	pop	r9
 33c:	8f 90       	pop	r8
 33e:	08 95       	ret

00000340 <gpio_set_mode>:
#include <stdint.h>
#include <avr/io.h>

//Set the specified pin on the specified port to be in output (1) or input (0) mode.
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in){
  if(out_or_in) port->DIRSET = pin;
 340:	44 23       	and	r20, r20
 342:	19 f0       	breq	.+6      	; 0x34a <gpio_set_mode+0xa>
 344:	fc 01       	movw	r30, r24
 346:	61 83       	std	Z+1, r22	; 0x01
 348:	08 95       	ret
  else port->DIRCLR = pin;
 34a:	fc 01       	movw	r30, r24
 34c:	62 83       	std	Z+2, r22	; 0x02
 34e:	08 95       	ret

00000350 <gpio_set_out>:
}

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
/* inline */ void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
  if(on_or_off) port->OUTSET = pin;
 350:	44 23       	and	r20, r20
 352:	19 f0       	breq	.+6      	; 0x35a <gpio_set_out+0xa>
 354:	fc 01       	movw	r30, r24
 356:	65 83       	std	Z+5, r22	; 0x05
 358:	08 95       	ret
  else port->OUTCLR = pin;
 35a:	fc 01       	movw	r30, r24
 35c:	66 83       	std	Z+6, r22	; 0x06
 35e:	08 95       	ret

00000360 <gpio_toggle_out>:
}

//If the specified pin on the specified port is in output mode, toggle the pinâ€™s state (if 1 then 0, if 0 then 1).
/* inline */ void gpio_toggle_out(PORT_t* port, uint8_t pin){
	port->OUTTGL=pin;
 360:	fc 01       	movw	r30, r24
 362:	67 83       	std	Z+7, r22	; 0x07
 364:	08 95       	ret

00000366 <led_off>:
	gpio_set_out(&PORTC, led, 0);	
}

//Turn off the specified led.
void led_off(uint8_t led){
	gpio_set_out(&PORTC, led, 1);
 366:	41 e0       	ldi	r20, 0x01	; 1
 368:	68 2f       	mov	r22, r24
 36a:	80 e4       	ldi	r24, 0x40	; 64
 36c:	96 e0       	ldi	r25, 0x06	; 6
 36e:	0e 94 a8 01 	call	0x350	; 0x350 <gpio_set_out>
 372:	08 95       	ret

00000374 <led_init>:
	}
};

//Setup all of the LEDs so they are in output mode and off.
void led_init(){
	gpio_set_mode(&PORTC, LED_GREEN_bm, 1);
 374:	41 e0       	ldi	r20, 0x01	; 1
 376:	61 e0       	ldi	r22, 0x01	; 1
 378:	80 e4       	ldi	r24, 0x40	; 64
 37a:	96 e0       	ldi	r25, 0x06	; 6
 37c:	0e 94 a0 01 	call	0x340	; 0x340 <gpio_set_mode>
	gpio_set_mode(&PORTC, LED_YELLOW_bm, 1);
 380:	41 e0       	ldi	r20, 0x01	; 1
 382:	62 e0       	ldi	r22, 0x02	; 2
 384:	80 e4       	ldi	r24, 0x40	; 64
 386:	96 e0       	ldi	r25, 0x06	; 6
 388:	0e 94 a0 01 	call	0x340	; 0x340 <gpio_set_mode>
	gpio_set_mode(&PORTC, LED_RED_bm, 1);
 38c:	41 e0       	ldi	r20, 0x01	; 1
 38e:	64 e0       	ldi	r22, 0x04	; 4
 390:	80 e4       	ldi	r24, 0x40	; 64
 392:	96 e0       	ldi	r25, 0x06	; 6
 394:	0e 94 a0 01 	call	0x340	; 0x340 <gpio_set_mode>
	led_off(LED_GREEN_bm);
 398:	81 e0       	ldi	r24, 0x01	; 1
 39a:	0e 94 b3 01 	call	0x366	; 0x366 <led_off>
	led_off(LED_YELLOW_bm);
 39e:	82 e0       	ldi	r24, 0x02	; 2
 3a0:	0e 94 b3 01 	call	0x366	; 0x366 <led_off>
	led_off(LED_RED_bm);
 3a4:	84 e0       	ldi	r24, 0x04	; 4
 3a6:	0e 94 b3 01 	call	0x366	; 0x366 <led_off>
 3aa:	08 95       	ret

000003ac <led_toggle>:
	gpio_set_out(&PORTC, led, 1);
}

//Toggle the specified led on and off.
void led_toggle(uint8_t led){
	gpio_toggle_out(&PORTC, led);
 3ac:	68 2f       	mov	r22, r24
 3ae:	80 e4       	ldi	r24, 0x40	; 64
 3b0:	96 e0       	ldi	r25, 0x06	; 6
 3b2:	0e 94 b0 01 	call	0x360	; 0x360 <gpio_toggle_out>
 3b6:	08 95       	ret

000003b8 <main>:
volatile uint8_t checkBlink;
uint32_t lastTime;

int main(void)
{
	sei();
 3b8:	78 94       	sei
	PMIC.CTRL = PMIC.CTRL | 0b111;
 3ba:	e0 ea       	ldi	r30, 0xA0	; 160
 3bc:	f0 e0       	ldi	r31, 0x00	; 0
 3be:	82 81       	ldd	r24, Z+2	; 0x02
 3c0:	87 60       	ori	r24, 0x07	; 7
 3c2:	82 83       	std	Z+2, r24	; 0x02

	led_init();
 3c4:	0e 94 ba 01 	call	0x374	; 0x374 <led_init>
	blink_init();
 3c8:	0e 94 14 01 	call	0x228	; 0x228 <blink_init>
	blink_set(LED_GREEN_bm, 100);
 3cc:	64 e6       	ldi	r22, 0x64	; 100
 3ce:	70 e0       	ldi	r23, 0x00	; 0
 3d0:	81 e0       	ldi	r24, 0x01	; 1
 3d2:	0e 94 21 01 	call	0x242	; 0x242 <blink_set>
	blink_set(LED_YELLOW_bm, 250);
 3d6:	6a ef       	ldi	r22, 0xFA	; 250
 3d8:	70 e0       	ldi	r23, 0x00	; 0
 3da:	82 e0       	ldi	r24, 0x02	; 2
 3dc:	0e 94 21 01 	call	0x242	; 0x242 <blink_set>
	blink_set(LED_RED_bm, 500);
 3e0:	64 ef       	ldi	r22, 0xF4	; 244
 3e2:	71 e0       	ldi	r23, 0x01	; 1
 3e4:	84 e0       	ldi	r24, 0x04	; 4
 3e6:	0e 94 21 01 	call	0x242	; 0x242 <blink_set>

    while (1)
    {
		if(checkBlink == 1) {
 3ea:	80 91 0c 20 	lds	r24, 0x200C
 3ee:	81 30       	cpi	r24, 0x01	; 1
 3f0:	e1 f7       	brne	.-8      	; 0x3ea <main+0x32>
			blink_ms_timer_update();
 3f2:	0e 94 31 01 	call	0x262	; 0x262 <blink_ms_timer_update>
			checkBlink = 0;
 3f6:	10 92 0c 20 	sts	0x200C, r1
 3fa:	f7 cf       	rjmp	.-18     	; 0x3ea <main+0x32>

000003fc <timer_init>:
#include <stdint.h>
#include <avr/io.h>

//Setup the specified timer peripheral. Clear out any timer state and reset all counters. Set it to have the specified interrupt_level.
void timer_init(TC0_t* timer, uint8_t int_level){
 3fc:	fc 01       	movw	r30, r24
	timer->CTRLFSET = timer->CTRLFSET | 0b1000; //Executes reset command on CTRLFSet, see p179
 3fe:	81 85       	ldd	r24, Z+9	; 0x09
 400:	88 60       	ori	r24, 0x08	; 8
 402:	81 87       	std	Z+9, r24	; 0x09
	timer->INTCTRLA = 0b1 & int_level; //Enables overflow interrupt. See p134.
 404:	61 70       	andi	r22, 0x01	; 1
 406:	66 83       	std	Z+6, r22	; 0x06
 408:	08 95       	ret

0000040a <timer_set>:
	setBit(timer->CTRLFSET, 0b1000, 1); //Executes restart command on CTRLFSet, see p179
}

//Takes in period as time in microseconds between every overflow interrupt.
void timer_set(TC0_t* timer, uint8_t prescaler, uint16_t period){
	timer->CTRLA = (0b00000111 & prescaler); //Set prescaler by setting lower 3 bits of CLKSel;
 40a:	67 70       	andi	r22, 0x07	; 7
 40c:	fc 01       	movw	r30, r24
 40e:	60 83       	st	Z, r22
	timer->PER = period;
 410:	46 a3       	std	Z+38, r20	; 0x26
 412:	57 a3       	std	Z+39, r21	; 0x27
 414:	08 95       	ret

00000416 <_exit>:
 416:	f8 94       	cli

00000418 <__stop_program>:
 418:	ff cf       	rjmp	.-2      	; 0x418 <__stop_program>
