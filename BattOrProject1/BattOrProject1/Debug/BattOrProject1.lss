
BattOrProject1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003e8  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00802000  00802000  0000045c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000014  00802000  00802000  0000045c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000045c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000048c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000080  00000000  00000000  000004cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000010fb  00000000  00000000  0000054c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000002a2  00000000  00000000  00001647  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000028a  00000000  00000000  000018e9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000128  00000000  00000000  00001b74  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006da  00000000  00000000  00001c9c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000049a  00000000  00000000  00002376  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000070  00000000  00000000  00002810  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
   8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
   c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  10:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  14:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  18:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  1c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  20:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  24:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  28:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  2c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  30:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  34:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  38:	0c 94 54 01 	jmp	0x2a8	; 0x2a8 <__vector_14>
  3c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  40:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  44:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  48:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  4c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  50:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  54:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  58:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  5c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  60:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  64:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  68:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  6c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  70:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  74:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  78:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  7c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  80:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  84:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  88:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  8c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  90:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  94:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  98:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  9c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  a0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  a4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  a8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  ac:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  b0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  b4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  b8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  bc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  c0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  c4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  c8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  cc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  d0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  d4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  d8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  dc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  e0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  e4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  e8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  ec:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  f0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  f4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  f8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  fc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 100:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 104:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 108:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 10c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 110:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 114:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 118:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 11c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 120:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 124:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 128:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 12c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 130:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 134:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 138:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 13c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 140:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 144:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 148:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 14c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 150:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 154:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 158:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 15c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 160:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 164:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 168:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 16c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 170:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 174:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 178:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 17c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 180:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 184:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 188:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 18c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 190:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 194:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 198:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 19c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1a0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1a4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1a8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1ac:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1b0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1b4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1b8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1bc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1c0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1c4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1c8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1cc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1d0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1d4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1d8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1dc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1e0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1e4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1e8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1ec:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1f0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1f4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1f8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e5       	ldi	r29, 0x5F	; 95
 206:	de bf       	out	0x3e, r29	; 62
 208:	00 e0       	ldi	r16, 0x00	; 0
 20a:	0c bf       	out	0x3c, r16	; 60

0000020c <__do_clear_bss>:
 20c:	20 e2       	ldi	r18, 0x20	; 32
 20e:	a0 e0       	ldi	r26, 0x00	; 0
 210:	b0 e2       	ldi	r27, 0x20	; 32
 212:	01 c0       	rjmp	.+2      	; 0x216 <.do_clear_bss_start>

00000214 <.do_clear_bss_loop>:
 214:	1d 92       	st	X+, r1

00000216 <.do_clear_bss_start>:
 216:	a4 31       	cpi	r26, 0x14	; 20
 218:	b2 07       	cpc	r27, r18
 21a:	e1 f7       	brne	.-8      	; 0x214 <.do_clear_bss_loop>
 21c:	0e 94 d7 01 	call	0x3ae	; 0x3ae <main>
 220:	0c 94 f2 01 	jmp	0x3e4	; 0x3e4 <_exit>

00000224 <__bad_interrupt>:
 224:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000228 <led_off>:
  port->DIR =  setBit(port->DIR, pin, out_or_in);
}

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
  if(getBit(port->DIR, pin))
 228:	90 91 40 06 	lds	r25, 0x0640
  }
}

//returns value of bit at a specified position in a specified uint8_t
inline uint8_t getBit(uint8_t target, uint8_t requestedBit){
  return (target & requestedBit);
 22c:	98 23       	and	r25, r24
  port->DIR =  setBit(port->DIR, pin, out_or_in);
}

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
  if(getBit(port->DIR, pin))
 22e:	29 f0       	breq	.+10     	; 0x23a <led_off+0x12>
    port->OUT = setBit(port->OUT, pin, on_or_off);
 230:	e0 e4       	ldi	r30, 0x40	; 64
 232:	f6 e0       	ldi	r31, 0x06	; 6
 234:	94 81       	ldd	r25, Z+4	; 0x04
}

//sets value of bit at a specified position in a specified uint8_t and returns changed uint8_t
inline uint8_t setBit(uint8_t target, uint8_t requestedBit, uint8_t requestedValue){
	uint8_t setValue = (requestedValue == 0) ? requestedBit : 0;
  return (target | requestedBit) & (0b11111111 ^ setValue); //could we do ~setValue
 236:	89 2b       	or	r24, r25
}

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
  if(getBit(port->DIR, pin))
    port->OUT = setBit(port->OUT, pin, on_or_off);
 238:	84 83       	std	Z+4, r24	; 0x04
 23a:	08 95       	ret

0000023c <led_init>:
//Set the specified pin on the specified port to be in output (1) or input (0) mode.
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in){
  port->DIR =  setBit(port->DIR, pin, out_or_in);
 23c:	e0 e4       	ldi	r30, 0x40	; 64
 23e:	f6 e0       	ldi	r31, 0x06	; 6
 240:	80 81       	ld	r24, Z
}

//sets value of bit at a specified position in a specified uint8_t and returns changed uint8_t
inline uint8_t setBit(uint8_t target, uint8_t requestedBit, uint8_t requestedValue){
	uint8_t setValue = (requestedValue == 0) ? requestedBit : 0;
  return (target | requestedBit) & (0b11111111 ^ setValue); //could we do ~setValue
 242:	81 60       	ori	r24, 0x01	; 1
//Set the specified pin on the specified port to be in output (1) or input (0) mode.
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in){
  port->DIR =  setBit(port->DIR, pin, out_or_in);
 244:	80 83       	st	Z, r24
 246:	80 81       	ld	r24, Z
}

//sets value of bit at a specified position in a specified uint8_t and returns changed uint8_t
inline uint8_t setBit(uint8_t target, uint8_t requestedBit, uint8_t requestedValue){
	uint8_t setValue = (requestedValue == 0) ? requestedBit : 0;
  return (target | requestedBit) & (0b11111111 ^ setValue); //could we do ~setValue
 248:	82 60       	ori	r24, 0x02	; 2
//Set the specified pin on the specified port to be in output (1) or input (0) mode.
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in){
  port->DIR =  setBit(port->DIR, pin, out_or_in);
 24a:	80 83       	st	Z, r24
 24c:	80 81       	ld	r24, Z
}

//sets value of bit at a specified position in a specified uint8_t and returns changed uint8_t
inline uint8_t setBit(uint8_t target, uint8_t requestedBit, uint8_t requestedValue){
	uint8_t setValue = (requestedValue == 0) ? requestedBit : 0;
  return (target | requestedBit) & (0b11111111 ^ setValue); //could we do ~setValue
 24e:	84 60       	ori	r24, 0x04	; 4
//Set the specified pin on the specified port to be in output (1) or input (0) mode.
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in){
  port->DIR =  setBit(port->DIR, pin, out_or_in);
 250:	80 83       	st	Z, r24
//Setup all of the LEDs so they are in output mode and off.
void led_init(){
	gpio_set_mode(&PORTC, LED_GREEN_bm, 1);
	gpio_set_mode(&PORTC, LED_YELLOW_bm, 1);
	gpio_set_mode(&PORTC, LED_RED_bm, 1);
	led_off(LED_GREEN_bm);
 252:	81 e0       	ldi	r24, 0x01	; 1
 254:	0e 94 14 01 	call	0x228	; 0x228 <led_off>
	led_off(LED_YELLOW_bm);
 258:	82 e0       	ldi	r24, 0x02	; 2
 25a:	0e 94 14 01 	call	0x228	; 0x228 <led_off>
	led_off(LED_RED_bm);
 25e:	84 e0       	ldi	r24, 0x04	; 4
 260:	0e 94 14 01 	call	0x228	; 0x228 <led_off>
 264:	08 95       	ret

00000266 <led_toggle>:
    port->OUT = setBit(port->OUT, pin, on_or_off);
}

//If the specified pin on the specified port is in output mode, toggle the pin’s state (if 1 then 0, if 0 then 1).
inline void gpio_toggle_out(PORT_t* port, uint8_t pin){
  if(getBit(port->DIR, pin)) {
 266:	90 91 40 06 	lds	r25, 0x0640
  }
}

//returns value of bit at a specified position in a specified uint8_t
inline uint8_t getBit(uint8_t target, uint8_t requestedBit){
  return (target & requestedBit);
 26a:	98 23       	and	r25, r24
    port->OUT = setBit(port->OUT, pin, on_or_off);
}

//If the specified pin on the specified port is in output mode, toggle the pin’s state (if 1 then 0, if 0 then 1).
inline void gpio_toggle_out(PORT_t* port, uint8_t pin){
  if(getBit(port->DIR, pin)) {
 26c:	71 f0       	breq	.+28     	; 0x28a <led_toggle+0x24>
    port->OUT = setBit(port->OUT, pin, !getBit(port->OUT, pin));
 26e:	e0 e4       	ldi	r30, 0x40	; 64
 270:	f6 e0       	ldi	r31, 0x06	; 6
 272:	24 81       	ldd	r18, Z+4	; 0x04
 274:	94 81       	ldd	r25, Z+4	; 0x04
  }
}

//returns value of bit at a specified position in a specified uint8_t
inline uint8_t getBit(uint8_t target, uint8_t requestedBit){
  return (target & requestedBit);
 276:	28 23       	and	r18, r24
}

//sets value of bit at a specified position in a specified uint8_t and returns changed uint8_t
inline uint8_t setBit(uint8_t target, uint8_t requestedBit, uint8_t requestedValue){
	uint8_t setValue = (requestedValue == 0) ? requestedBit : 0;
 278:	11 f0       	breq	.+4      	; 0x27e <led_toggle+0x18>
 27a:	28 2f       	mov	r18, r24
 27c:	01 c0       	rjmp	.+2      	; 0x280 <led_toggle+0x1a>
 27e:	20 e0       	ldi	r18, 0x00	; 0
  return (target | requestedBit) & (0b11111111 ^ setValue); //could we do ~setValue
 280:	20 95       	com	r18
 282:	89 2b       	or	r24, r25
 284:	82 23       	and	r24, r18
}

//If the specified pin on the specified port is in output mode, toggle the pin’s state (if 1 then 0, if 0 then 1).
inline void gpio_toggle_out(PORT_t* port, uint8_t pin){
  if(getBit(port->DIR, pin)) {
    port->OUT = setBit(port->OUT, pin, !getBit(port->OUT, pin));
 286:	80 93 44 06 	sts	0x0644, r24
 28a:	08 95       	ret

0000028c <blink_init>:
//Setup the specified timer peripheral. Clear out any timer state and reset all counters. Set it to have the specified interrupt_level.
void timer_init(TC0_t* timer, uint8_t int_level){
	timer->CTRLFSET = timer->CTRLFSET | 0b1000; //Executes reset command on CTRLFSet, see p179
 28c:	e0 e0       	ldi	r30, 0x00	; 0
 28e:	f8 e0       	ldi	r31, 0x08	; 8
 290:	81 85       	ldd	r24, Z+9	; 0x09
 292:	88 60       	ori	r24, 0x08	; 8
 294:	81 87       	std	Z+9, r24	; 0x09
	timer->INTCTRLA = 0b11 & int_level; //Enables overflow interrupt. Sets to high. See p134.
 296:	83 e0       	ldi	r24, 0x03	; 3
 298:	86 83       	std	Z+6, r24	; 0x06
	setBit(timer->CTRLFSET, 0b1000, 1); //Executes restart command on CTRLFSet, see p179
}

//Takes in period as time in microseconds between every overflow interrupt.
void timer_set(TC0_t* timer, uint8_t prescaler, uint16_t period){
	timer->CTRLA = (0b00000111 & prescaler); //Set prescaler by setting lower 3 bits of CLKSel;
 29a:	81 e0       	ldi	r24, 0x01	; 1
 29c:	80 83       	st	Z, r24
	timer->PER = period;
 29e:	88 ee       	ldi	r24, 0xE8	; 232
 2a0:	93 e0       	ldi	r25, 0x03	; 3
 2a2:	86 a3       	std	Z+38, r24	; 0x26
 2a4:	97 a3       	std	Z+39, r25	; 0x27
 2a6:	08 95       	ret

000002a8 <__vector_14>:
	//Disable blinks
	timer_init(&TCC0, 0b11);
	timer_set(&TCC0, 0b001, 1000);
}

ISR(TCC0_OVF_vect){
 2a8:	1f 92       	push	r1
 2aa:	0f 92       	push	r0
 2ac:	0f b6       	in	r0, 0x3f	; 63
 2ae:	0f 92       	push	r0
 2b0:	11 24       	eor	r1, r1
 2b2:	8f 93       	push	r24
 2b4:	9f 93       	push	r25
 2b6:	af 93       	push	r26
 2b8:	bf 93       	push	r27
	globalTime++;
 2ba:	80 91 0c 20 	lds	r24, 0x200C
 2be:	90 91 0d 20 	lds	r25, 0x200D
 2c2:	a0 91 0e 20 	lds	r26, 0x200E
 2c6:	b0 91 0f 20 	lds	r27, 0x200F
 2ca:	01 96       	adiw	r24, 0x01	; 1
 2cc:	a1 1d       	adc	r26, r1
 2ce:	b1 1d       	adc	r27, r1
 2d0:	80 93 0c 20 	sts	0x200C, r24
 2d4:	90 93 0d 20 	sts	0x200D, r25
 2d8:	a0 93 0e 20 	sts	0x200E, r26
 2dc:	b0 93 0f 20 	sts	0x200F, r27
}
 2e0:	bf 91       	pop	r27
 2e2:	af 91       	pop	r26
 2e4:	9f 91       	pop	r25
 2e6:	8f 91       	pop	r24
 2e8:	0f 90       	pop	r0
 2ea:	0f be       	out	0x3f, r0	; 63
 2ec:	0f 90       	pop	r0
 2ee:	1f 90       	pop	r1
 2f0:	18 95       	reti

000002f2 <blink_ms_timer_update>:
void blink_set(uint8_t led, uint16_t interval_ms){
	LEDArray[led].blinkInterval = interval_ms;
}

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
 2f2:	cf 92       	push	r12
 2f4:	df 92       	push	r13
 2f6:	ef 92       	push	r14
 2f8:	ff 92       	push	r15
 2fa:	1f 93       	push	r17
 2fc:	cf 93       	push	r28
 2fe:	df 93       	push	r29
 300:	c0 e0       	ldi	r28, 0x00	; 0
 302:	d0 e2       	ldi	r29, 0x20	; 32
 304:	10 e0       	ldi	r17, 0x00	; 0
 306:	fe 01       	movw	r30, r28
	for (int i = 0; i < sizeof(LEDArray)/sizeof(LEDArray[0]); ++i) {
		if (LEDArray[i].blinkInterval != 0) {
 308:	88 81       	ld	r24, Y
 30a:	99 81       	ldd	r25, Y+1	; 0x01
 30c:	00 97       	sbiw	r24, 0x00	; 0
 30e:	09 f4       	brne	.+2      	; 0x312 <blink_ms_timer_update+0x20>
 310:	41 c0       	rjmp	.+130    	; 0x394 <blink_ms_timer_update+0xa2>
			if (lastTime < globalTime) {
 312:	c0 90 10 20 	lds	r12, 0x2010
 316:	d0 90 11 20 	lds	r13, 0x2011
 31a:	e0 90 12 20 	lds	r14, 0x2012
 31e:	f0 90 13 20 	lds	r15, 0x2013
 322:	40 91 0c 20 	lds	r20, 0x200C
 326:	50 91 0d 20 	lds	r21, 0x200D
 32a:	60 91 0e 20 	lds	r22, 0x200E
 32e:	70 91 0f 20 	lds	r23, 0x200F
 332:	c4 16       	cp	r12, r20
 334:	d5 06       	cpc	r13, r21
 336:	e6 06       	cpc	r14, r22
 338:	f7 06       	cpc	r15, r23
 33a:	90 f4       	brcc	.+36     	; 0x360 <blink_ms_timer_update+0x6e>
				LEDArray[i].counter += (globalTime - lastTime); }
 33c:	40 91 0c 20 	lds	r20, 0x200C
 340:	50 91 0d 20 	lds	r21, 0x200D
 344:	60 91 0e 20 	lds	r22, 0x200E
 348:	70 91 0f 20 	lds	r23, 0x200F
 34c:	4c 19       	sub	r20, r12
 34e:	5d 09       	sbc	r21, r13
 350:	6e 09       	sbc	r22, r14
 352:	7f 09       	sbc	r23, r15
 354:	2a 81       	ldd	r18, Y+2	; 0x02
 356:	3b 81       	ldd	r19, Y+3	; 0x03
 358:	42 0f       	add	r20, r18
 35a:	53 1f       	adc	r21, r19
 35c:	4a 83       	std	Y+2, r20	; 0x02
 35e:	5b 83       	std	Y+3, r21	; 0x03
			lastTime = globalTime;
 360:	40 91 0c 20 	lds	r20, 0x200C
 364:	50 91 0d 20 	lds	r21, 0x200D
 368:	60 91 0e 20 	lds	r22, 0x200E
 36c:	70 91 0f 20 	lds	r23, 0x200F
 370:	40 93 10 20 	sts	0x2010, r20
 374:	50 93 11 20 	sts	0x2011, r21
 378:	60 93 12 20 	sts	0x2012, r22
 37c:	70 93 13 20 	sts	0x2013, r23
			if (LEDArray[i].counter >= LEDArray[i].blinkInterval) {
 380:	22 81       	ldd	r18, Z+2	; 0x02
 382:	33 81       	ldd	r19, Z+3	; 0x03
 384:	28 17       	cp	r18, r24
 386:	39 07       	cpc	r19, r25
 388:	28 f0       	brcs	.+10     	; 0x394 <blink_ms_timer_update+0xa2>
				LEDArray[i].counter = 0;
 38a:	12 82       	std	Z+2, r1	; 0x02
 38c:	13 82       	std	Z+3, r1	; 0x03
				led_toggle(i);
 38e:	81 2f       	mov	r24, r17
 390:	0e 94 33 01 	call	0x266	; 0x266 <led_toggle>
 394:	24 96       	adiw	r28, 0x04	; 4
 396:	1f 5f       	subi	r17, 0xFF	; 255
	LEDArray[led].blinkInterval = interval_ms;
}

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
	for (int i = 0; i < sizeof(LEDArray)/sizeof(LEDArray[0]); ++i) {
 398:	13 30       	cpi	r17, 0x03	; 3
 39a:	09 f0       	breq	.+2      	; 0x39e <blink_ms_timer_update+0xac>
 39c:	b4 cf       	rjmp	.-152    	; 0x306 <blink_ms_timer_update+0x14>
				LEDArray[i].counter = 0;
				led_toggle(i);
			}
		}
	}
}
 39e:	df 91       	pop	r29
 3a0:	cf 91       	pop	r28
 3a2:	1f 91       	pop	r17
 3a4:	ff 90       	pop	r15
 3a6:	ef 90       	pop	r14
 3a8:	df 90       	pop	r13
 3aa:	cf 90       	pop	r12
 3ac:	08 95       	ret

000003ae <main>:
#include "../../blink.c"

int main(void)
{
	//SREG = SREG | 0b10000000;
	sei(); //Enables interrupts
 3ae:	78 94       	sei
	PMIC.CTRL = PMIC.CTRL | 0b111;
 3b0:	e0 ea       	ldi	r30, 0xA0	; 160
 3b2:	f0 e0       	ldi	r31, 0x00	; 0
 3b4:	82 81       	ldd	r24, Z+2	; 0x02
 3b6:	87 60       	ori	r24, 0x07	; 7
 3b8:	82 83       	std	Z+2, r24	; 0x02
	
	led_init();
 3ba:	0e 94 1e 01 	call	0x23c	; 0x23c <led_init>
	
	//led_on(LED_RED_bm);
	//led_on(LED_GREEN_bm);
	//led_on(LED_YELLOW_bm);
	
	blink_init();
 3be:	0e 94 46 01 	call	0x28c	; 0x28c <blink_init>
//Exactly what we're supposed to do with this is unclear
//Interrupt handler for the timer that you specify [A or B or C or D]. Note that variables that are modified in interrupt handlers must be declared as volatile. For more information about the volatile keyword check out this tutorial.

//Set the specified led to blink at the specified interval_ms.
void blink_set(uint8_t led, uint16_t interval_ms){
	LEDArray[led].blinkInterval = interval_ms;
 3c2:	e0 e0       	ldi	r30, 0x00	; 0
 3c4:	f0 e2       	ldi	r31, 0x20	; 32
 3c6:	80 ed       	ldi	r24, 0xD0	; 208
 3c8:	97 e0       	ldi	r25, 0x07	; 7
 3ca:	80 8b       	std	Z+16, r24	; 0x10
 3cc:	91 8b       	std	Z+17, r25	; 0x11
 3ce:	80 ea       	ldi	r24, 0xA0	; 160
 3d0:	9f e0       	ldi	r25, 0x0F	; 15
 3d2:	84 83       	std	Z+4, r24	; 0x04
 3d4:	95 83       	std	Z+5, r25	; 0x05
 3d6:	80 e7       	ldi	r24, 0x70	; 112
 3d8:	97 e1       	ldi	r25, 0x17	; 23
 3da:	80 87       	std	Z+8, r24	; 0x08
 3dc:	91 87       	std	Z+9, r25	; 0x09
	blink_set(LED_GREEN_bm, 4000);
	blink_set(LED_YELLOW_bm, 6000);
	
    while (1) 
    {
		blink_ms_timer_update();
 3de:	0e 94 79 01 	call	0x2f2	; 0x2f2 <blink_ms_timer_update>
    }
 3e2:	fd cf       	rjmp	.-6      	; 0x3de <main+0x30>

000003e4 <_exit>:
 3e4:	f8 94       	cli

000003e6 <__stop_program>:
 3e6:	ff cf       	rjmp	.-2      	; 0x3e6 <__stop_program>
