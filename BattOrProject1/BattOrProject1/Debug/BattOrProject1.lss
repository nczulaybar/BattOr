
BattOrProject1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000014a0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000a2  00802000  000014a0  00001534  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000026  008020a2  008020a2  000015d6  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000015d6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001634  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000200  00000000  00000000  00001674  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004105  00000000  00000000  00001874  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001038  00000000  00000000  00005979  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000fbd  00000000  00000000  000069b1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000444  00000000  00000000  00007970  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000b29  00000000  00000000  00007db4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000b00  00000000  00000000  000088dd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000140  00000000  00000000  000093dd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 02 01 	jmp	0x204	; 0x204 <__ctors_end>
       4:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
       8:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
       c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      10:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      14:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      18:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      1c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      20:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      24:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      28:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      2c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      30:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      34:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      38:	0c 94 57 01 	jmp	0x2ae	; 0x2ae <__vector_14>
      3c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      40:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      44:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      48:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      4c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      50:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      54:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      58:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      5c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      60:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      64:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      68:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      6c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      70:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      74:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      78:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      7c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      80:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      84:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      88:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      8c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      90:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      94:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      98:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      9c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      a0:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      a4:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      a8:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      ac:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      b0:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      b4:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      b8:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      bc:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      c0:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      c4:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      c8:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      cc:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      d0:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      d4:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      d8:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      dc:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      e0:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      e4:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      e8:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      ec:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      f0:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      f4:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      f8:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
      fc:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     100:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     104:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     108:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     10c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     110:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     114:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     118:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     11c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     120:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     124:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     128:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     12c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     130:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     134:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     138:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     13c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     140:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     144:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     148:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     14c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     150:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     154:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     158:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     15c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     160:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     164:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     168:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     16c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     170:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     174:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     178:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     17c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     180:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     184:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     188:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     18c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     190:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     194:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     198:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     19c:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1a0:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1a4:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1a8:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1ac:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1b0:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1b4:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1b8:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1bc:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1c0:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1c4:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1c8:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1cc:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1d0:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1d4:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1d8:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1dc:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1e0:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1e4:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1e8:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1ec:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1f0:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1f4:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>
     1f8:	0c 94 23 01 	jmp	0x246	; 0x246 <__bad_interrupt>

000001fc <__trampolines_start>:
     1fc:	0c 94 21 05 	jmp	0xa42	; 0xa42 <uart_getchar>
     200:	0c 94 03 05 	jmp	0xa06	; 0xa06 <uart_putchar>

00000204 <__ctors_end>:
     204:	11 24       	eor	r1, r1
     206:	1f be       	out	0x3f, r1	; 63
     208:	cf ef       	ldi	r28, 0xFF	; 255
     20a:	cd bf       	out	0x3d, r28	; 61
     20c:	df e5       	ldi	r29, 0x5F	; 95
     20e:	de bf       	out	0x3e, r29	; 62
     210:	00 e0       	ldi	r16, 0x00	; 0
     212:	0c bf       	out	0x3c, r16	; 60

00000214 <__do_copy_data>:
     214:	10 e2       	ldi	r17, 0x20	; 32
     216:	a0 e0       	ldi	r26, 0x00	; 0
     218:	b0 e2       	ldi	r27, 0x20	; 32
     21a:	e0 ea       	ldi	r30, 0xA0	; 160
     21c:	f4 e1       	ldi	r31, 0x14	; 20
     21e:	00 e0       	ldi	r16, 0x00	; 0
     220:	0b bf       	out	0x3b, r16	; 59
     222:	02 c0       	rjmp	.+4      	; 0x228 <__do_copy_data+0x14>
     224:	07 90       	elpm	r0, Z+
     226:	0d 92       	st	X+, r0
     228:	a2 3a       	cpi	r26, 0xA2	; 162
     22a:	b1 07       	cpc	r27, r17
     22c:	d9 f7       	brne	.-10     	; 0x224 <__do_copy_data+0x10>

0000022e <__do_clear_bss>:
     22e:	20 e2       	ldi	r18, 0x20	; 32
     230:	a2 ea       	ldi	r26, 0xA2	; 162
     232:	b0 e2       	ldi	r27, 0x20	; 32
     234:	01 c0       	rjmp	.+2      	; 0x238 <.do_clear_bss_start>

00000236 <.do_clear_bss_loop>:
     236:	1d 92       	st	X+, r1

00000238 <.do_clear_bss_start>:
     238:	a8 3c       	cpi	r26, 0xC8	; 200
     23a:	b2 07       	cpc	r27, r18
     23c:	e1 f7       	brne	.-8      	; 0x236 <.do_clear_bss_loop>
     23e:	0e 94 8d 03 	call	0x71a	; 0x71a <main>
     242:	0c 94 4e 0a 	jmp	0x149c	; 0x149c <_exit>

00000246 <__bad_interrupt>:
     246:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000024a <adc_init>:
#include <avr/io.h>
#include "led.h"

void adc_init(){
	//Set to 12 bit resolution
	ADCB.CTRLB &= 0b000;
     24a:	e0 e4       	ldi	r30, 0x40	; 64
     24c:	f2 e0       	ldi	r31, 0x02	; 2
     24e:	81 81       	ldd	r24, Z+1	; 0x01
     250:	11 82       	std	Z+1, r1	; 0x01
	
	//Select the external reference voltage connected to PORTA. 
	ADCB.REFCTRL |= 0b0100000;
     252:	82 81       	ldd	r24, Z+2	; 0x02
     254:	80 62       	ori	r24, 0x20	; 32
     256:	82 83       	std	Z+2, r24	; 0x02
	
	//Divide down the ADC’s clock rate so it is below the 2 MHz maximum clock rate of the ADC.
	ADCB.PRESCALER = 0b1; //Division by 8 to go from 16MHz to 2MHz
     258:	81 e0       	ldi	r24, 0x01	; 1
     25a:	84 83       	std	Z+4, r24	; 0x04
	
	//Set to signed mode, enabling differential input
	ADCB.CTRLB |= 0b10000;
     25c:	81 81       	ldd	r24, Z+1	; 0x01
     25e:	80 61       	ori	r24, 0x10	; 16
     260:	81 83       	std	Z+1, r24	; 0x01

	//Configure voltage and current ADC channel.
	ADCB_CH0_CTRL = 0b10; //Sets to differential, no gain
     262:	92 e0       	ldi	r25, 0x02	; 2
     264:	90 93 60 02 	sts	0x0260, r25
	ADCB_CH0_MUXCTRL |= 0b1000; //Pin 1 is current
     268:	a1 e6       	ldi	r26, 0x61	; 97
     26a:	b2 e0       	ldi	r27, 0x02	; 2
     26c:	8c 91       	ld	r24, X
     26e:	88 60       	ori	r24, 0x08	; 8
     270:	8c 93       	st	X, r24
	ADCB_CH0_MUXCTRL |= 0b101; // Pad ground
     272:	8c 91       	ld	r24, X
     274:	85 60       	ori	r24, 0x05	; 5
     276:	8c 93       	st	X, r24
	
	ADCB_CH1_CTRL = 0b10; //Sets to differential, no gain
     278:	90 93 68 02 	sts	0x0268, r25
	ADCB_CH1_MUXCTRL |= 0b10000; //Pin 2 is voltage
     27c:	a9 e6       	ldi	r26, 0x69	; 105
     27e:	b2 e0       	ldi	r27, 0x02	; 2
     280:	8c 91       	ld	r24, X
     282:	80 61       	ori	r24, 0x10	; 16
     284:	8c 93       	st	X, r24
	ADCB_CH1_MUXCTRL |= 0b101; //Pad ground
     286:	8c 91       	ld	r24, X
     288:	85 60       	ori	r24, 0x05	; 5
     28a:	8c 93       	st	X, r24
	
	ADCB.CTRLA |= 0b1; //Enable ADC
     28c:	80 81       	ld	r24, Z
     28e:	81 60       	ori	r24, 0x01	; 1
     290:	80 83       	st	Z, r24
     292:	08 95       	ret

00000294 <blink_init>:
volatile uint8_t timerFlag;


//Initialize the state of all of the LEDs in local state of the blink library to have their blinks disabled. Also, setup a timer that will fire an interrupt once every millisecond. Note that the timer is clocked off of the peripheral clock, and the peripheral clock is clocked off of the system clock.
void blink_init(){
	timer_init(&TCC0, 0b11); //high interrupt level
     294:	63 e0       	ldi	r22, 0x03	; 3
     296:	80 e0       	ldi	r24, 0x00	; 0
     298:	98 e0       	ldi	r25, 0x08	; 8
     29a:	0e 94 3a 05 	call	0xa74	; 0xa74 <timer_init>
	timer_set(&TCC0, 0b1, 16000); //16000 ticks corresponds to 1ms, with the new clock
     29e:	40 e8       	ldi	r20, 0x80	; 128
     2a0:	5e e3       	ldi	r21, 0x3E	; 62
     2a2:	61 e0       	ldi	r22, 0x01	; 1
     2a4:	80 e0       	ldi	r24, 0x00	; 0
     2a6:	98 e0       	ldi	r25, 0x08	; 8
     2a8:	0e 94 41 05 	call	0xa82	; 0xa82 <timer_set>
     2ac:	08 95       	ret

000002ae <__vector_14>:
}

ISR(TCC0_OVF_vect){//Upper Half
     2ae:	1f 92       	push	r1
     2b0:	0f 92       	push	r0
     2b2:	0f b6       	in	r0, 0x3f	; 63
     2b4:	0f 92       	push	r0
     2b6:	11 24       	eor	r1, r1
     2b8:	0b b6       	in	r0, 0x3b	; 59
     2ba:	0f 92       	push	r0
     2bc:	2f 93       	push	r18
     2be:	3f 93       	push	r19
     2c0:	4f 93       	push	r20
     2c2:	5f 93       	push	r21
     2c4:	6f 93       	push	r22
     2c6:	7f 93       	push	r23
     2c8:	8f 93       	push	r24
     2ca:	9f 93       	push	r25
     2cc:	af 93       	push	r26
     2ce:	bf 93       	push	r27
     2d0:	ef 93       	push	r30
     2d2:	ff 93       	push	r31
	globalTime++;
     2d4:	80 91 b2 20 	lds	r24, 0x20B2
     2d8:	90 91 b3 20 	lds	r25, 0x20B3
     2dc:	a0 91 b4 20 	lds	r26, 0x20B4
     2e0:	b0 91 b5 20 	lds	r27, 0x20B5
     2e4:	01 96       	adiw	r24, 0x01	; 1
     2e6:	a1 1d       	adc	r26, r1
     2e8:	b1 1d       	adc	r27, r1
     2ea:	80 93 b2 20 	sts	0x20B2, r24
     2ee:	90 93 b3 20 	sts	0x20B3, r25
     2f2:	a0 93 b4 20 	sts	0x20B4, r26
     2f6:	b0 93 b5 20 	sts	0x20B5, r27
	checkBlink++;
     2fa:	80 91 af 20 	lds	r24, 0x20AF
     2fe:	8f 5f       	subi	r24, 0xFF	; 255
     300:	80 93 af 20 	sts	0x20AF, r24
	timerFlag = 0b1; //Enables light updating and sampling
     304:	81 e0       	ldi	r24, 0x01	; 1
     306:	80 93 b6 20 	sts	0x20B6, r24

volatile uint16_t current;
volatile uint16_t voltage;

inline void adc_start_sample(){
	ADCB.CTRLA |= 0b1100;
     30a:	e0 e4       	ldi	r30, 0x40	; 64
     30c:	f2 e0       	ldi	r31, 0x02	; 2
     30e:	80 81       	ld	r24, Z
     310:	8c 60       	ori	r24, 0x0C	; 12
     312:	80 83       	st	Z, r24
	adc_start_sample();
	//check to see if the lower half did not have time to complete printing the last sample. 
	while(finishedPrinting == 0){
     314:	80 91 ae 20 	lds	r24, 0x20AE
     318:	81 11       	cpse	r24, r1
     31a:	07 c0       	rjmp	.+14     	; 0x32a <__vector_14+0x7c>
		led_on(LED_RED_bm);
     31c:	84 e0       	ldi	r24, 0x04	; 4
     31e:	0e 94 84 03 	call	0x708	; 0x708 <led_on>
	globalTime++;
	checkBlink++;
	timerFlag = 0b1; //Enables light updating and sampling
	adc_start_sample();
	//check to see if the lower half did not have time to complete printing the last sample. 
	while(finishedPrinting == 0){
     322:	80 91 ae 20 	lds	r24, 0x20AE
     326:	88 23       	and	r24, r24
     328:	c9 f3       	breq	.-14     	; 0x31c <__vector_14+0x6e>
		led_on(LED_RED_bm);
	}
	
	finishedPrinting = 0b0;
     32a:	10 92 ae 20 	sts	0x20AE, r1

}
     32e:	ff 91       	pop	r31
     330:	ef 91       	pop	r30
     332:	bf 91       	pop	r27
     334:	af 91       	pop	r26
     336:	9f 91       	pop	r25
     338:	8f 91       	pop	r24
     33a:	7f 91       	pop	r23
     33c:	6f 91       	pop	r22
     33e:	5f 91       	pop	r21
     340:	4f 91       	pop	r20
     342:	3f 91       	pop	r19
     344:	2f 91       	pop	r18
     346:	0f 90       	pop	r0
     348:	0b be       	out	0x3b, r0	; 59
     34a:	0f 90       	pop	r0
     34c:	0f be       	out	0x3f, r0	; 63
     34e:	0f 90       	pop	r0
     350:	1f 90       	pop	r1
     352:	18 95       	reti

00000354 <blink_set>:

//Set the specified led to blink at the specified interval_ms.
void blink_set(uint8_t led, uint16_t interval_ms) {
     354:	e2 ea       	ldi	r30, 0xA2	; 162
     356:	f0 e2       	ldi	r31, 0x20	; 32
     358:	4e ea       	ldi	r20, 0xAE	; 174
     35a:	50 e2       	ldi	r21, 0x20	; 32
	uint8_t i = 0;
	for (uint8_t pos = 0b1; pos < 0b1000; pos = pos << 1) {
     35c:	91 e0       	ldi	r25, 0x01	; 1
		if(pos & led) LEDArray[i].blinkInterval = interval_ms;
     35e:	29 2f       	mov	r18, r25
     360:	28 23       	and	r18, r24
     362:	11 f0       	breq	.+4      	; 0x368 <blink_set+0x14>
     364:	60 83       	st	Z, r22
     366:	71 83       	std	Z+1, r23	; 0x01
}

//Set the specified led to blink at the specified interval_ms.
void blink_set(uint8_t led, uint16_t interval_ms) {
	uint8_t i = 0;
	for (uint8_t pos = 0b1; pos < 0b1000; pos = pos << 1) {
     368:	99 0f       	add	r25, r25
     36a:	34 96       	adiw	r30, 0x04	; 4
     36c:	e4 17       	cp	r30, r20
     36e:	f5 07       	cpc	r31, r21
     370:	b1 f7       	brne	.-20     	; 0x35e <blink_set+0xa>
		if(pos & led) LEDArray[i].blinkInterval = interval_ms;
		i++;
	}
}
     372:	08 95       	ret

00000374 <blink_ms_timer_update>:

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
     374:	8f 92       	push	r8
     376:	9f 92       	push	r9
     378:	af 92       	push	r10
     37a:	bf 92       	push	r11
     37c:	ef 92       	push	r14
     37e:	ff 92       	push	r15
     380:	0f 93       	push	r16
     382:	1f 93       	push	r17
     384:	cf 93       	push	r28
     386:	df 93       	push	r29
     388:	02 ea       	ldi	r16, 0xA2	; 162
     38a:	10 e2       	ldi	r17, 0x20	; 32
     38c:	c0 e0       	ldi	r28, 0x00	; 0
     38e:	d0 e0       	ldi	r29, 0x00	; 0
			if (lastTime < globalTime) {
				LEDArray[i].counter += (globalTime - lastTime); 
				}
			if (LEDArray[i].counter >= LEDArray[i].blinkInterval) {
				LEDArray[i].counter = LEDArray[i].counter-LEDArray[i].blinkInterval;
				led_toggle(0b1 << (i));
     390:	ff 24       	eor	r15, r15
     392:	f3 94       	inc	r15
}

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
	for (uint8_t i = 0; i < 3; i++) {
		if (LEDArray[i].blinkInterval != 0) {
     394:	ec 2e       	mov	r14, r28
     396:	f8 01       	movw	r30, r16
     398:	80 81       	ld	r24, Z
     39a:	91 81       	ldd	r25, Z+1	; 0x01
     39c:	00 97       	sbiw	r24, 0x00	; 0
     39e:	b9 f1       	breq	.+110    	; 0x40e <blink_ms_timer_update+0x9a>
			if (lastTime < globalTime) {
     3a0:	80 90 b9 20 	lds	r8, 0x20B9
     3a4:	90 90 ba 20 	lds	r9, 0x20BA
     3a8:	a0 90 bb 20 	lds	r10, 0x20BB
     3ac:	b0 90 bc 20 	lds	r11, 0x20BC
     3b0:	40 91 b2 20 	lds	r20, 0x20B2
     3b4:	50 91 b3 20 	lds	r21, 0x20B3
     3b8:	60 91 b4 20 	lds	r22, 0x20B4
     3bc:	70 91 b5 20 	lds	r23, 0x20B5
     3c0:	84 16       	cp	r8, r20
     3c2:	95 06       	cpc	r9, r21
     3c4:	a6 06       	cpc	r10, r22
     3c6:	b7 06       	cpc	r11, r23
     3c8:	90 f4       	brcc	.+36     	; 0x3ee <blink_ms_timer_update+0x7a>
				LEDArray[i].counter += (globalTime - lastTime); 
     3ca:	40 91 b2 20 	lds	r20, 0x20B2
     3ce:	50 91 b3 20 	lds	r21, 0x20B3
     3d2:	60 91 b4 20 	lds	r22, 0x20B4
     3d6:	70 91 b5 20 	lds	r23, 0x20B5
     3da:	48 19       	sub	r20, r8
     3dc:	59 09       	sbc	r21, r9
     3de:	6a 09       	sbc	r22, r10
     3e0:	7b 09       	sbc	r23, r11
     3e2:	22 81       	ldd	r18, Z+2	; 0x02
     3e4:	33 81       	ldd	r19, Z+3	; 0x03
     3e6:	42 0f       	add	r20, r18
     3e8:	53 1f       	adc	r21, r19
     3ea:	42 83       	std	Z+2, r20	; 0x02
     3ec:	53 83       	std	Z+3, r21	; 0x03
				}
			if (LEDArray[i].counter >= LEDArray[i].blinkInterval) {
     3ee:	22 81       	ldd	r18, Z+2	; 0x02
     3f0:	33 81       	ldd	r19, Z+3	; 0x03
     3f2:	28 17       	cp	r18, r24
     3f4:	39 07       	cpc	r19, r25
     3f6:	58 f0       	brcs	.+22     	; 0x40e <blink_ms_timer_update+0x9a>
				LEDArray[i].counter = LEDArray[i].counter-LEDArray[i].blinkInterval;
     3f8:	28 1b       	sub	r18, r24
     3fa:	39 0b       	sbc	r19, r25
     3fc:	22 83       	std	Z+2, r18	; 0x02
     3fe:	33 83       	std	Z+3, r19	; 0x03
				led_toggle(0b1 << (i));
     400:	8f 2d       	mov	r24, r15
     402:	01 c0       	rjmp	.+2      	; 0x406 <blink_ms_timer_update+0x92>
     404:	88 0f       	add	r24, r24
     406:	ea 94       	dec	r14
     408:	ea f7       	brpl	.-6      	; 0x404 <blink_ms_timer_update+0x90>
     40a:	0e 94 8a 03 	call	0x714	; 0x714 <led_toggle>
     40e:	21 96       	adiw	r28, 0x01	; 1
     410:	0c 5f       	subi	r16, 0xFC	; 252
     412:	1f 4f       	sbci	r17, 0xFF	; 255
	}
}

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
	for (uint8_t i = 0; i < 3; i++) {
     414:	c3 30       	cpi	r28, 0x03	; 3
     416:	d1 05       	cpc	r29, r1
     418:	09 f0       	breq	.+2      	; 0x41c <blink_ms_timer_update+0xa8>
     41a:	bc cf       	rjmp	.-136    	; 0x394 <blink_ms_timer_update+0x20>
				LEDArray[i].counter = LEDArray[i].counter-LEDArray[i].blinkInterval;
				led_toggle(0b1 << (i));
			}
		}
	}
	lastTime = globalTime;
     41c:	80 91 b2 20 	lds	r24, 0x20B2
     420:	90 91 b3 20 	lds	r25, 0x20B3
     424:	a0 91 b4 20 	lds	r26, 0x20B4
     428:	b0 91 b5 20 	lds	r27, 0x20B5
     42c:	80 93 b9 20 	sts	0x20B9, r24
     430:	90 93 ba 20 	sts	0x20BA, r25
     434:	a0 93 bb 20 	sts	0x20BB, r26
     438:	b0 93 bc 20 	sts	0x20BC, r27
     43c:	df 91       	pop	r29
     43e:	cf 91       	pop	r28
     440:	1f 91       	pop	r17
     442:	0f 91       	pop	r16
     444:	ff 90       	pop	r15
     446:	ef 90       	pop	r14
     448:	bf 90       	pop	r11
     44a:	af 90       	pop	r10
     44c:	9f 90       	pop	r9
     44e:	8f 90       	pop	r8
     450:	08 95       	ret

00000452 <clock_switch_to_ext_crystal>:
#include "timer.h"
#include "blink.h"

void clock_switch_to_ext_crystal(){
	
	OSC.XOSCCTRL = 0b11001011;
     452:	e0 e5       	ldi	r30, 0x50	; 80
     454:	f0 e0       	ldi	r31, 0x00	; 0
     456:	8b ec       	ldi	r24, 0xCB	; 203
     458:	82 83       	std	Z+2, r24	; 0x02
	OSC.CTRL = OSC.CTRL | 0b1000;
     45a:	80 81       	ld	r24, Z
     45c:	88 60       	ori	r24, 0x08	; 8
     45e:	80 83       	st	Z, r24
	while(!(OSC.STATUS & 0b1000)){
     460:	81 81       	ldd	r24, Z+1	; 0x01
     462:	83 ff       	sbrs	r24, 3
     464:	fd cf       	rjmp	.-6      	; 0x460 <clock_switch_to_ext_crystal+0xe>
	}
	CPU_CCP = CCP_IOREG_gc;
     466:	88 ed       	ldi	r24, 0xD8	; 216
     468:	84 bf       	out	0x34, r24	; 52
	CLK.CTRL = 0b11; //Changes multiplexer to set source to external oscillator
     46a:	83 e0       	ldi	r24, 0x03	; 3
     46c:	80 93 40 00 	sts	0x0040, r24
     470:	08 95       	ret

00000472 <pot_high_impedance_sdo>:
	gpio_set_out(&PORTC, DIGIPOT_FIL_CS_PIN_gm, 1);
	pot_high_impedance_sdo(DIGIPOT_FIL_CS_PIN_gm);
	
}

static void pot_high_impedance_sdo(uint8_t pot_cs_pin){
     472:	ff 92       	push	r15
     474:	0f 93       	push	r16
     476:	1f 93       	push	r17
     478:	cf 93       	push	r28
     47a:	df 93       	push	r29
     47c:	00 d0       	rcall	.+0      	; 0x47e <pot_high_impedance_sdo+0xc>
     47e:	1f 92       	push	r1
     480:	cd b7       	in	r28, 0x3d	; 61
     482:	de b7       	in	r29, 0x3e	; 62
     484:	f8 2e       	mov	r15, r24
//Set the specified pin on the specified port to be in output (1) or input (0) mode.

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
	if(on_or_off) port->OUTSET = pin;
	else port->OUTCLR = pin;
     486:	00 e4       	ldi	r16, 0x40	; 64
     488:	16 e0       	ldi	r17, 0x06	; 6
     48a:	f8 01       	movw	r30, r16
     48c:	86 83       	std	Z+6, r24	; 0x06
	gpio_set_out(&PORTC, pot_cs_pin, 0); //Pull down CS
	
	uint16_t dataword = 0b1000000000000001;
     48e:	81 e0       	ldi	r24, 0x01	; 1
     490:	90 e8       	ldi	r25, 0x80	; 128
     492:	89 83       	std	Y+1, r24	; 0x01
     494:	9a 83       	std	Y+2, r25	; 0x02
	spi_txrx(&SPIC, &dataword, NULL, 2);
     496:	22 e0       	ldi	r18, 0x02	; 2
     498:	30 e0       	ldi	r19, 0x00	; 0
     49a:	40 e0       	ldi	r20, 0x00	; 0
     49c:	50 e0       	ldi	r21, 0x00	; 0
     49e:	be 01       	movw	r22, r28
     4a0:	6f 5f       	subi	r22, 0xFF	; 255
     4a2:	7f 4f       	sbci	r23, 0xFF	; 255
     4a4:	80 ec       	ldi	r24, 0xC0	; 192
     4a6:	98 e0       	ldi	r25, 0x08	; 8
     4a8:	0e 94 c2 04 	call	0x984	; 0x984 <spi_txrx>
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in);
//Set the specified pin on the specified port to be in output (1) or input (0) mode.

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
	if(on_or_off) port->OUTSET = pin;
     4ac:	f8 01       	movw	r30, r16
     4ae:	f5 82       	std	Z+5, r15	; 0x05
	else port->OUTCLR = pin;
     4b0:	f6 82       	std	Z+6, r15	; 0x06
	
	gpio_set_out(&PORTC, pot_cs_pin, 1); //Pull up CS
	gpio_set_out(&PORTC, pot_cs_pin, 0); //Pull down CS
	
	uint16_t dataword2 = 0b0000000000000000;
     4b2:	1b 82       	std	Y+3, r1	; 0x03
     4b4:	1c 82       	std	Y+4, r1	; 0x04
	spi_txrx(&SPIC, &dataword2, NULL, 2);
     4b6:	22 e0       	ldi	r18, 0x02	; 2
     4b8:	30 e0       	ldi	r19, 0x00	; 0
     4ba:	40 e0       	ldi	r20, 0x00	; 0
     4bc:	50 e0       	ldi	r21, 0x00	; 0
     4be:	be 01       	movw	r22, r28
     4c0:	6d 5f       	subi	r22, 0xFD	; 253
     4c2:	7f 4f       	sbci	r23, 0xFF	; 255
     4c4:	80 ec       	ldi	r24, 0xC0	; 192
     4c6:	98 e0       	ldi	r25, 0x08	; 8
     4c8:	0e 94 c2 04 	call	0x984	; 0x984 <spi_txrx>
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in);
//Set the specified pin on the specified port to be in output (1) or input (0) mode.

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
	if(on_or_off) port->OUTSET = pin;
     4cc:	f8 01       	movw	r30, r16
     4ce:	f5 82       	std	Z+5, r15	; 0x05
	
	gpio_set_out(&PORTC, pot_cs_pin, 1); //Pull up CS
}
     4d0:	24 96       	adiw	r28, 0x04	; 4
     4d2:	cd bf       	out	0x3d, r28	; 61
     4d4:	de bf       	out	0x3e, r29	; 62
     4d6:	df 91       	pop	r29
     4d8:	cf 91       	pop	r28
     4da:	1f 91       	pop	r17
     4dc:	0f 91       	pop	r16
     4de:	ff 90       	pop	r15
     4e0:	08 95       	ret

000004e2 <digipot_init>:
#include <stdio.h>
#include "led.h"

static void pot_high_impedance_sdo(uint8_t pot_cs_pin);

void digipot_init(){
     4e2:	cf 92       	push	r12
     4e4:	df 92       	push	r13
     4e6:	ef 92       	push	r14
     4e8:	ff 92       	push	r15
     4ea:	0f 93       	push	r16
     4ec:	1f 93       	push	r17
     4ee:	cf 93       	push	r28
     4f0:	df 93       	push	r29
     4f2:	1f 92       	push	r1
     4f4:	1f 92       	push	r1
     4f6:	cd b7       	in	r28, 0x3d	; 61
     4f8:	de b7       	in	r29, 0x3e	; 62
	
	//Set chip select pins to output mode
	gpio_set_mode(&PORTC, DIGIPOT_AMP_CS_PIN_gm, 1);
     4fa:	41 e0       	ldi	r20, 0x01	; 1
     4fc:	68 e0       	ldi	r22, 0x08	; 8
     4fe:	80 e4       	ldi	r24, 0x40	; 64
     500:	96 e0       	ldi	r25, 0x06	; 6
     502:	0e 94 61 03 	call	0x6c2	; 0x6c2 <gpio_set_mode>
	gpio_set_mode(&PORTC,DIGIPOT_FIL_CS_PIN_gm, 1);
     506:	41 e0       	ldi	r20, 0x01	; 1
     508:	60 e1       	ldi	r22, 0x10	; 16
     50a:	80 e4       	ldi	r24, 0x40	; 64
     50c:	96 e0       	ldi	r25, 0x06	; 6
     50e:	0e 94 61 03 	call	0x6c2	; 0x6c2 <gpio_set_mode>
	
	//Set mode to SSbar
	gpio_set_mode(&PORTC, 0b10100000, 1); // set mosi out
     512:	41 e0       	ldi	r20, 0x01	; 1
     514:	60 ea       	ldi	r22, 0xA0	; 160
     516:	80 e4       	ldi	r24, 0x40	; 64
     518:	96 e0       	ldi	r25, 0x06	; 6
     51a:	0e 94 61 03 	call	0x6c2	; 0x6c2 <gpio_set_mode>
	gpio_set_mode(&PORTC, 0b01000000, 0); // Set miso in
     51e:	40 e0       	ldi	r20, 0x00	; 0
     520:	60 e4       	ldi	r22, 0x40	; 64
     522:	80 e4       	ldi	r24, 0x40	; 64
     524:	96 e0       	ldi	r25, 0x06	; 6
     526:	0e 94 61 03 	call	0x6c2	; 0x6c2 <gpio_set_mode>
     52a:	00 e4       	ldi	r16, 0x40	; 64
     52c:	16 e0       	ldi	r17, 0x06	; 6
     52e:	68 94       	set
     530:	ee 24       	eor	r14, r14
     532:	e3 f8       	bld	r14, 3
     534:	f8 01       	movw	r30, r16
     536:	e5 82       	std	Z+5, r14	; 0x05
     538:	68 94       	set
     53a:	ff 24       	eor	r15, r15
     53c:	f4 f8       	bld	r15, 4
     53e:	f5 82       	std	Z+5, r15	; 0x05
     540:	80 e4       	ldi	r24, 0x40	; 64
     542:	85 83       	std	Z+5, r24	; 0x05
	gpio_set_out(&PORTC, 0b1000000, 1);
	
	 //Enable register
	 //Turn to master mode
	 //Set to transmit least significant first
	SPIC_CTRL = 0b01010111; //Rising, setup and falling sample
     544:	87 e5       	ldi	r24, 0x57	; 87
     546:	80 93 c0 08 	sts	0x08C0, r24
	
	//Set miso to input again
	gpio_set_mode(&PORTC, 0b01000000, 0); 
     54a:	40 e0       	ldi	r20, 0x00	; 0
     54c:	60 e4       	ldi	r22, 0x40	; 64
     54e:	80 e4       	ldi	r24, 0x40	; 64
     550:	96 e0       	ldi	r25, 0x06	; 6
     552:	0e 94 61 03 	call	0x6c2	; 0x6c2 <gpio_set_mode>
	//Enable pullup resistor on MISO
	PORTC.PIN6CTRL |= 0b011000;
     556:	f8 01       	movw	r30, r16
     558:	86 89       	ldd	r24, Z+22	; 0x16
     55a:	88 61       	ori	r24, 0x18	; 24
     55c:	86 8b       	std	Z+22, r24	; 0x16
	
	pot_high_impedance_sdo(DIGIPOT_AMP_CS_PIN_gm);
     55e:	88 e0       	ldi	r24, 0x08	; 8
     560:	0e 94 39 02 	call	0x472	; 0x472 <pot_high_impedance_sdo>
	pot_high_impedance_sdo(DIGIPOT_FIL_CS_PIN_gm);
     564:	80 e1       	ldi	r24, 0x10	; 16
     566:	0e 94 39 02 	call	0x472	; 0x472 <pot_high_impedance_sdo>
	else port->OUTCLR = pin;
     56a:	f8 01       	movw	r30, r16
     56c:	e6 82       	std	Z+6, r14	; 0x06
	
	//Write enable, AMPOT
	gpio_set_out(&PORTC, DIGIPOT_AMP_CS_PIN_gm, 0);
	uint16_t writeEnable =  0b0001110000000010;
     56e:	0f 2e       	mov	r0, r31
     570:	f2 e0       	ldi	r31, 0x02	; 2
     572:	cf 2e       	mov	r12, r31
     574:	fc e1       	ldi	r31, 0x1C	; 28
     576:	df 2e       	mov	r13, r31
     578:	f0 2d       	mov	r31, r0
     57a:	c9 82       	std	Y+1, r12	; 0x01
     57c:	da 82       	std	Y+2, r13	; 0x02
	spi_txrx(&SPIC, &writeEnable, NULL, 2);
     57e:	22 e0       	ldi	r18, 0x02	; 2
     580:	30 e0       	ldi	r19, 0x00	; 0
     582:	40 e0       	ldi	r20, 0x00	; 0
     584:	50 e0       	ldi	r21, 0x00	; 0
     586:	be 01       	movw	r22, r28
     588:	6f 5f       	subi	r22, 0xFF	; 255
     58a:	7f 4f       	sbci	r23, 0xFF	; 255
     58c:	80 ec       	ldi	r24, 0xC0	; 192
     58e:	98 e0       	ldi	r25, 0x08	; 8
     590:	0e 94 c2 04 	call	0x984	; 0x984 <spi_txrx>
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in);
//Set the specified pin on the specified port to be in output (1) or input (0) mode.

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
	if(on_or_off) port->OUTSET = pin;
     594:	f8 01       	movw	r30, r16
     596:	e5 82       	std	Z+5, r14	; 0x05
	gpio_set_out(&PORTC, DIGIPOT_AMP_CS_PIN_gm, 1);
	pot_high_impedance_sdo(DIGIPOT_AMP_CS_PIN_gm);
     598:	88 e0       	ldi	r24, 0x08	; 8
     59a:	0e 94 39 02 	call	0x472	; 0x472 <pot_high_impedance_sdo>
	else port->OUTCLR = pin;
     59e:	f8 01       	movw	r30, r16
     5a0:	f6 82       	std	Z+6, r15	; 0x06
	
	//Write enable, FILPOT
	gpio_set_out(&PORTC, DIGIPOT_FIL_CS_PIN_gm, 0);
	writeEnable =  0b0001110000000010;
     5a2:	c9 82       	std	Y+1, r12	; 0x01
     5a4:	da 82       	std	Y+2, r13	; 0x02
	spi_txrx(&SPIC, &writeEnable, NULL, 2);
     5a6:	22 e0       	ldi	r18, 0x02	; 2
     5a8:	30 e0       	ldi	r19, 0x00	; 0
     5aa:	40 e0       	ldi	r20, 0x00	; 0
     5ac:	50 e0       	ldi	r21, 0x00	; 0
     5ae:	be 01       	movw	r22, r28
     5b0:	6f 5f       	subi	r22, 0xFF	; 255
     5b2:	7f 4f       	sbci	r23, 0xFF	; 255
     5b4:	80 ec       	ldi	r24, 0xC0	; 192
     5b6:	98 e0       	ldi	r25, 0x08	; 8
     5b8:	0e 94 c2 04 	call	0x984	; 0x984 <spi_txrx>
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in);
//Set the specified pin on the specified port to be in output (1) or input (0) mode.

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
	if(on_or_off) port->OUTSET = pin;
     5bc:	f8 01       	movw	r30, r16
     5be:	f5 82       	std	Z+5, r15	; 0x05
	gpio_set_out(&PORTC, DIGIPOT_FIL_CS_PIN_gm, 1);
	pot_high_impedance_sdo(DIGIPOT_FIL_CS_PIN_gm);
     5c0:	80 e1       	ldi	r24, 0x10	; 16
     5c2:	0e 94 39 02 	call	0x472	; 0x472 <pot_high_impedance_sdo>
	
}
     5c6:	0f 90       	pop	r0
     5c8:	0f 90       	pop	r0
     5ca:	df 91       	pop	r29
     5cc:	cf 91       	pop	r28
     5ce:	1f 91       	pop	r17
     5d0:	0f 91       	pop	r16
     5d2:	ff 90       	pop	r15
     5d4:	ef 90       	pop	r14
     5d6:	df 90       	pop	r13
     5d8:	cf 90       	pop	r12
     5da:	08 95       	ret

000005dc <pot_wiperpos_get>:
	
	gpio_set_out(&PORTC, pot_cs_pin, 1); //Pull up CS
}

//Read the wiper position (0 - 1023) of the potentiometer which has its CS pin connected to pot_cs_pin.
uint16_t pot_wiperpos_get(uint8_t pot_cs_pin){
     5dc:	ef 92       	push	r14
     5de:	ff 92       	push	r15
     5e0:	1f 93       	push	r17
     5e2:	cf 93       	push	r28
     5e4:	df 93       	push	r29
     5e6:	00 d0       	rcall	.+0      	; 0x5e8 <pot_wiperpos_get+0xc>
     5e8:	00 d0       	rcall	.+0      	; 0x5ea <pot_wiperpos_get+0xe>
     5ea:	cd b7       	in	r28, 0x3d	; 61
     5ec:	de b7       	in	r29, 0x3e	; 62
     5ee:	18 2f       	mov	r17, r24
	else port->OUTCLR = pin;
     5f0:	0f 2e       	mov	r0, r31
     5f2:	f0 e4       	ldi	r31, 0x40	; 64
     5f4:	ef 2e       	mov	r14, r31
     5f6:	f6 e0       	ldi	r31, 0x06	; 6
     5f8:	ff 2e       	mov	r15, r31
     5fa:	f0 2d       	mov	r31, r0
     5fc:	f7 01       	movw	r30, r14
     5fe:	86 83       	std	Z+6, r24	; 0x06
	gpio_set_out(&PORTC, pot_cs_pin, 0); //Pull down CS
	uint16_t returnable = -1;
     600:	8f ef       	ldi	r24, 0xFF	; 255
     602:	9f ef       	ldi	r25, 0xFF	; 255
     604:	89 83       	std	Y+1, r24	; 0x01
     606:	9a 83       	std	Y+2, r25	; 0x02
	uint16_t command = 0b00100000000000;
     608:	80 e0       	ldi	r24, 0x00	; 0
     60a:	98 e0       	ldi	r25, 0x08	; 8
     60c:	8b 83       	std	Y+3, r24	; 0x03
     60e:	9c 83       	std	Y+4, r25	; 0x04
	//uint16_t command = 0x2000;
	spi_txrx(&SPIC, &command, NULL, 2);
     610:	22 e0       	ldi	r18, 0x02	; 2
     612:	30 e0       	ldi	r19, 0x00	; 0
     614:	40 e0       	ldi	r20, 0x00	; 0
     616:	50 e0       	ldi	r21, 0x00	; 0
     618:	be 01       	movw	r22, r28
     61a:	6d 5f       	subi	r22, 0xFD	; 253
     61c:	7f 4f       	sbci	r23, 0xFF	; 255
     61e:	80 ec       	ldi	r24, 0xC0	; 192
     620:	98 e0       	ldi	r25, 0x08	; 8
     622:	0e 94 c2 04 	call	0x984	; 0x984 <spi_txrx>
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in);
//Set the specified pin on the specified port to be in output (1) or input (0) mode.

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
	if(on_or_off) port->OUTSET = pin;
     626:	f7 01       	movw	r30, r14
     628:	15 83       	std	Z+5, r17	; 0x05
	gpio_set_out(&PORTC, pot_cs_pin, 1); //Pull up CS
	uint16_t zeroes = 0b0000000000000000;
     62a:	1d 82       	std	Y+5, r1	; 0x05
     62c:	1e 82       	std	Y+6, r1	; 0x06
	else port->OUTCLR = pin;
     62e:	16 83       	std	Z+6, r17	; 0x06
	gpio_set_out(&PORTC, pot_cs_pin, 0); //Pull down CS
	spi_txrx(&SPIC, &zeroes, &returnable, 2);
     630:	22 e0       	ldi	r18, 0x02	; 2
     632:	30 e0       	ldi	r19, 0x00	; 0
     634:	ae 01       	movw	r20, r28
     636:	4f 5f       	subi	r20, 0xFF	; 255
     638:	5f 4f       	sbci	r21, 0xFF	; 255
     63a:	be 01       	movw	r22, r28
     63c:	6b 5f       	subi	r22, 0xFB	; 251
     63e:	7f 4f       	sbci	r23, 0xFF	; 255
     640:	80 ec       	ldi	r24, 0xC0	; 192
     642:	98 e0       	ldi	r25, 0x08	; 8
     644:	0e 94 c2 04 	call	0x984	; 0x984 <spi_txrx>
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in);
//Set the specified pin on the specified port to be in output (1) or input (0) mode.

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
	if(on_or_off) port->OUTSET = pin;
     648:	f7 01       	movw	r30, r14
     64a:	15 83       	std	Z+5, r17	; 0x05
	gpio_set_out(&PORTC, pot_cs_pin, 1); //Pull up CS
	
	pot_high_impedance_sdo(pot_cs_pin); 
     64c:	81 2f       	mov	r24, r17
     64e:	0e 94 39 02 	call	0x472	; 0x472 <pot_high_impedance_sdo>
	
	return returnable;
}
     652:	89 81       	ldd	r24, Y+1	; 0x01
     654:	9a 81       	ldd	r25, Y+2	; 0x02
     656:	26 96       	adiw	r28, 0x06	; 6
     658:	cd bf       	out	0x3d, r28	; 61
     65a:	de bf       	out	0x3e, r29	; 62
     65c:	df 91       	pop	r29
     65e:	cf 91       	pop	r28
     660:	1f 91       	pop	r17
     662:	ff 90       	pop	r15
     664:	ef 90       	pop	r14
     666:	08 95       	ret

00000668 <pot_wiperpos_set>:

//Write the wiper position (0 - 1023) of the potentiometer which has its CS pin connected to pot_cs_pin.
void pot_wiperpos_set(uint8_t pot_cs_pin, uint16_t pos){
     668:	ef 92       	push	r14
     66a:	ff 92       	push	r15
     66c:	1f 93       	push	r17
     66e:	cf 93       	push	r28
     670:	df 93       	push	r29
     672:	1f 92       	push	r1
     674:	1f 92       	push	r1
     676:	cd b7       	in	r28, 0x3d	; 61
     678:	de b7       	in	r29, 0x3e	; 62
     67a:	18 2f       	mov	r17, r24
	else port->OUTCLR = pin;
     67c:	0f 2e       	mov	r0, r31
     67e:	f0 e4       	ldi	r31, 0x40	; 64
     680:	ef 2e       	mov	r14, r31
     682:	f6 e0       	ldi	r31, 0x06	; 6
     684:	ff 2e       	mov	r15, r31
     686:	f0 2d       	mov	r31, r0
     688:	f7 01       	movw	r30, r14
     68a:	86 83       	std	Z+6, r24	; 0x06
	gpio_set_out(&PORTC, pot_cs_pin, 0); //Pull down CS

	uint16_t command = 0b00010000000000 | pos;
     68c:	74 60       	ori	r23, 0x04	; 4
     68e:	69 83       	std	Y+1, r22	; 0x01
     690:	7a 83       	std	Y+2, r23	; 0x02
	spi_txrx(&SPIC, &command , NULL, 2);
     692:	22 e0       	ldi	r18, 0x02	; 2
     694:	30 e0       	ldi	r19, 0x00	; 0
     696:	40 e0       	ldi	r20, 0x00	; 0
     698:	50 e0       	ldi	r21, 0x00	; 0
     69a:	be 01       	movw	r22, r28
     69c:	6f 5f       	subi	r22, 0xFF	; 255
     69e:	7f 4f       	sbci	r23, 0xFF	; 255
     6a0:	80 ec       	ldi	r24, 0xC0	; 192
     6a2:	98 e0       	ldi	r25, 0x08	; 8
     6a4:	0e 94 c2 04 	call	0x984	; 0x984 <spi_txrx>
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in);
//Set the specified pin on the specified port to be in output (1) or input (0) mode.

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
	if(on_or_off) port->OUTSET = pin;
     6a8:	f7 01       	movw	r30, r14
     6aa:	15 83       	std	Z+5, r17	; 0x05

	gpio_set_out(&PORTC, pot_cs_pin, 1); //Pull up CS
	
	pot_high_impedance_sdo(pot_cs_pin);
     6ac:	81 2f       	mov	r24, r17
     6ae:	0e 94 39 02 	call	0x472	; 0x472 <pot_high_impedance_sdo>
	
	//printf("hullo");
}
     6b2:	0f 90       	pop	r0
     6b4:	0f 90       	pop	r0
     6b6:	df 91       	pop	r29
     6b8:	cf 91       	pop	r28
     6ba:	1f 91       	pop	r17
     6bc:	ff 90       	pop	r15
     6be:	ef 90       	pop	r14
     6c0:	08 95       	ret

000006c2 <gpio_set_mode>:
#include <stdint.h>
#include <avr/io.h>

//Set the specified pin on the specified port to be in output (1) or input (0) mode.
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in){
  if(out_or_in) port->DIRSET = pin;
     6c2:	44 23       	and	r20, r20
     6c4:	19 f0       	breq	.+6      	; 0x6cc <gpio_set_mode+0xa>
     6c6:	fc 01       	movw	r30, r24
     6c8:	61 83       	std	Z+1, r22	; 0x01
     6ca:	08 95       	ret
  else port->DIRCLR = pin;
     6cc:	fc 01       	movw	r30, r24
     6ce:	62 83       	std	Z+2, r22	; 0x02
     6d0:	08 95       	ret

000006d2 <led_init>:
	}
};

//Setup all of the LEDs so they are in output mode and off.
void led_init(){
	gpio_set_mode(&PORTC, LED_GREEN_bm, 1);
     6d2:	41 e0       	ldi	r20, 0x01	; 1
     6d4:	61 e0       	ldi	r22, 0x01	; 1
     6d6:	80 e4       	ldi	r24, 0x40	; 64
     6d8:	96 e0       	ldi	r25, 0x06	; 6
     6da:	0e 94 61 03 	call	0x6c2	; 0x6c2 <gpio_set_mode>
	gpio_set_mode(&PORTC, LED_YELLOW_bm, 1);
     6de:	41 e0       	ldi	r20, 0x01	; 1
     6e0:	62 e0       	ldi	r22, 0x02	; 2
     6e2:	80 e4       	ldi	r24, 0x40	; 64
     6e4:	96 e0       	ldi	r25, 0x06	; 6
     6e6:	0e 94 61 03 	call	0x6c2	; 0x6c2 <gpio_set_mode>
	gpio_set_mode(&PORTC, LED_RED_bm, 1);
     6ea:	41 e0       	ldi	r20, 0x01	; 1
     6ec:	64 e0       	ldi	r22, 0x04	; 4
     6ee:	80 e4       	ldi	r24, 0x40	; 64
     6f0:	96 e0       	ldi	r25, 0x06	; 6
     6f2:	0e 94 61 03 	call	0x6c2	; 0x6c2 <gpio_set_mode>
     6f6:	e0 e4       	ldi	r30, 0x40	; 64
     6f8:	f6 e0       	ldi	r31, 0x06	; 6
     6fa:	81 e0       	ldi	r24, 0x01	; 1
     6fc:	85 83       	std	Z+5, r24	; 0x05
     6fe:	82 e0       	ldi	r24, 0x02	; 2
     700:	85 83       	std	Z+5, r24	; 0x05
     702:	84 e0       	ldi	r24, 0x04	; 4
     704:	85 83       	std	Z+5, r24	; 0x05
     706:	08 95       	ret

00000708 <led_on>:
	else port->OUTCLR = pin;
     708:	80 93 46 06 	sts	0x0646, r24
     70c:	08 95       	ret

0000070e <led_off>:
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in);
//Set the specified pin on the specified port to be in output (1) or input (0) mode.

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
	if(on_or_off) port->OUTSET = pin;
     70e:	80 93 45 06 	sts	0x0645, r24
     712:	08 95       	ret

00000714 <led_toggle>:
	else port->OUTCLR = pin;
}

//If the specified pin on the specified port is in output mode, toggle the pinâ€™s state (if 1 then 0, if 0 then 1).
inline void gpio_toggle_out(PORT_t* port, uint8_t pin){
	port->OUTTGL=pin;
     714:	80 93 47 06 	sts	0x0647, r24
     718:	08 95       	ret

0000071a <main>:
uint32_t lastTime;
volatile uint8_t finishedPrinting;

int main(void)
{
	finishedPrinting = 0b1;	
     71a:	81 e0       	ldi	r24, 0x01	; 1
     71c:	80 93 ae 20 	sts	0x20AE, r24
	
	
	led_init();
     720:	0e 94 69 03 	call	0x6d2	; 0x6d2 <led_init>
	blink_init();	
     724:	0e 94 4a 01 	call	0x294	; 0x294 <blink_init>
	clock_switch_to_ext_crystal();
     728:	0e 94 29 02 	call	0x452	; 0x452 <clock_switch_to_ext_crystal>
	uart_init();
     72c:	0e 94 47 05 	call	0xa8e	; 0xa8e <uart_init>
	stdinout_init();
     730:	0e 94 2f 05 	call	0xa5e	; 0xa5e <stdinout_init>
	digipot_init();
     734:	0e 94 71 02 	call	0x4e2	; 0x4e2 <digipot_init>
	adc_init();
     738:	0e 94 25 01 	call	0x24a	; 0x24a <adc_init>
	
	setupAmplifier();
     73c:	0e 94 bf 03 	call	0x77e	; 0x77e <setupAmplifier>
	setupAntiAliasingFilter();
     740:	0e 94 3c 04 	call	0x878	; 0x878 <setupAntiAliasingFilter>

	
	sei();
     744:	78 94       	sei
	PMIC.CTRL = PMIC.CTRL | 0b111;
     746:	e0 ea       	ldi	r30, 0xA0	; 160
     748:	f0 e0       	ldi	r31, 0x00	; 0
     74a:	82 81       	ldd	r24, Z+2	; 0x02
     74c:	87 60       	ori	r24, 0x07	; 7
     74e:	82 83       	std	Z+2, r24	; 0x02

	blink_set(LED_YELLOW_bm, 200);
     750:	68 ec       	ldi	r22, 0xC8	; 200
     752:	70 e0       	ldi	r23, 0x00	; 0
     754:	82 e0       	ldi	r24, 0x02	; 2
     756:	0e 94 aa 01 	call	0x354	; 0x354 <blink_set>
	calibrate();
     75a:	0e 94 8c 04 	call	0x918	; 0x918 <calibrate>
	blink_set(LED_YELLOW_bm, 0);
     75e:	60 e0       	ldi	r22, 0x00	; 0
     760:	70 e0       	ldi	r23, 0x00	; 0
     762:	82 e0       	ldi	r24, 0x02	; 2
     764:	0e 94 aa 01 	call	0x354	; 0x354 <blink_set>
	led_off(LED_YELLOW_bm);
     768:	82 e0       	ldi	r24, 0x02	; 2
     76a:	0e 94 87 03 	call	0x70e	; 0x70e <led_off>

	blink_set(LED_GREEN_bm, 200);
     76e:	68 ec       	ldi	r22, 0xC8	; 200
     770:	70 e0       	ldi	r23, 0x00	; 0
     772:	81 e0       	ldi	r24, 0x01	; 1
     774:	0e 94 aa 01 	call	0x354	; 0x354 <blink_set>
	
	while (1) {	
		blinkAndSample();
     778:	0e 94 42 04 	call	0x884	; 0x884 <blinkAndSample>
		//printf("here");
    }
     77c:	fd cf       	rjmp	.-6      	; 0x778 <main+0x5e>

0000077e <setupAmplifier>:
volatile uint8_t checkBlink;
volatile uint8_t finishedPrinting;
volatile uint8_t timerFlag;
uint16_t numSamples;

void setupAmplifier(){
     77e:	8f 92       	push	r8
     780:	9f 92       	push	r9
     782:	af 92       	push	r10
     784:	bf 92       	push	r11
     786:	cf 92       	push	r12
     788:	df 92       	push	r13
     78a:	ef 92       	push	r14
     78c:	ff 92       	push	r15
	printf("Enter your desired amplifier gain:\n");
     78e:	8e e0       	ldi	r24, 0x0E	; 14
     790:	90 e2       	ldi	r25, 0x20	; 32
     792:	0e 94 2c 07 	call	0xe58	; 0xe58 <puts>
	char* responseString;
	gets(responseString);
     796:	e1 2c       	mov	r14, r1
     798:	f1 2c       	mov	r15, r1
     79a:	c7 01       	movw	r24, r14
     79c:	0e 94 ee 06 	call	0xddc	; 0xddc <gets>
	long desiredGain = strtol(responseString, NULL, 10);
     7a0:	4a e0       	ldi	r20, 0x0A	; 10
     7a2:	50 e0       	ldi	r21, 0x00	; 0
     7a4:	60 e0       	ldi	r22, 0x00	; 0
     7a6:	70 e0       	ldi	r23, 0x00	; 0
     7a8:	c7 01       	movw	r24, r14
     7aa:	0e 94 ba 05 	call	0xb74	; 0xb74 <strtol>
	long desiredResistance = 100000/(desiredGain - 1);
     7ae:	9b 01       	movw	r18, r22
     7b0:	ac 01       	movw	r20, r24
     7b2:	21 50       	subi	r18, 0x01	; 1
     7b4:	31 09       	sbc	r19, r1
     7b6:	41 09       	sbc	r20, r1
     7b8:	51 09       	sbc	r21, r1
     7ba:	0f 2e       	mov	r0, r31
     7bc:	f0 ea       	ldi	r31, 0xA0	; 160
     7be:	8f 2e       	mov	r8, r31
     7c0:	f6 e8       	ldi	r31, 0x86	; 134
     7c2:	9f 2e       	mov	r9, r31
     7c4:	aa 24       	eor	r10, r10
     7c6:	a3 94       	inc	r10
     7c8:	b1 2c       	mov	r11, r1
     7ca:	f0 2d       	mov	r31, r0
     7cc:	c5 01       	movw	r24, r10
     7ce:	b4 01       	movw	r22, r8
     7d0:	0e 94 5f 05 	call	0xabe	; 0xabe <__divmodsi4>
     7d4:	69 01       	movw	r12, r18
     7d6:	7a 01       	movw	r14, r20
	printf("\t You requested %ld ohms.\n",desiredResistance);
     7d8:	ff 92       	push	r15
     7da:	ef 92       	push	r14
     7dc:	df 92       	push	r13
     7de:	2f 93       	push	r18
     7e0:	81 e3       	ldi	r24, 0x31	; 49
     7e2:	90 e2       	ldi	r25, 0x20	; 32
     7e4:	9f 93       	push	r25
     7e6:	8f 93       	push	r24
     7e8:	0e 94 18 07 	call	0xe30	; 0xe30 <printf>
	uint16_t toSend = ((desiredResistance*1024)/100000)-1;
     7ec:	c7 01       	movw	r24, r14
     7ee:	b6 01       	movw	r22, r12
     7f0:	05 2e       	mov	r0, r21
     7f2:	5a e0       	ldi	r21, 0x0A	; 10
     7f4:	66 0f       	add	r22, r22
     7f6:	77 1f       	adc	r23, r23
     7f8:	88 1f       	adc	r24, r24
     7fa:	99 1f       	adc	r25, r25
     7fc:	5a 95       	dec	r21
     7fe:	d1 f7       	brne	.-12     	; 0x7f4 <setupAmplifier+0x76>
     800:	50 2d       	mov	r21, r0
     802:	a5 01       	movw	r20, r10
     804:	94 01       	movw	r18, r8
     806:	0e 94 5f 05 	call	0xabe	; 0xabe <__divmodsi4>
     80a:	b9 01       	movw	r22, r18
     80c:	61 50       	subi	r22, 0x01	; 1
     80e:	71 09       	sbc	r23, r1
	pot_wiperpos_set(DIGIPOT_AMP_CS_PIN_gm, toSend);
     810:	88 e0       	ldi	r24, 0x08	; 8
     812:	0e 94 34 03 	call	0x668	; 0x668 <pot_wiperpos_set>
	uint16_t actualValue = pot_wiperpos_get(DIGIPOT_AMP_CS_PIN_gm);
     816:	88 e0       	ldi	r24, 0x08	; 8
     818:	0e 94 ee 02 	call	0x5dc	; 0x5dc <pot_wiperpos_get>
	printf("\t The best I can give is %ld.\n", (((uint32_t)actualValue)*100000/1024)+100);
     81c:	dc 01       	movw	r26, r24
     81e:	20 ea       	ldi	r18, 0xA0	; 160
     820:	36 e8       	ldi	r19, 0x86	; 134
     822:	41 e0       	ldi	r20, 0x01	; 1
     824:	50 e0       	ldi	r21, 0x00	; 0
     826:	0e 94 7e 05 	call	0xafc	; 0xafc <__muluhisi3>
     82a:	dc 01       	movw	r26, r24
     82c:	cb 01       	movw	r24, r22
     82e:	07 2e       	mov	r0, r23
     830:	7a e0       	ldi	r23, 0x0A	; 10
     832:	b6 95       	lsr	r27
     834:	a7 95       	ror	r26
     836:	97 95       	ror	r25
     838:	87 95       	ror	r24
     83a:	7a 95       	dec	r23
     83c:	d1 f7       	brne	.-12     	; 0x832 <setupAmplifier+0xb4>
     83e:	70 2d       	mov	r23, r0
     840:	8c 59       	subi	r24, 0x9C	; 156
     842:	9f 4f       	sbci	r25, 0xFF	; 255
     844:	af 4f       	sbci	r26, 0xFF	; 255
     846:	bf 4f       	sbci	r27, 0xFF	; 255
     848:	bf 93       	push	r27
     84a:	af 93       	push	r26
     84c:	9f 93       	push	r25
     84e:	8f 93       	push	r24
     850:	8c e4       	ldi	r24, 0x4C	; 76
     852:	90 e2       	ldi	r25, 0x20	; 32
     854:	9f 93       	push	r25
     856:	8f 93       	push	r24
     858:	0e 94 18 07 	call	0xe30	; 0xe30 <printf>
     85c:	8d b7       	in	r24, 0x3d	; 61
     85e:	9e b7       	in	r25, 0x3e	; 62
     860:	0c 96       	adiw	r24, 0x0c	; 12
     862:	8d bf       	out	0x3d, r24	; 61
     864:	9e bf       	out	0x3e, r25	; 62
	
}
     866:	ff 90       	pop	r15
     868:	ef 90       	pop	r14
     86a:	df 90       	pop	r13
     86c:	cf 90       	pop	r12
     86e:	bf 90       	pop	r11
     870:	af 90       	pop	r10
     872:	9f 90       	pop	r9
     874:	8f 90       	pop	r8
     876:	08 95       	ret

00000878 <setupAntiAliasingFilter>:
		// This digipot is FILPOT
		//Omegacutoff = 1/RC = 500*2pi; 
		//C = 10nF -> R = 200;
		long desiredResistance = 32000;
		uint16_t toSend = ((desiredResistance*1024)/100000)-1;
		pot_wiperpos_set(DIGIPOT_FIL_CS_PIN_gm, toSend);
     878:	66 e4       	ldi	r22, 0x46	; 70
     87a:	71 e0       	ldi	r23, 0x01	; 1
     87c:	80 e1       	ldi	r24, 0x10	; 16
     87e:	0e 94 34 03 	call	0x668	; 0x668 <pot_wiperpos_set>
     882:	08 95       	ret

00000884 <blinkAndSample>:
	//Return voltage back to where it was before
	ADCB_CH1_MUXCTRL = (ADCB_CH1_MUXCTRL & 0b111) | 0b10000; //Pin 2 is voltage
}

void blinkAndSample(){
	if(timerFlag == 0b1){
     884:	80 91 b6 20 	lds	r24, 0x20B6
     888:	81 30       	cpi	r24, 0x01	; 1
     88a:	51 f4       	brne	.+20     	; 0x8a0 <blinkAndSample+0x1c>
		if(checkBlink >= 5) {
     88c:	80 91 af 20 	lds	r24, 0x20AF
     890:	85 30       	cpi	r24, 0x05	; 5
     892:	20 f0       	brcs	.+8      	; 0x89c <blinkAndSample+0x18>
			blink_ms_timer_update();
     894:	0e 94 ba 01 	call	0x374	; 0x374 <blink_ms_timer_update>
			checkBlink = 0;
     898:	10 92 af 20 	sts	0x20AF, r1
		}
		timerFlag = 0b0;
     89c:	10 92 b6 20 	sts	0x20B6, r1
	}
	
	while(ADCB.INTFLAGS != 0b11); // do nothing while still sampling
     8a0:	e0 e4       	ldi	r30, 0x40	; 64
     8a2:	f2 e0       	ldi	r31, 0x02	; 2
     8a4:	86 81       	ldd	r24, Z+6	; 0x06
     8a6:	83 30       	cpi	r24, 0x03	; 3
     8a8:	e9 f7       	brne	.-6      	; 0x8a4 <blinkAndSample+0x20>
	ADCB.INTFLAGS = 0b11; //Clear by writing 1 to location
     8aa:	80 93 46 02 	sts	0x0246, r24
	//Print raw samples over usartRINT
	current = ADCB_CH0_RES;
     8ae:	80 91 64 02 	lds	r24, 0x0264
     8b2:	90 91 65 02 	lds	r25, 0x0265
     8b6:	80 93 b7 20 	sts	0x20B7, r24
     8ba:	90 93 b8 20 	sts	0x20B8, r25
	voltage = ADCB_CH1_RES;
     8be:	80 91 6c 02 	lds	r24, 0x026C
     8c2:	90 91 6d 02 	lds	r25, 0x026D
     8c6:	80 93 b0 20 	sts	0x20B0, r24
     8ca:	90 93 b1 20 	sts	0x20B1, r25
	printf("%d %d \n",current, voltage);
     8ce:	20 91 b0 20 	lds	r18, 0x20B0
     8d2:	30 91 b1 20 	lds	r19, 0x20B1
     8d6:	80 91 b7 20 	lds	r24, 0x20B7
     8da:	90 91 b8 20 	lds	r25, 0x20B8
     8de:	3f 93       	push	r19
     8e0:	2f 93       	push	r18
     8e2:	9f 93       	push	r25
     8e4:	8f 93       	push	r24
     8e6:	8b e6       	ldi	r24, 0x6B	; 107
     8e8:	90 e2       	ldi	r25, 0x20	; 32
     8ea:	9f 93       	push	r25
     8ec:	8f 93       	push	r24
     8ee:	0e 94 18 07 	call	0xe30	; 0xe30 <printf>
	finishedPrinting = 0b1;
     8f2:	81 e0       	ldi	r24, 0x01	; 1
     8f4:	80 93 ae 20 	sts	0x20AE, r24
	numSamples++;
     8f8:	80 91 be 20 	lds	r24, 0x20BE
     8fc:	90 91 bf 20 	lds	r25, 0x20BF
     900:	01 96       	adiw	r24, 0x01	; 1
     902:	80 93 be 20 	sts	0x20BE, r24
     906:	90 93 bf 20 	sts	0x20BF, r25
     90a:	0f 90       	pop	r0
     90c:	0f 90       	pop	r0
     90e:	0f 90       	pop	r0
     910:	0f 90       	pop	r0
     912:	0f 90       	pop	r0
     914:	0f 90       	pop	r0
     916:	08 95       	ret

00000918 <calibrate>:
}

void calibrate(){

	//For current, set Muxctrl mode to ouput, then set output to 0
	gpio_set_mode(&PORTD, 0b0, 1);
     918:	41 e0       	ldi	r20, 0x01	; 1
     91a:	60 e0       	ldi	r22, 0x00	; 0
     91c:	80 e6       	ldi	r24, 0x60	; 96
     91e:	96 e0       	ldi	r25, 0x06	; 6
     920:	0e 94 61 03 	call	0x6c2	; 0x6c2 <gpio_set_mode>
//Set the specified pin on the specified port to be in output (1) or input (0) mode.

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
	if(on_or_off) port->OUTSET = pin;
	else port->OUTCLR = pin;
     924:	10 92 66 06 	sts	0x0666, r1
	gpio_set_out(&PORTD, 0b0, 0);

	//Set voltage input to Pin7 GND
	ADCB_CH1_MUXCTRL |= 0b111000; //Set voltage input to gnd
     928:	e9 e6       	ldi	r30, 0x69	; 105
     92a:	f2 e0       	ldi	r31, 0x02	; 2
     92c:	80 81       	ld	r24, Z
     92e:	88 63       	ori	r24, 0x38	; 56
     930:	80 83       	st	Z, r24

	printf("===BEGIN CALIBRATION===");
     932:	83 e7       	ldi	r24, 0x73	; 115
     934:	90 e2       	ldi	r25, 0x20	; 32
     936:	9f 93       	push	r25
     938:	8f 93       	push	r24
     93a:	0e 94 18 07 	call	0xe30	; 0xe30 <printf>
	while(numSamples < 1000){
     93e:	0f 90       	pop	r0
     940:	0f 90       	pop	r0
     942:	80 91 be 20 	lds	r24, 0x20BE
     946:	90 91 bf 20 	lds	r25, 0x20BF
     94a:	88 3e       	cpi	r24, 0xE8	; 232
     94c:	93 40       	sbci	r25, 0x03	; 3
     94e:	48 f4       	brcc	.+18     	; 0x962 <calibrate+0x4a>
		blinkAndSample();
     950:	0e 94 42 04 	call	0x884	; 0x884 <blinkAndSample>

	//Set voltage input to Pin7 GND
	ADCB_CH1_MUXCTRL |= 0b111000; //Set voltage input to gnd

	printf("===BEGIN CALIBRATION===");
	while(numSamples < 1000){
     954:	80 91 be 20 	lds	r24, 0x20BE
     958:	90 91 bf 20 	lds	r25, 0x20BF
     95c:	88 3e       	cpi	r24, 0xE8	; 232
     95e:	93 40       	sbci	r25, 0x03	; 3
     960:	b8 f3       	brcs	.-18     	; 0x950 <calibrate+0x38>
		blinkAndSample();
	}
	printf("===END CALIBRATION===");
     962:	8b e8       	ldi	r24, 0x8B	; 139
     964:	90 e2       	ldi	r25, 0x20	; 32
     966:	9f 93       	push	r25
     968:	8f 93       	push	r24
     96a:	0e 94 18 07 	call	0xe30	; 0xe30 <printf>
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in);
//Set the specified pin on the specified port to be in output (1) or input (0) mode.

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
	if(on_or_off) port->OUTSET = pin;
     96e:	10 92 65 06 	sts	0x0665, r1
	
	//For current, set muxctrl input high
	gpio_set_out(&PORTD, 0b0, 1);
	//Return voltage back to where it was before
	ADCB_CH1_MUXCTRL = (ADCB_CH1_MUXCTRL & 0b111) | 0b10000; //Pin 2 is voltage
     972:	e9 e6       	ldi	r30, 0x69	; 105
     974:	f2 e0       	ldi	r31, 0x02	; 2
     976:	80 81       	ld	r24, Z
     978:	87 70       	andi	r24, 0x07	; 7
     97a:	80 61       	ori	r24, 0x10	; 16
     97c:	80 83       	st	Z, r24
     97e:	0f 90       	pop	r0
     980:	0f 90       	pop	r0
     982:	08 95       	ret

00000984 <spi_txrx>:
#include <avr/io.h>
#include <stdint.h>
#include <stdio.h>

void spi_txrx(SPI_t* spi, void* txd, void* rxd, uint16_t len){	
     984:	cf 93       	push	r28
     986:	df 93       	push	r29
     988:	fc 01       	movw	r30, r24
	
	// Case, want to both send and receive
	if(rxd != NULL && txd != NULL){
     98a:	41 15       	cp	r20, r1
     98c:	51 05       	cpc	r21, r1
     98e:	c1 f0       	breq	.+48     	; 0x9c0 <spi_txrx+0x3c>
     990:	61 15       	cp	r22, r1
     992:	71 05       	cpc	r23, r1
     994:	31 f1       	breq	.+76     	; 0x9e2 <spi_txrx+0x5e>
		for(int i = len-1; i >= 0; i--){
     996:	d9 01       	movw	r26, r18
     998:	11 97       	sbiw	r26, 0x01	; 1
     99a:	92 f1       	brmi	.+100    	; 0xa00 <spi_txrx+0x7c>
     99c:	62 0f       	add	r22, r18
     99e:	73 1f       	adc	r23, r19
     9a0:	24 0f       	add	r18, r20
     9a2:	35 1f       	adc	r19, r21
			spi->DATA = ((uint8_t*)txd)[i];
     9a4:	eb 01       	movw	r28, r22
     9a6:	8a 91       	ld	r24, -Y
     9a8:	be 01       	movw	r22, r28
     9aa:	83 83       	std	Z+3, r24	; 0x03
			
			while(spi->STATUS == 0){
     9ac:	92 81       	ldd	r25, Z+2	; 0x02
     9ae:	99 23       	and	r25, r25
     9b0:	e9 f3       	breq	.-6      	; 0x9ac <spi_txrx+0x28>
			}
			((uint8_t*)rxd)[i] = spi->DATA;
     9b2:	83 81       	ldd	r24, Z+3	; 0x03
     9b4:	e9 01       	movw	r28, r18
     9b6:	8a 93       	st	-Y, r24
     9b8:	9e 01       	movw	r18, r28

void spi_txrx(SPI_t* spi, void* txd, void* rxd, uint16_t len){	
	
	// Case, want to both send and receive
	if(rxd != NULL && txd != NULL){
		for(int i = len-1; i >= 0; i--){
     9ba:	11 97       	sbiw	r26, 0x01	; 1
     9bc:	9a f7       	brpl	.-26     	; 0x9a4 <spi_txrx+0x20>
     9be:	20 c0       	rjmp	.+64     	; 0xa00 <spi_txrx+0x7c>
		}
	}
	
	//Case, just want to send
	else if(rxd == NULL){
		for(int i = len-1; i >= 0; i--){
     9c0:	a9 01       	movw	r20, r18
     9c2:	41 50       	subi	r20, 0x01	; 1
     9c4:	51 09       	sbc	r21, r1
     9c6:	e2 f0       	brmi	.+56     	; 0xa00 <spi_txrx+0x7c>
     9c8:	eb 01       	movw	r28, r22
     9ca:	c2 0f       	add	r28, r18
     9cc:	d3 1f       	adc	r29, r19
			//printf("--> %d \n\r",((uint8_t*)txd)[i]);
			spi->DATA = ((uint8_t*)txd)[i];
     9ce:	8a 91       	ld	r24, -Y
     9d0:	83 83       	std	Z+3, r24	; 0x03
			
			while(spi->STATUS == 0){
     9d2:	82 81       	ldd	r24, Z+2	; 0x02
     9d4:	88 23       	and	r24, r24
     9d6:	e9 f3       	breq	.-6      	; 0x9d2 <spi_txrx+0x4e>
			}
			
			spi->DATA;
     9d8:	83 81       	ldd	r24, Z+3	; 0x03
		}
	}
	
	//Case, just want to send
	else if(rxd == NULL){
		for(int i = len-1; i >= 0; i--){
     9da:	41 50       	subi	r20, 0x01	; 1
     9dc:	51 09       	sbc	r21, r1
     9de:	ba f7       	brpl	.-18     	; 0x9ce <spi_txrx+0x4a>
     9e0:	0f c0       	rjmp	.+30     	; 0xa00 <spi_txrx+0x7c>
		}
	}
	
	//Case, just want to receive
	else if(txd == NULL){
		for(int i = 0; i < len; i++){
     9e2:	21 15       	cp	r18, r1
     9e4:	31 05       	cpc	r19, r1
     9e6:	61 f0       	breq	.+24     	; 0xa00 <spi_txrx+0x7c>
     9e8:	da 01       	movw	r26, r20
     9ea:	24 0f       	add	r18, r20
     9ec:	35 1f       	adc	r19, r21
			spi->DATA = 0x0;
     9ee:	13 82       	std	Z+3, r1	; 0x03
			((uint8_t*)rxd)[i] = spi->DATA;
     9f0:	83 81       	ldd	r24, Z+3	; 0x03
     9f2:	8d 93       	st	X+, r24
			while(spi->STATUS == 0){
     9f4:	82 81       	ldd	r24, Z+2	; 0x02
     9f6:	88 23       	and	r24, r24
     9f8:	e9 f3       	breq	.-6      	; 0x9f4 <spi_txrx+0x70>
		}
	}
	
	//Case, just want to receive
	else if(txd == NULL){
		for(int i = 0; i < len; i++){
     9fa:	a2 17       	cp	r26, r18
     9fc:	b3 07       	cpc	r27, r19
     9fe:	b9 f7       	brne	.-18     	; 0x9ee <spi_txrx+0x6a>
			while(spi->STATUS == 0){
			}
		}
	}

}
     a00:	df 91       	pop	r29
     a02:	cf 91       	pop	r28
     a04:	08 95       	ret

00000a06 <uart_putchar>:
//Configure the USART D0 peripheral to operate at 1 Mbit/s baud, with 8 bit characters, one start bit and one stop bit, and no parity bits.
void uart_init();

//Transmit the specified byte called data over the UART bus. This function will complete when the byte has been fully transmitted.
inline void uart_tx_byte(uint8_t data){
  while(!(USARTD0.STATUS & USART_DREIF_bm)){} //Pause until ReadyToSend bit goes high
     a06:	e0 ea       	ldi	r30, 0xA0	; 160
     a08:	f9 e0       	ldi	r31, 0x09	; 9
     a0a:	91 81       	ldd	r25, Z+1	; 0x01
     a0c:	95 ff       	sbrs	r25, 5
     a0e:	fd cf       	rjmp	.-6      	; 0xa0a <uart_putchar+0x4>
  USARTD0.DATA = data;
     a10:	80 93 a0 09 	sts	0x09A0, r24
  while(!(USARTD0.STATUS & USART_TXCIF_bm)){} //Pause until Done Sending bit goes high
     a14:	e0 ea       	ldi	r30, 0xA0	; 160
     a16:	f9 e0       	ldi	r31, 0x09	; 9
     a18:	91 81       	ldd	r25, Z+1	; 0x01
     a1a:	96 ff       	sbrs	r25, 6
     a1c:	fd cf       	rjmp	.-6      	; 0xa18 <uart_putchar+0x12>
#include "uart.h"
#include <stdio.h>

int uart_putchar(char c, FILE* stream) {
	uart_tx_byte(c);
	if(c == '\n') uart_tx_byte('\r');
     a1e:	8a 30       	cpi	r24, 0x0A	; 10
     a20:	69 f4       	brne	.+26     	; 0xa3c <uart_putchar+0x36>
//Configure the USART D0 peripheral to operate at 1 Mbit/s baud, with 8 bit characters, one start bit and one stop bit, and no parity bits.
void uart_init();

//Transmit the specified byte called data over the UART bus. This function will complete when the byte has been fully transmitted.
inline void uart_tx_byte(uint8_t data){
  while(!(USARTD0.STATUS & USART_DREIF_bm)){} //Pause until ReadyToSend bit goes high
     a22:	e0 ea       	ldi	r30, 0xA0	; 160
     a24:	f9 e0       	ldi	r31, 0x09	; 9
     a26:	81 81       	ldd	r24, Z+1	; 0x01
     a28:	85 ff       	sbrs	r24, 5
     a2a:	fd cf       	rjmp	.-6      	; 0xa26 <uart_putchar+0x20>
  USARTD0.DATA = data;
     a2c:	8d e0       	ldi	r24, 0x0D	; 13
     a2e:	80 93 a0 09 	sts	0x09A0, r24
  while(!(USARTD0.STATUS & USART_TXCIF_bm)){} //Pause until Done Sending bit goes high
     a32:	e0 ea       	ldi	r30, 0xA0	; 160
     a34:	f9 e0       	ldi	r31, 0x09	; 9
     a36:	81 81       	ldd	r24, Z+1	; 0x01
     a38:	86 ff       	sbrs	r24, 6
     a3a:	fd cf       	rjmp	.-6      	; 0xa36 <uart_putchar+0x30>
	return 0;
}
     a3c:	80 e0       	ldi	r24, 0x00	; 0
     a3e:	90 e0       	ldi	r25, 0x00	; 0
     a40:	08 95       	ret

00000a42 <uart_getchar>:
}
  
//Receive the specified byte called data over the UART bus. This function will complete when one byte has been fully received.
inline uint8_t uart_rx_byte(){
  while(!(USARTD0.STATUS & USART_RXCIF_bm)){} //Pause until data ready bit goes high
     a42:	e0 ea       	ldi	r30, 0xA0	; 160
     a44:	f9 e0       	ldi	r31, 0x09	; 9
     a46:	81 81       	ldd	r24, Z+1	; 0x01
     a48:	88 23       	and	r24, r24
     a4a:	ec f7       	brge	.-6      	; 0xa46 <uart_getchar+0x4>
  return USARTD0.DATA;
     a4c:	80 91 a0 09 	lds	r24, 0x09A0

int uart_getchar(FILE* stream) {
	char c = uart_rx_byte();
	return (c == '\r') ? '\n' : c;
     a50:	8d 30       	cpi	r24, 0x0D	; 13
     a52:	11 f0       	breq	.+4      	; 0xa58 <uart_getchar+0x16>
     a54:	90 e0       	ldi	r25, 0x00	; 0
     a56:	08 95       	ret
     a58:	8a e0       	ldi	r24, 0x0A	; 10
     a5a:	90 e0       	ldi	r25, 0x00	; 0
}
     a5c:	08 95       	ret

00000a5e <stdinout_init>:

void stdinout_init(){
	uart_init();
     a5e:	0e 94 47 05 	call	0xa8e	; 0xa8e <uart_init>

	static FILE uart_stream = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

	stdout = &uart_stream;
     a62:	e0 ec       	ldi	r30, 0xC0	; 192
     a64:	f0 e2       	ldi	r31, 0x20	; 32
     a66:	80 e0       	ldi	r24, 0x00	; 0
     a68:	90 e2       	ldi	r25, 0x20	; 32
     a6a:	82 83       	std	Z+2, r24	; 0x02
     a6c:	93 83       	std	Z+3, r25	; 0x03
	stdin = &uart_stream;
     a6e:	80 83       	st	Z, r24
     a70:	91 83       	std	Z+1, r25	; 0x01
     a72:	08 95       	ret

00000a74 <timer_init>:
#include <stdint.h>
#include <avr/io.h>
#include "gpio.h"

//Setup the specified timer peripheral. Clear out any timer state and reset all counters. Set it to have the specified interrupt_level.
void timer_init(TC0_t* timer, uint8_t int_level){
     a74:	fc 01       	movw	r30, r24
	timer->CTRLFSET = timer->CTRLFSET | 0b1000; //Executes reset command on CTRLFSet, see p179
     a76:	81 85       	ldd	r24, Z+9	; 0x09
     a78:	88 60       	ori	r24, 0x08	; 8
     a7a:	81 87       	std	Z+9, r24	; 0x09
	timer->INTCTRLA = 0b1 & int_level; //Enables overflow interrupt. See p134.
     a7c:	61 70       	andi	r22, 0x01	; 1
     a7e:	66 83       	std	Z+6, r22	; 0x06
     a80:	08 95       	ret

00000a82 <timer_set>:
	setBit(timer->CTRLFSET, 0b1000, 1); //Executes restart command on CTRLFSet, see p179
}

//Takes in period as time in microseconds between every overflow interrupt.
void timer_set(TC0_t* timer, uint8_t prescaler, uint16_t period){
	timer->CTRLA = (0b00000111 & prescaler); //Set prescaler by setting lower 3 bits of CLKSel;
     a82:	67 70       	andi	r22, 0x07	; 7
     a84:	fc 01       	movw	r30, r24
     a86:	60 83       	st	Z, r22
	timer->PER = period;
     a88:	46 a3       	std	Z+38, r20	; 0x26
     a8a:	57 a3       	std	Z+39, r21	; 0x27
     a8c:	08 95       	ret

00000a8e <uart_init>:
#include "gpio.h"
#include <avr/io.h>
#include <stdio.h>

void uart_init(){
  gpio_set_mode(&PORTD, 0b100, 0);
     a8e:	40 e0       	ldi	r20, 0x00	; 0
     a90:	64 e0       	ldi	r22, 0x04	; 4
     a92:	80 e6       	ldi	r24, 0x60	; 96
     a94:	96 e0       	ldi	r25, 0x06	; 6
     a96:	0e 94 61 03 	call	0x6c2	; 0x6c2 <gpio_set_mode>
  gpio_set_mode(&PORTD, 0b1000, 1);
     a9a:	41 e0       	ldi	r20, 0x01	; 1
     a9c:	68 e0       	ldi	r22, 0x08	; 8
     a9e:	80 e6       	ldi	r24, 0x60	; 96
     aa0:	96 e0       	ldi	r25, 0x06	; 6
     aa2:	0e 94 61 03 	call	0x6c2	; 0x6c2 <gpio_set_mode>
     aa6:	88 e0       	ldi	r24, 0x08	; 8
     aa8:	80 93 65 06 	sts	0x0665, r24
  gpio_set_out(&PORTD, 0b1000, 1);
  USARTD0.CTRLB = 0b00011000; //Initialize UART
     aac:	e0 ea       	ldi	r30, 0xA0	; 160
     aae:	f9 e0       	ldi	r31, 0x09	; 9
     ab0:	88 e1       	ldi	r24, 0x18	; 24
     ab2:	84 83       	std	Z+4, r24	; 0x04
  USARTD0.CTRLC = 0b00000011; //Set UART start, stop, parity, # data bits
     ab4:	83 e0       	ldi	r24, 0x03	; 3
     ab6:	85 83       	std	Z+5, r24	; 0x05
  USARTD0.BAUDCTRLA = 0b00000000; //This and next line set baud rate to f_clk/16, or 1MHz
     ab8:	16 82       	std	Z+6, r1	; 0x06
  USARTD0.BAUDCTRLB = 0b00000000;
     aba:	17 82       	std	Z+7, r1	; 0x07
     abc:	08 95       	ret

00000abe <__divmodsi4>:
     abe:	05 2e       	mov	r0, r21
     ac0:	97 fb       	bst	r25, 7
     ac2:	1e f4       	brtc	.+6      	; 0xaca <__divmodsi4+0xc>
     ac4:	00 94       	com	r0
     ac6:	0e 94 76 05 	call	0xaec	; 0xaec <__negsi2>
     aca:	57 fd       	sbrc	r21, 7
     acc:	07 d0       	rcall	.+14     	; 0xadc <__divmodsi4_neg2>
     ace:	0e 94 89 05 	call	0xb12	; 0xb12 <__udivmodsi4>
     ad2:	07 fc       	sbrc	r0, 7
     ad4:	03 d0       	rcall	.+6      	; 0xadc <__divmodsi4_neg2>
     ad6:	4e f4       	brtc	.+18     	; 0xaea <__divmodsi4_exit>
     ad8:	0c 94 76 05 	jmp	0xaec	; 0xaec <__negsi2>

00000adc <__divmodsi4_neg2>:
     adc:	50 95       	com	r21
     ade:	40 95       	com	r20
     ae0:	30 95       	com	r19
     ae2:	21 95       	neg	r18
     ae4:	3f 4f       	sbci	r19, 0xFF	; 255
     ae6:	4f 4f       	sbci	r20, 0xFF	; 255
     ae8:	5f 4f       	sbci	r21, 0xFF	; 255

00000aea <__divmodsi4_exit>:
     aea:	08 95       	ret

00000aec <__negsi2>:
     aec:	90 95       	com	r25
     aee:	80 95       	com	r24
     af0:	70 95       	com	r23
     af2:	61 95       	neg	r22
     af4:	7f 4f       	sbci	r23, 0xFF	; 255
     af6:	8f 4f       	sbci	r24, 0xFF	; 255
     af8:	9f 4f       	sbci	r25, 0xFF	; 255
     afa:	08 95       	ret

00000afc <__muluhisi3>:
     afc:	0e 94 ab 05 	call	0xb56	; 0xb56 <__umulhisi3>
     b00:	a5 9f       	mul	r26, r21
     b02:	90 0d       	add	r25, r0
     b04:	b4 9f       	mul	r27, r20
     b06:	90 0d       	add	r25, r0
     b08:	a4 9f       	mul	r26, r20
     b0a:	80 0d       	add	r24, r0
     b0c:	91 1d       	adc	r25, r1
     b0e:	11 24       	eor	r1, r1
     b10:	08 95       	ret

00000b12 <__udivmodsi4>:
     b12:	a1 e2       	ldi	r26, 0x21	; 33
     b14:	1a 2e       	mov	r1, r26
     b16:	aa 1b       	sub	r26, r26
     b18:	bb 1b       	sub	r27, r27
     b1a:	fd 01       	movw	r30, r26
     b1c:	0d c0       	rjmp	.+26     	; 0xb38 <__udivmodsi4_ep>

00000b1e <__udivmodsi4_loop>:
     b1e:	aa 1f       	adc	r26, r26
     b20:	bb 1f       	adc	r27, r27
     b22:	ee 1f       	adc	r30, r30
     b24:	ff 1f       	adc	r31, r31
     b26:	a2 17       	cp	r26, r18
     b28:	b3 07       	cpc	r27, r19
     b2a:	e4 07       	cpc	r30, r20
     b2c:	f5 07       	cpc	r31, r21
     b2e:	20 f0       	brcs	.+8      	; 0xb38 <__udivmodsi4_ep>
     b30:	a2 1b       	sub	r26, r18
     b32:	b3 0b       	sbc	r27, r19
     b34:	e4 0b       	sbc	r30, r20
     b36:	f5 0b       	sbc	r31, r21

00000b38 <__udivmodsi4_ep>:
     b38:	66 1f       	adc	r22, r22
     b3a:	77 1f       	adc	r23, r23
     b3c:	88 1f       	adc	r24, r24
     b3e:	99 1f       	adc	r25, r25
     b40:	1a 94       	dec	r1
     b42:	69 f7       	brne	.-38     	; 0xb1e <__udivmodsi4_loop>
     b44:	60 95       	com	r22
     b46:	70 95       	com	r23
     b48:	80 95       	com	r24
     b4a:	90 95       	com	r25
     b4c:	9b 01       	movw	r18, r22
     b4e:	ac 01       	movw	r20, r24
     b50:	bd 01       	movw	r22, r26
     b52:	cf 01       	movw	r24, r30
     b54:	08 95       	ret

00000b56 <__umulhisi3>:
     b56:	a2 9f       	mul	r26, r18
     b58:	b0 01       	movw	r22, r0
     b5a:	b3 9f       	mul	r27, r19
     b5c:	c0 01       	movw	r24, r0
     b5e:	a3 9f       	mul	r26, r19
     b60:	70 0d       	add	r23, r0
     b62:	81 1d       	adc	r24, r1
     b64:	11 24       	eor	r1, r1
     b66:	91 1d       	adc	r25, r1
     b68:	b2 9f       	mul	r27, r18
     b6a:	70 0d       	add	r23, r0
     b6c:	81 1d       	adc	r24, r1
     b6e:	11 24       	eor	r1, r1
     b70:	91 1d       	adc	r25, r1
     b72:	08 95       	ret

00000b74 <strtol>:
     b74:	2f 92       	push	r2
     b76:	3f 92       	push	r3
     b78:	4f 92       	push	r4
     b7a:	5f 92       	push	r5
     b7c:	6f 92       	push	r6
     b7e:	7f 92       	push	r7
     b80:	8f 92       	push	r8
     b82:	9f 92       	push	r9
     b84:	af 92       	push	r10
     b86:	bf 92       	push	r11
     b88:	cf 92       	push	r12
     b8a:	df 92       	push	r13
     b8c:	ef 92       	push	r14
     b8e:	ff 92       	push	r15
     b90:	0f 93       	push	r16
     b92:	1f 93       	push	r17
     b94:	cf 93       	push	r28
     b96:	df 93       	push	r29
     b98:	5c 01       	movw	r10, r24
     b9a:	6b 01       	movw	r12, r22
     b9c:	7a 01       	movw	r14, r20
     b9e:	61 15       	cp	r22, r1
     ba0:	71 05       	cpc	r23, r1
     ba2:	19 f0       	breq	.+6      	; 0xbaa <strtol+0x36>
     ba4:	fb 01       	movw	r30, r22
     ba6:	80 83       	st	Z, r24
     ba8:	91 83       	std	Z+1, r25	; 0x01
     baa:	e1 14       	cp	r14, r1
     bac:	f1 04       	cpc	r15, r1
     bae:	29 f0       	breq	.+10     	; 0xbba <strtol+0x46>
     bb0:	c7 01       	movw	r24, r14
     bb2:	02 97       	sbiw	r24, 0x02	; 2
     bb4:	83 97       	sbiw	r24, 0x23	; 35
     bb6:	08 f0       	brcs	.+2      	; 0xbba <strtol+0x46>
     bb8:	f1 c0       	rjmp	.+482    	; 0xd9c <strtol+0x228>
     bba:	e5 01       	movw	r28, r10
     bbc:	21 96       	adiw	r28, 0x01	; 1
     bbe:	f5 01       	movw	r30, r10
     bc0:	10 81       	ld	r17, Z
     bc2:	81 2f       	mov	r24, r17
     bc4:	90 e0       	ldi	r25, 0x00	; 0
     bc6:	0e 94 e5 06 	call	0xdca	; 0xdca <isspace>
     bca:	89 2b       	or	r24, r25
     bcc:	11 f0       	breq	.+4      	; 0xbd2 <strtol+0x5e>
     bce:	5e 01       	movw	r10, r28
     bd0:	f4 cf       	rjmp	.-24     	; 0xbba <strtol+0x46>
     bd2:	1d 32       	cpi	r17, 0x2D	; 45
     bd4:	29 f4       	brne	.+10     	; 0xbe0 <strtol+0x6c>
     bd6:	21 96       	adiw	r28, 0x01	; 1
     bd8:	f5 01       	movw	r30, r10
     bda:	11 81       	ldd	r17, Z+1	; 0x01
     bdc:	01 e0       	ldi	r16, 0x01	; 1
     bde:	07 c0       	rjmp	.+14     	; 0xbee <strtol+0x7a>
     be0:	1b 32       	cpi	r17, 0x2B	; 43
     be2:	21 f4       	brne	.+8      	; 0xbec <strtol+0x78>
     be4:	e5 01       	movw	r28, r10
     be6:	22 96       	adiw	r28, 0x02	; 2
     be8:	f5 01       	movw	r30, r10
     bea:	11 81       	ldd	r17, Z+1	; 0x01
     bec:	00 e0       	ldi	r16, 0x00	; 0
     bee:	e1 14       	cp	r14, r1
     bf0:	f1 04       	cpc	r15, r1
     bf2:	59 f1       	breq	.+86     	; 0xc4a <strtol+0xd6>
     bf4:	f0 e1       	ldi	r31, 0x10	; 16
     bf6:	ef 16       	cp	r14, r31
     bf8:	f1 04       	cpc	r15, r1
     bfa:	61 f4       	brne	.+24     	; 0xc14 <strtol+0xa0>
     bfc:	10 33       	cpi	r17, 0x30	; 48
     bfe:	e1 f4       	brne	.+56     	; 0xc38 <strtol+0xc4>
     c00:	88 81       	ld	r24, Y
     c02:	8f 7d       	andi	r24, 0xDF	; 223
     c04:	88 35       	cpi	r24, 0x58	; 88
     c06:	69 f5       	brne	.+90     	; 0xc62 <strtol+0xee>
     c08:	19 81       	ldd	r17, Y+1	; 0x01
     c0a:	22 96       	adiw	r28, 0x02	; 2
     c0c:	02 60       	ori	r16, 0x02	; 2
     c0e:	70 e1       	ldi	r23, 0x10	; 16
     c10:	e7 2e       	mov	r14, r23
     c12:	f1 2c       	mov	r15, r1
     c14:	88 e0       	ldi	r24, 0x08	; 8
     c16:	e8 16       	cp	r14, r24
     c18:	f1 04       	cpc	r15, r1
     c1a:	39 f1       	breq	.+78     	; 0xc6a <strtol+0xf6>
     c1c:	2c f4       	brge	.+10     	; 0xc28 <strtol+0xb4>
     c1e:	f2 e0       	ldi	r31, 0x02	; 2
     c20:	ef 16       	cp	r14, r31
     c22:	f1 04       	cpc	r15, r1
     c24:	c9 f1       	breq	.+114    	; 0xc98 <strtol+0x124>
     c26:	2a c0       	rjmp	.+84     	; 0xc7c <strtol+0x108>
     c28:	8a e0       	ldi	r24, 0x0A	; 10
     c2a:	e8 16       	cp	r14, r24
     c2c:	f1 04       	cpc	r15, r1
     c2e:	79 f0       	breq	.+30     	; 0xc4e <strtol+0xda>
     c30:	e0 e1       	ldi	r30, 0x10	; 16
     c32:	ee 16       	cp	r14, r30
     c34:	f1 04       	cpc	r15, r1
     c36:	11 f5       	brne	.+68     	; 0xc7c <strtol+0x108>
     c38:	50 e1       	ldi	r21, 0x10	; 16
     c3a:	e5 2e       	mov	r14, r21
     c3c:	f1 2c       	mov	r15, r1
     c3e:	81 2c       	mov	r8, r1
     c40:	91 2c       	mov	r9, r1
     c42:	a1 2c       	mov	r10, r1
     c44:	68 e0       	ldi	r22, 0x08	; 8
     c46:	b6 2e       	mov	r11, r22
     c48:	2c c0       	rjmp	.+88     	; 0xca2 <strtol+0x12e>
     c4a:	10 33       	cpi	r17, 0x30	; 48
     c4c:	c9 f2       	breq	.-78     	; 0xc00 <strtol+0x8c>
     c4e:	3a e0       	ldi	r19, 0x0A	; 10
     c50:	e3 2e       	mov	r14, r19
     c52:	f1 2c       	mov	r15, r1
     c54:	4c ec       	ldi	r20, 0xCC	; 204
     c56:	84 2e       	mov	r8, r20
     c58:	98 2c       	mov	r9, r8
     c5a:	a8 2c       	mov	r10, r8
     c5c:	4c e0       	ldi	r20, 0x0C	; 12
     c5e:	b4 2e       	mov	r11, r20
     c60:	20 c0       	rjmp	.+64     	; 0xca2 <strtol+0x12e>
     c62:	10 e3       	ldi	r17, 0x30	; 48
     c64:	e1 14       	cp	r14, r1
     c66:	f1 04       	cpc	r15, r1
     c68:	a9 f6       	brne	.-86     	; 0xc14 <strtol+0xa0>
     c6a:	98 e0       	ldi	r25, 0x08	; 8
     c6c:	e9 2e       	mov	r14, r25
     c6e:	f1 2c       	mov	r15, r1
     c70:	81 2c       	mov	r8, r1
     c72:	91 2c       	mov	r9, r1
     c74:	a1 2c       	mov	r10, r1
     c76:	20 e1       	ldi	r18, 0x10	; 16
     c78:	b2 2e       	mov	r11, r18
     c7a:	13 c0       	rjmp	.+38     	; 0xca2 <strtol+0x12e>
     c7c:	60 e0       	ldi	r22, 0x00	; 0
     c7e:	70 e0       	ldi	r23, 0x00	; 0
     c80:	80 e0       	ldi	r24, 0x00	; 0
     c82:	90 e8       	ldi	r25, 0x80	; 128
     c84:	97 01       	movw	r18, r14
     c86:	0f 2c       	mov	r0, r15
     c88:	00 0c       	add	r0, r0
     c8a:	44 0b       	sbc	r20, r20
     c8c:	55 0b       	sbc	r21, r21
     c8e:	0e 94 89 05 	call	0xb12	; 0xb12 <__udivmodsi4>
     c92:	49 01       	movw	r8, r18
     c94:	5a 01       	movw	r10, r20
     c96:	05 c0       	rjmp	.+10     	; 0xca2 <strtol+0x12e>
     c98:	81 2c       	mov	r8, r1
     c9a:	91 2c       	mov	r9, r1
     c9c:	a1 2c       	mov	r10, r1
     c9e:	80 e4       	ldi	r24, 0x40	; 64
     ca0:	b8 2e       	mov	r11, r24
     ca2:	60 e0       	ldi	r22, 0x00	; 0
     ca4:	20 e0       	ldi	r18, 0x00	; 0
     ca6:	30 e0       	ldi	r19, 0x00	; 0
     ca8:	a9 01       	movw	r20, r18
     caa:	27 01       	movw	r4, r14
     cac:	0f 2c       	mov	r0, r15
     cae:	00 0c       	add	r0, r0
     cb0:	66 08       	sbc	r6, r6
     cb2:	77 08       	sbc	r7, r7
     cb4:	1e 01       	movw	r2, r28
     cb6:	e0 ed       	ldi	r30, 0xD0	; 208
     cb8:	e1 0f       	add	r30, r17
     cba:	ea 30       	cpi	r30, 0x0A	; 10
     cbc:	60 f0       	brcs	.+24     	; 0xcd6 <strtol+0x162>
     cbe:	8f eb       	ldi	r24, 0xBF	; 191
     cc0:	81 0f       	add	r24, r17
     cc2:	8a 31       	cpi	r24, 0x1A	; 26
     cc4:	10 f4       	brcc	.+4      	; 0xcca <strtol+0x156>
     cc6:	e9 ec       	ldi	r30, 0xC9	; 201
     cc8:	05 c0       	rjmp	.+10     	; 0xcd4 <strtol+0x160>
     cca:	8f e9       	ldi	r24, 0x9F	; 159
     ccc:	81 0f       	add	r24, r17
     cce:	8a 31       	cpi	r24, 0x1A	; 26
     cd0:	28 f5       	brcc	.+74     	; 0xd1c <strtol+0x1a8>
     cd2:	e9 ea       	ldi	r30, 0xA9	; 169
     cd4:	e1 0f       	add	r30, r17
     cd6:	8e 2f       	mov	r24, r30
     cd8:	90 e0       	ldi	r25, 0x00	; 0
     cda:	8e 15       	cp	r24, r14
     cdc:	9f 05       	cpc	r25, r15
     cde:	f4 f4       	brge	.+60     	; 0xd1c <strtol+0x1a8>
     ce0:	67 fd       	sbrc	r22, 7
     ce2:	18 c0       	rjmp	.+48     	; 0xd14 <strtol+0x1a0>
     ce4:	82 16       	cp	r8, r18
     ce6:	93 06       	cpc	r9, r19
     ce8:	a4 06       	cpc	r10, r20
     cea:	b5 06       	cpc	r11, r21
     cec:	90 f0       	brcs	.+36     	; 0xd12 <strtol+0x19e>
     cee:	c3 01       	movw	r24, r6
     cf0:	b2 01       	movw	r22, r4
     cf2:	0e 94 3e 0a 	call	0x147c	; 0x147c <__mulsi3>
     cf6:	9b 01       	movw	r18, r22
     cf8:	ac 01       	movw	r20, r24
     cfa:	2e 0f       	add	r18, r30
     cfc:	31 1d       	adc	r19, r1
     cfe:	41 1d       	adc	r20, r1
     d00:	51 1d       	adc	r21, r1
     d02:	21 30       	cpi	r18, 0x01	; 1
     d04:	31 05       	cpc	r19, r1
     d06:	41 05       	cpc	r20, r1
     d08:	f0 e8       	ldi	r31, 0x80	; 128
     d0a:	5f 07       	cpc	r21, r31
     d0c:	10 f4       	brcc	.+4      	; 0xd12 <strtol+0x19e>
     d0e:	61 e0       	ldi	r22, 0x01	; 1
     d10:	01 c0       	rjmp	.+2      	; 0xd14 <strtol+0x1a0>
     d12:	6f ef       	ldi	r22, 0xFF	; 255
     d14:	21 96       	adiw	r28, 0x01	; 1
     d16:	f1 01       	movw	r30, r2
     d18:	10 81       	ld	r17, Z
     d1a:	cc cf       	rjmp	.-104    	; 0xcb4 <strtol+0x140>
     d1c:	80 2f       	mov	r24, r16
     d1e:	81 70       	andi	r24, 0x01	; 1
     d20:	c1 14       	cp	r12, r1
     d22:	d1 04       	cpc	r13, r1
     d24:	71 f0       	breq	.+28     	; 0xd42 <strtol+0x1ce>
     d26:	66 23       	and	r22, r22
     d28:	29 f0       	breq	.+10     	; 0xd34 <strtol+0x1c0>
     d2a:	21 97       	sbiw	r28, 0x01	; 1
     d2c:	f6 01       	movw	r30, r12
     d2e:	c0 83       	st	Z, r28
     d30:	d1 83       	std	Z+1, r29	; 0x01
     d32:	07 c0       	rjmp	.+14     	; 0xd42 <strtol+0x1ce>
     d34:	01 ff       	sbrs	r16, 1
     d36:	19 c0       	rjmp	.+50     	; 0xd6a <strtol+0x1f6>
     d38:	22 97       	sbiw	r28, 0x02	; 2
     d3a:	f6 01       	movw	r30, r12
     d3c:	c0 83       	st	Z, r28
     d3e:	d1 83       	std	Z+1, r29	; 0x01
     d40:	14 c0       	rjmp	.+40     	; 0xd6a <strtol+0x1f6>
     d42:	67 ff       	sbrs	r22, 7
     d44:	12 c0       	rjmp	.+36     	; 0xd6a <strtol+0x1f6>
     d46:	81 11       	cpse	r24, r1
     d48:	05 c0       	rjmp	.+10     	; 0xd54 <strtol+0x1e0>
     d4a:	2f ef       	ldi	r18, 0xFF	; 255
     d4c:	3f ef       	ldi	r19, 0xFF	; 255
     d4e:	4f ef       	ldi	r20, 0xFF	; 255
     d50:	5f e7       	ldi	r21, 0x7F	; 127
     d52:	04 c0       	rjmp	.+8      	; 0xd5c <strtol+0x1e8>
     d54:	20 e0       	ldi	r18, 0x00	; 0
     d56:	30 e0       	ldi	r19, 0x00	; 0
     d58:	40 e0       	ldi	r20, 0x00	; 0
     d5a:	50 e8       	ldi	r21, 0x80	; 128
     d5c:	82 e2       	ldi	r24, 0x22	; 34
     d5e:	90 e0       	ldi	r25, 0x00	; 0
     d60:	80 93 c6 20 	sts	0x20C6, r24
     d64:	90 93 c7 20 	sts	0x20C7, r25
     d68:	16 c0       	rjmp	.+44     	; 0xd96 <strtol+0x222>
     d6a:	88 23       	and	r24, r24
     d6c:	41 f0       	breq	.+16     	; 0xd7e <strtol+0x20a>
     d6e:	50 95       	com	r21
     d70:	40 95       	com	r20
     d72:	30 95       	com	r19
     d74:	21 95       	neg	r18
     d76:	3f 4f       	sbci	r19, 0xFF	; 255
     d78:	4f 4f       	sbci	r20, 0xFF	; 255
     d7a:	5f 4f       	sbci	r21, 0xFF	; 255
     d7c:	0c c0       	rjmp	.+24     	; 0xd96 <strtol+0x222>
     d7e:	57 ff       	sbrs	r21, 7
     d80:	0a c0       	rjmp	.+20     	; 0xd96 <strtol+0x222>
     d82:	82 e2       	ldi	r24, 0x22	; 34
     d84:	90 e0       	ldi	r25, 0x00	; 0
     d86:	80 93 c6 20 	sts	0x20C6, r24
     d8a:	90 93 c7 20 	sts	0x20C7, r25
     d8e:	2f ef       	ldi	r18, 0xFF	; 255
     d90:	3f ef       	ldi	r19, 0xFF	; 255
     d92:	4f ef       	ldi	r20, 0xFF	; 255
     d94:	5f e7       	ldi	r21, 0x7F	; 127
     d96:	b9 01       	movw	r22, r18
     d98:	ca 01       	movw	r24, r20
     d9a:	04 c0       	rjmp	.+8      	; 0xda4 <strtol+0x230>
     d9c:	60 e0       	ldi	r22, 0x00	; 0
     d9e:	70 e0       	ldi	r23, 0x00	; 0
     da0:	80 e0       	ldi	r24, 0x00	; 0
     da2:	90 e0       	ldi	r25, 0x00	; 0
     da4:	df 91       	pop	r29
     da6:	cf 91       	pop	r28
     da8:	1f 91       	pop	r17
     daa:	0f 91       	pop	r16
     dac:	ff 90       	pop	r15
     dae:	ef 90       	pop	r14
     db0:	df 90       	pop	r13
     db2:	cf 90       	pop	r12
     db4:	bf 90       	pop	r11
     db6:	af 90       	pop	r10
     db8:	9f 90       	pop	r9
     dba:	8f 90       	pop	r8
     dbc:	7f 90       	pop	r7
     dbe:	6f 90       	pop	r6
     dc0:	5f 90       	pop	r5
     dc2:	4f 90       	pop	r4
     dc4:	3f 90       	pop	r3
     dc6:	2f 90       	pop	r2
     dc8:	08 95       	ret

00000dca <isspace>:
     dca:	91 11       	cpse	r25, r1
     dcc:	0c 94 51 09 	jmp	0x12a2	; 0x12a2 <__ctype_isfalse>
     dd0:	80 32       	cpi	r24, 0x20	; 32
     dd2:	19 f0       	breq	.+6      	; 0xdda <isspace+0x10>
     dd4:	89 50       	subi	r24, 0x09	; 9
     dd6:	85 50       	subi	r24, 0x05	; 5
     dd8:	c8 f7       	brcc	.-14     	; 0xdcc <isspace+0x2>
     dda:	08 95       	ret

00000ddc <gets>:
     ddc:	0f 93       	push	r16
     dde:	1f 93       	push	r17
     de0:	cf 93       	push	r28
     de2:	df 93       	push	r29
     de4:	e0 91 c0 20 	lds	r30, 0x20C0
     de8:	f0 91 c1 20 	lds	r31, 0x20C1
     dec:	23 81       	ldd	r18, Z+3	; 0x03
     dee:	20 fd       	sbrc	r18, 0
     df0:	03 c0       	rjmp	.+6      	; 0xdf8 <gets+0x1c>
     df2:	80 e0       	ldi	r24, 0x00	; 0
     df4:	90 e0       	ldi	r25, 0x00	; 0
     df6:	17 c0       	rjmp	.+46     	; 0xe26 <gets+0x4a>
     df8:	c9 2f       	mov	r28, r25
     dfa:	d8 2f       	mov	r29, r24
     dfc:	08 2f       	mov	r16, r24
     dfe:	19 2f       	mov	r17, r25
     e00:	80 91 c0 20 	lds	r24, 0x20C0
     e04:	90 91 c1 20 	lds	r25, 0x20C1
     e08:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <fgetc>
     e0c:	8f 3f       	cpi	r24, 0xFF	; 255
     e0e:	2f ef       	ldi	r18, 0xFF	; 255
     e10:	92 07       	cpc	r25, r18
     e12:	79 f3       	breq	.-34     	; 0xdf2 <gets+0x16>
     e14:	f8 01       	movw	r30, r16
     e16:	81 93       	st	Z+, r24
     e18:	8f 01       	movw	r16, r30
     e1a:	0a 97       	sbiw	r24, 0x0a	; 10
     e1c:	89 f7       	brne	.-30     	; 0xe00 <gets+0x24>
     e1e:	31 97       	sbiw	r30, 0x01	; 1
     e20:	10 82       	st	Z, r1
     e22:	8d 2f       	mov	r24, r29
     e24:	9c 2f       	mov	r25, r28
     e26:	df 91       	pop	r29
     e28:	cf 91       	pop	r28
     e2a:	1f 91       	pop	r17
     e2c:	0f 91       	pop	r16
     e2e:	08 95       	ret

00000e30 <printf>:
     e30:	cf 93       	push	r28
     e32:	df 93       	push	r29
     e34:	cd b7       	in	r28, 0x3d	; 61
     e36:	de b7       	in	r29, 0x3e	; 62
     e38:	ae 01       	movw	r20, r28
     e3a:	4a 5f       	subi	r20, 0xFA	; 250
     e3c:	5f 4f       	sbci	r21, 0xFF	; 255
     e3e:	fa 01       	movw	r30, r20
     e40:	61 91       	ld	r22, Z+
     e42:	71 91       	ld	r23, Z+
     e44:	af 01       	movw	r20, r30
     e46:	80 91 c2 20 	lds	r24, 0x20C2
     e4a:	90 91 c3 20 	lds	r25, 0x20C3
     e4e:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vfprintf>
     e52:	df 91       	pop	r29
     e54:	cf 91       	pop	r28
     e56:	08 95       	ret

00000e58 <puts>:
     e58:	0f 93       	push	r16
     e5a:	1f 93       	push	r17
     e5c:	cf 93       	push	r28
     e5e:	df 93       	push	r29
     e60:	e0 91 c2 20 	lds	r30, 0x20C2
     e64:	f0 91 c3 20 	lds	r31, 0x20C3
     e68:	23 81       	ldd	r18, Z+3	; 0x03
     e6a:	21 ff       	sbrs	r18, 1
     e6c:	1b c0       	rjmp	.+54     	; 0xea4 <puts+0x4c>
     e6e:	8c 01       	movw	r16, r24
     e70:	d0 e0       	ldi	r29, 0x00	; 0
     e72:	c0 e0       	ldi	r28, 0x00	; 0
     e74:	f8 01       	movw	r30, r16
     e76:	81 91       	ld	r24, Z+
     e78:	8f 01       	movw	r16, r30
     e7a:	60 91 c2 20 	lds	r22, 0x20C2
     e7e:	70 91 c3 20 	lds	r23, 0x20C3
     e82:	db 01       	movw	r26, r22
     e84:	18 96       	adiw	r26, 0x08	; 8
     e86:	ed 91       	ld	r30, X+
     e88:	fc 91       	ld	r31, X
     e8a:	19 97       	sbiw	r26, 0x09	; 9
     e8c:	88 23       	and	r24, r24
     e8e:	31 f0       	breq	.+12     	; 0xe9c <puts+0x44>
     e90:	19 95       	eicall
     e92:	89 2b       	or	r24, r25
     e94:	79 f3       	breq	.-34     	; 0xe74 <puts+0x1c>
     e96:	df ef       	ldi	r29, 0xFF	; 255
     e98:	cf ef       	ldi	r28, 0xFF	; 255
     e9a:	ec cf       	rjmp	.-40     	; 0xe74 <puts+0x1c>
     e9c:	8a e0       	ldi	r24, 0x0A	; 10
     e9e:	19 95       	eicall
     ea0:	89 2b       	or	r24, r25
     ea2:	19 f0       	breq	.+6      	; 0xeaa <puts+0x52>
     ea4:	8f ef       	ldi	r24, 0xFF	; 255
     ea6:	9f ef       	ldi	r25, 0xFF	; 255
     ea8:	02 c0       	rjmp	.+4      	; 0xeae <puts+0x56>
     eaa:	8d 2f       	mov	r24, r29
     eac:	9c 2f       	mov	r25, r28
     eae:	df 91       	pop	r29
     eb0:	cf 91       	pop	r28
     eb2:	1f 91       	pop	r17
     eb4:	0f 91       	pop	r16
     eb6:	08 95       	ret

00000eb8 <vfprintf>:
     eb8:	2f 92       	push	r2
     eba:	3f 92       	push	r3
     ebc:	4f 92       	push	r4
     ebe:	5f 92       	push	r5
     ec0:	6f 92       	push	r6
     ec2:	7f 92       	push	r7
     ec4:	8f 92       	push	r8
     ec6:	9f 92       	push	r9
     ec8:	af 92       	push	r10
     eca:	bf 92       	push	r11
     ecc:	cf 92       	push	r12
     ece:	df 92       	push	r13
     ed0:	ef 92       	push	r14
     ed2:	ff 92       	push	r15
     ed4:	0f 93       	push	r16
     ed6:	1f 93       	push	r17
     ed8:	cf 93       	push	r28
     eda:	df 93       	push	r29
     edc:	cd b7       	in	r28, 0x3d	; 61
     ede:	de b7       	in	r29, 0x3e	; 62
     ee0:	2c 97       	sbiw	r28, 0x0c	; 12
     ee2:	cd bf       	out	0x3d, r28	; 61
     ee4:	de bf       	out	0x3e, r29	; 62
     ee6:	7c 01       	movw	r14, r24
     ee8:	6b 01       	movw	r12, r22
     eea:	8a 01       	movw	r16, r20
     eec:	fc 01       	movw	r30, r24
     eee:	16 82       	std	Z+6, r1	; 0x06
     ef0:	17 82       	std	Z+7, r1	; 0x07
     ef2:	83 81       	ldd	r24, Z+3	; 0x03
     ef4:	81 ff       	sbrs	r24, 1
     ef6:	bd c1       	rjmp	.+890    	; 0x1272 <vfprintf+0x3ba>
     ef8:	ce 01       	movw	r24, r28
     efa:	01 96       	adiw	r24, 0x01	; 1
     efc:	4c 01       	movw	r8, r24
     efe:	f7 01       	movw	r30, r14
     f00:	93 81       	ldd	r25, Z+3	; 0x03
     f02:	f6 01       	movw	r30, r12
     f04:	93 fd       	sbrc	r25, 3
     f06:	85 91       	lpm	r24, Z+
     f08:	93 ff       	sbrs	r25, 3
     f0a:	81 91       	ld	r24, Z+
     f0c:	6f 01       	movw	r12, r30
     f0e:	88 23       	and	r24, r24
     f10:	09 f4       	brne	.+2      	; 0xf14 <vfprintf+0x5c>
     f12:	ab c1       	rjmp	.+854    	; 0x126a <vfprintf+0x3b2>
     f14:	85 32       	cpi	r24, 0x25	; 37
     f16:	39 f4       	brne	.+14     	; 0xf26 <vfprintf+0x6e>
     f18:	93 fd       	sbrc	r25, 3
     f1a:	85 91       	lpm	r24, Z+
     f1c:	93 ff       	sbrs	r25, 3
     f1e:	81 91       	ld	r24, Z+
     f20:	6f 01       	movw	r12, r30
     f22:	85 32       	cpi	r24, 0x25	; 37
     f24:	29 f4       	brne	.+10     	; 0xf30 <vfprintf+0x78>
     f26:	b7 01       	movw	r22, r14
     f28:	90 e0       	ldi	r25, 0x00	; 0
     f2a:	0e 94 a8 09 	call	0x1350	; 0x1350 <fputc>
     f2e:	e7 cf       	rjmp	.-50     	; 0xefe <vfprintf+0x46>
     f30:	51 2c       	mov	r5, r1
     f32:	31 2c       	mov	r3, r1
     f34:	20 e0       	ldi	r18, 0x00	; 0
     f36:	20 32       	cpi	r18, 0x20	; 32
     f38:	a0 f4       	brcc	.+40     	; 0xf62 <vfprintf+0xaa>
     f3a:	8b 32       	cpi	r24, 0x2B	; 43
     f3c:	69 f0       	breq	.+26     	; 0xf58 <vfprintf+0xa0>
     f3e:	30 f4       	brcc	.+12     	; 0xf4c <vfprintf+0x94>
     f40:	80 32       	cpi	r24, 0x20	; 32
     f42:	59 f0       	breq	.+22     	; 0xf5a <vfprintf+0xa2>
     f44:	83 32       	cpi	r24, 0x23	; 35
     f46:	69 f4       	brne	.+26     	; 0xf62 <vfprintf+0xaa>
     f48:	20 61       	ori	r18, 0x10	; 16
     f4a:	2c c0       	rjmp	.+88     	; 0xfa4 <vfprintf+0xec>
     f4c:	8d 32       	cpi	r24, 0x2D	; 45
     f4e:	39 f0       	breq	.+14     	; 0xf5e <vfprintf+0xa6>
     f50:	80 33       	cpi	r24, 0x30	; 48
     f52:	39 f4       	brne	.+14     	; 0xf62 <vfprintf+0xaa>
     f54:	21 60       	ori	r18, 0x01	; 1
     f56:	26 c0       	rjmp	.+76     	; 0xfa4 <vfprintf+0xec>
     f58:	22 60       	ori	r18, 0x02	; 2
     f5a:	24 60       	ori	r18, 0x04	; 4
     f5c:	23 c0       	rjmp	.+70     	; 0xfa4 <vfprintf+0xec>
     f5e:	28 60       	ori	r18, 0x08	; 8
     f60:	21 c0       	rjmp	.+66     	; 0xfa4 <vfprintf+0xec>
     f62:	27 fd       	sbrc	r18, 7
     f64:	27 c0       	rjmp	.+78     	; 0xfb4 <vfprintf+0xfc>
     f66:	30 ed       	ldi	r19, 0xD0	; 208
     f68:	38 0f       	add	r19, r24
     f6a:	3a 30       	cpi	r19, 0x0A	; 10
     f6c:	78 f4       	brcc	.+30     	; 0xf8c <vfprintf+0xd4>
     f6e:	26 ff       	sbrs	r18, 6
     f70:	06 c0       	rjmp	.+12     	; 0xf7e <vfprintf+0xc6>
     f72:	fa e0       	ldi	r31, 0x0A	; 10
     f74:	5f 9e       	mul	r5, r31
     f76:	30 0d       	add	r19, r0
     f78:	11 24       	eor	r1, r1
     f7a:	53 2e       	mov	r5, r19
     f7c:	13 c0       	rjmp	.+38     	; 0xfa4 <vfprintf+0xec>
     f7e:	8a e0       	ldi	r24, 0x0A	; 10
     f80:	38 9e       	mul	r3, r24
     f82:	30 0d       	add	r19, r0
     f84:	11 24       	eor	r1, r1
     f86:	33 2e       	mov	r3, r19
     f88:	20 62       	ori	r18, 0x20	; 32
     f8a:	0c c0       	rjmp	.+24     	; 0xfa4 <vfprintf+0xec>
     f8c:	8e 32       	cpi	r24, 0x2E	; 46
     f8e:	21 f4       	brne	.+8      	; 0xf98 <vfprintf+0xe0>
     f90:	26 fd       	sbrc	r18, 6
     f92:	6b c1       	rjmp	.+726    	; 0x126a <vfprintf+0x3b2>
     f94:	20 64       	ori	r18, 0x40	; 64
     f96:	06 c0       	rjmp	.+12     	; 0xfa4 <vfprintf+0xec>
     f98:	8c 36       	cpi	r24, 0x6C	; 108
     f9a:	11 f4       	brne	.+4      	; 0xfa0 <vfprintf+0xe8>
     f9c:	20 68       	ori	r18, 0x80	; 128
     f9e:	02 c0       	rjmp	.+4      	; 0xfa4 <vfprintf+0xec>
     fa0:	88 36       	cpi	r24, 0x68	; 104
     fa2:	41 f4       	brne	.+16     	; 0xfb4 <vfprintf+0xfc>
     fa4:	f6 01       	movw	r30, r12
     fa6:	93 fd       	sbrc	r25, 3
     fa8:	85 91       	lpm	r24, Z+
     faa:	93 ff       	sbrs	r25, 3
     fac:	81 91       	ld	r24, Z+
     fae:	6f 01       	movw	r12, r30
     fb0:	81 11       	cpse	r24, r1
     fb2:	c1 cf       	rjmp	.-126    	; 0xf36 <vfprintf+0x7e>
     fb4:	98 2f       	mov	r25, r24
     fb6:	9f 7d       	andi	r25, 0xDF	; 223
     fb8:	95 54       	subi	r25, 0x45	; 69
     fba:	93 30       	cpi	r25, 0x03	; 3
     fbc:	28 f4       	brcc	.+10     	; 0xfc8 <vfprintf+0x110>
     fbe:	0c 5f       	subi	r16, 0xFC	; 252
     fc0:	1f 4f       	sbci	r17, 0xFF	; 255
     fc2:	ff e3       	ldi	r31, 0x3F	; 63
     fc4:	f9 83       	std	Y+1, r31	; 0x01
     fc6:	0d c0       	rjmp	.+26     	; 0xfe2 <vfprintf+0x12a>
     fc8:	83 36       	cpi	r24, 0x63	; 99
     fca:	31 f0       	breq	.+12     	; 0xfd8 <vfprintf+0x120>
     fcc:	83 37       	cpi	r24, 0x73	; 115
     fce:	71 f0       	breq	.+28     	; 0xfec <vfprintf+0x134>
     fd0:	83 35       	cpi	r24, 0x53	; 83
     fd2:	09 f0       	breq	.+2      	; 0xfd6 <vfprintf+0x11e>
     fd4:	5b c0       	rjmp	.+182    	; 0x108c <vfprintf+0x1d4>
     fd6:	22 c0       	rjmp	.+68     	; 0x101c <vfprintf+0x164>
     fd8:	f8 01       	movw	r30, r16
     fda:	80 81       	ld	r24, Z
     fdc:	89 83       	std	Y+1, r24	; 0x01
     fde:	0e 5f       	subi	r16, 0xFE	; 254
     fe0:	1f 4f       	sbci	r17, 0xFF	; 255
     fe2:	44 24       	eor	r4, r4
     fe4:	43 94       	inc	r4
     fe6:	51 2c       	mov	r5, r1
     fe8:	54 01       	movw	r10, r8
     fea:	15 c0       	rjmp	.+42     	; 0x1016 <vfprintf+0x15e>
     fec:	38 01       	movw	r6, r16
     fee:	f2 e0       	ldi	r31, 0x02	; 2
     ff0:	6f 0e       	add	r6, r31
     ff2:	71 1c       	adc	r7, r1
     ff4:	f8 01       	movw	r30, r16
     ff6:	a0 80       	ld	r10, Z
     ff8:	b1 80       	ldd	r11, Z+1	; 0x01
     ffa:	26 ff       	sbrs	r18, 6
     ffc:	03 c0       	rjmp	.+6      	; 0x1004 <vfprintf+0x14c>
     ffe:	65 2d       	mov	r22, r5
    1000:	70 e0       	ldi	r23, 0x00	; 0
    1002:	02 c0       	rjmp	.+4      	; 0x1008 <vfprintf+0x150>
    1004:	6f ef       	ldi	r22, 0xFF	; 255
    1006:	7f ef       	ldi	r23, 0xFF	; 255
    1008:	c5 01       	movw	r24, r10
    100a:	2c 87       	std	Y+12, r18	; 0x0c
    100c:	0e 94 5f 09 	call	0x12be	; 0x12be <strnlen>
    1010:	2c 01       	movw	r4, r24
    1012:	83 01       	movw	r16, r6
    1014:	2c 85       	ldd	r18, Y+12	; 0x0c
    1016:	2f 77       	andi	r18, 0x7F	; 127
    1018:	22 2e       	mov	r2, r18
    101a:	17 c0       	rjmp	.+46     	; 0x104a <vfprintf+0x192>
    101c:	38 01       	movw	r6, r16
    101e:	f2 e0       	ldi	r31, 0x02	; 2
    1020:	6f 0e       	add	r6, r31
    1022:	71 1c       	adc	r7, r1
    1024:	f8 01       	movw	r30, r16
    1026:	a0 80       	ld	r10, Z
    1028:	b1 80       	ldd	r11, Z+1	; 0x01
    102a:	26 ff       	sbrs	r18, 6
    102c:	03 c0       	rjmp	.+6      	; 0x1034 <vfprintf+0x17c>
    102e:	65 2d       	mov	r22, r5
    1030:	70 e0       	ldi	r23, 0x00	; 0
    1032:	02 c0       	rjmp	.+4      	; 0x1038 <vfprintf+0x180>
    1034:	6f ef       	ldi	r22, 0xFF	; 255
    1036:	7f ef       	ldi	r23, 0xFF	; 255
    1038:	c5 01       	movw	r24, r10
    103a:	2c 87       	std	Y+12, r18	; 0x0c
    103c:	0e 94 54 09 	call	0x12a8	; 0x12a8 <strnlen_P>
    1040:	2c 01       	movw	r4, r24
    1042:	2c 85       	ldd	r18, Y+12	; 0x0c
    1044:	20 68       	ori	r18, 0x80	; 128
    1046:	22 2e       	mov	r2, r18
    1048:	83 01       	movw	r16, r6
    104a:	23 fc       	sbrc	r2, 3
    104c:	1b c0       	rjmp	.+54     	; 0x1084 <vfprintf+0x1cc>
    104e:	83 2d       	mov	r24, r3
    1050:	90 e0       	ldi	r25, 0x00	; 0
    1052:	48 16       	cp	r4, r24
    1054:	59 06       	cpc	r5, r25
    1056:	b0 f4       	brcc	.+44     	; 0x1084 <vfprintf+0x1cc>
    1058:	b7 01       	movw	r22, r14
    105a:	80 e2       	ldi	r24, 0x20	; 32
    105c:	90 e0       	ldi	r25, 0x00	; 0
    105e:	0e 94 a8 09 	call	0x1350	; 0x1350 <fputc>
    1062:	3a 94       	dec	r3
    1064:	f4 cf       	rjmp	.-24     	; 0x104e <vfprintf+0x196>
    1066:	f5 01       	movw	r30, r10
    1068:	27 fc       	sbrc	r2, 7
    106a:	85 91       	lpm	r24, Z+
    106c:	27 fe       	sbrs	r2, 7
    106e:	81 91       	ld	r24, Z+
    1070:	5f 01       	movw	r10, r30
    1072:	b7 01       	movw	r22, r14
    1074:	90 e0       	ldi	r25, 0x00	; 0
    1076:	0e 94 a8 09 	call	0x1350	; 0x1350 <fputc>
    107a:	31 10       	cpse	r3, r1
    107c:	3a 94       	dec	r3
    107e:	f1 e0       	ldi	r31, 0x01	; 1
    1080:	4f 1a       	sub	r4, r31
    1082:	51 08       	sbc	r5, r1
    1084:	41 14       	cp	r4, r1
    1086:	51 04       	cpc	r5, r1
    1088:	71 f7       	brne	.-36     	; 0x1066 <vfprintf+0x1ae>
    108a:	e5 c0       	rjmp	.+458    	; 0x1256 <vfprintf+0x39e>
    108c:	84 36       	cpi	r24, 0x64	; 100
    108e:	11 f0       	breq	.+4      	; 0x1094 <vfprintf+0x1dc>
    1090:	89 36       	cpi	r24, 0x69	; 105
    1092:	39 f5       	brne	.+78     	; 0x10e2 <vfprintf+0x22a>
    1094:	f8 01       	movw	r30, r16
    1096:	27 ff       	sbrs	r18, 7
    1098:	07 c0       	rjmp	.+14     	; 0x10a8 <vfprintf+0x1f0>
    109a:	60 81       	ld	r22, Z
    109c:	71 81       	ldd	r23, Z+1	; 0x01
    109e:	82 81       	ldd	r24, Z+2	; 0x02
    10a0:	93 81       	ldd	r25, Z+3	; 0x03
    10a2:	0c 5f       	subi	r16, 0xFC	; 252
    10a4:	1f 4f       	sbci	r17, 0xFF	; 255
    10a6:	08 c0       	rjmp	.+16     	; 0x10b8 <vfprintf+0x200>
    10a8:	60 81       	ld	r22, Z
    10aa:	71 81       	ldd	r23, Z+1	; 0x01
    10ac:	07 2e       	mov	r0, r23
    10ae:	00 0c       	add	r0, r0
    10b0:	88 0b       	sbc	r24, r24
    10b2:	99 0b       	sbc	r25, r25
    10b4:	0e 5f       	subi	r16, 0xFE	; 254
    10b6:	1f 4f       	sbci	r17, 0xFF	; 255
    10b8:	2f 76       	andi	r18, 0x6F	; 111
    10ba:	72 2e       	mov	r7, r18
    10bc:	97 ff       	sbrs	r25, 7
    10be:	09 c0       	rjmp	.+18     	; 0x10d2 <vfprintf+0x21a>
    10c0:	90 95       	com	r25
    10c2:	80 95       	com	r24
    10c4:	70 95       	com	r23
    10c6:	61 95       	neg	r22
    10c8:	7f 4f       	sbci	r23, 0xFF	; 255
    10ca:	8f 4f       	sbci	r24, 0xFF	; 255
    10cc:	9f 4f       	sbci	r25, 0xFF	; 255
    10ce:	20 68       	ori	r18, 0x80	; 128
    10d0:	72 2e       	mov	r7, r18
    10d2:	2a e0       	ldi	r18, 0x0A	; 10
    10d4:	30 e0       	ldi	r19, 0x00	; 0
    10d6:	a4 01       	movw	r20, r8
    10d8:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <__ultoa_invert>
    10dc:	a8 2e       	mov	r10, r24
    10de:	a8 18       	sub	r10, r8
    10e0:	44 c0       	rjmp	.+136    	; 0x116a <vfprintf+0x2b2>
    10e2:	85 37       	cpi	r24, 0x75	; 117
    10e4:	29 f4       	brne	.+10     	; 0x10f0 <vfprintf+0x238>
    10e6:	2f 7e       	andi	r18, 0xEF	; 239
    10e8:	b2 2e       	mov	r11, r18
    10ea:	2a e0       	ldi	r18, 0x0A	; 10
    10ec:	30 e0       	ldi	r19, 0x00	; 0
    10ee:	25 c0       	rjmp	.+74     	; 0x113a <vfprintf+0x282>
    10f0:	f2 2f       	mov	r31, r18
    10f2:	f9 7f       	andi	r31, 0xF9	; 249
    10f4:	bf 2e       	mov	r11, r31
    10f6:	8f 36       	cpi	r24, 0x6F	; 111
    10f8:	c1 f0       	breq	.+48     	; 0x112a <vfprintf+0x272>
    10fa:	18 f4       	brcc	.+6      	; 0x1102 <vfprintf+0x24a>
    10fc:	88 35       	cpi	r24, 0x58	; 88
    10fe:	79 f0       	breq	.+30     	; 0x111e <vfprintf+0x266>
    1100:	b4 c0       	rjmp	.+360    	; 0x126a <vfprintf+0x3b2>
    1102:	80 37       	cpi	r24, 0x70	; 112
    1104:	19 f0       	breq	.+6      	; 0x110c <vfprintf+0x254>
    1106:	88 37       	cpi	r24, 0x78	; 120
    1108:	21 f0       	breq	.+8      	; 0x1112 <vfprintf+0x25a>
    110a:	af c0       	rjmp	.+350    	; 0x126a <vfprintf+0x3b2>
    110c:	2f 2f       	mov	r18, r31
    110e:	20 61       	ori	r18, 0x10	; 16
    1110:	b2 2e       	mov	r11, r18
    1112:	b4 fe       	sbrs	r11, 4
    1114:	0d c0       	rjmp	.+26     	; 0x1130 <vfprintf+0x278>
    1116:	8b 2d       	mov	r24, r11
    1118:	84 60       	ori	r24, 0x04	; 4
    111a:	b8 2e       	mov	r11, r24
    111c:	09 c0       	rjmp	.+18     	; 0x1130 <vfprintf+0x278>
    111e:	24 ff       	sbrs	r18, 4
    1120:	0a c0       	rjmp	.+20     	; 0x1136 <vfprintf+0x27e>
    1122:	9f 2f       	mov	r25, r31
    1124:	96 60       	ori	r25, 0x06	; 6
    1126:	b9 2e       	mov	r11, r25
    1128:	06 c0       	rjmp	.+12     	; 0x1136 <vfprintf+0x27e>
    112a:	28 e0       	ldi	r18, 0x08	; 8
    112c:	30 e0       	ldi	r19, 0x00	; 0
    112e:	05 c0       	rjmp	.+10     	; 0x113a <vfprintf+0x282>
    1130:	20 e1       	ldi	r18, 0x10	; 16
    1132:	30 e0       	ldi	r19, 0x00	; 0
    1134:	02 c0       	rjmp	.+4      	; 0x113a <vfprintf+0x282>
    1136:	20 e1       	ldi	r18, 0x10	; 16
    1138:	32 e0       	ldi	r19, 0x02	; 2
    113a:	f8 01       	movw	r30, r16
    113c:	b7 fe       	sbrs	r11, 7
    113e:	07 c0       	rjmp	.+14     	; 0x114e <vfprintf+0x296>
    1140:	60 81       	ld	r22, Z
    1142:	71 81       	ldd	r23, Z+1	; 0x01
    1144:	82 81       	ldd	r24, Z+2	; 0x02
    1146:	93 81       	ldd	r25, Z+3	; 0x03
    1148:	0c 5f       	subi	r16, 0xFC	; 252
    114a:	1f 4f       	sbci	r17, 0xFF	; 255
    114c:	06 c0       	rjmp	.+12     	; 0x115a <vfprintf+0x2a2>
    114e:	60 81       	ld	r22, Z
    1150:	71 81       	ldd	r23, Z+1	; 0x01
    1152:	80 e0       	ldi	r24, 0x00	; 0
    1154:	90 e0       	ldi	r25, 0x00	; 0
    1156:	0e 5f       	subi	r16, 0xFE	; 254
    1158:	1f 4f       	sbci	r17, 0xFF	; 255
    115a:	a4 01       	movw	r20, r8
    115c:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <__ultoa_invert>
    1160:	a8 2e       	mov	r10, r24
    1162:	a8 18       	sub	r10, r8
    1164:	fb 2d       	mov	r31, r11
    1166:	ff 77       	andi	r31, 0x7F	; 127
    1168:	7f 2e       	mov	r7, r31
    116a:	76 fe       	sbrs	r7, 6
    116c:	0b c0       	rjmp	.+22     	; 0x1184 <vfprintf+0x2cc>
    116e:	37 2d       	mov	r19, r7
    1170:	3e 7f       	andi	r19, 0xFE	; 254
    1172:	a5 14       	cp	r10, r5
    1174:	50 f4       	brcc	.+20     	; 0x118a <vfprintf+0x2d2>
    1176:	74 fe       	sbrs	r7, 4
    1178:	0a c0       	rjmp	.+20     	; 0x118e <vfprintf+0x2d6>
    117a:	72 fc       	sbrc	r7, 2
    117c:	08 c0       	rjmp	.+16     	; 0x118e <vfprintf+0x2d6>
    117e:	37 2d       	mov	r19, r7
    1180:	3e 7e       	andi	r19, 0xEE	; 238
    1182:	05 c0       	rjmp	.+10     	; 0x118e <vfprintf+0x2d6>
    1184:	ba 2c       	mov	r11, r10
    1186:	37 2d       	mov	r19, r7
    1188:	03 c0       	rjmp	.+6      	; 0x1190 <vfprintf+0x2d8>
    118a:	ba 2c       	mov	r11, r10
    118c:	01 c0       	rjmp	.+2      	; 0x1190 <vfprintf+0x2d8>
    118e:	b5 2c       	mov	r11, r5
    1190:	34 ff       	sbrs	r19, 4
    1192:	0d c0       	rjmp	.+26     	; 0x11ae <vfprintf+0x2f6>
    1194:	fe 01       	movw	r30, r28
    1196:	ea 0d       	add	r30, r10
    1198:	f1 1d       	adc	r31, r1
    119a:	80 81       	ld	r24, Z
    119c:	80 33       	cpi	r24, 0x30	; 48
    119e:	11 f4       	brne	.+4      	; 0x11a4 <vfprintf+0x2ec>
    11a0:	39 7e       	andi	r19, 0xE9	; 233
    11a2:	09 c0       	rjmp	.+18     	; 0x11b6 <vfprintf+0x2fe>
    11a4:	32 ff       	sbrs	r19, 2
    11a6:	06 c0       	rjmp	.+12     	; 0x11b4 <vfprintf+0x2fc>
    11a8:	b3 94       	inc	r11
    11aa:	b3 94       	inc	r11
    11ac:	04 c0       	rjmp	.+8      	; 0x11b6 <vfprintf+0x2fe>
    11ae:	83 2f       	mov	r24, r19
    11b0:	86 78       	andi	r24, 0x86	; 134
    11b2:	09 f0       	breq	.+2      	; 0x11b6 <vfprintf+0x2fe>
    11b4:	b3 94       	inc	r11
    11b6:	33 fd       	sbrc	r19, 3
    11b8:	13 c0       	rjmp	.+38     	; 0x11e0 <vfprintf+0x328>
    11ba:	30 ff       	sbrs	r19, 0
    11bc:	06 c0       	rjmp	.+12     	; 0x11ca <vfprintf+0x312>
    11be:	5a 2c       	mov	r5, r10
    11c0:	b3 14       	cp	r11, r3
    11c2:	18 f4       	brcc	.+6      	; 0x11ca <vfprintf+0x312>
    11c4:	53 0c       	add	r5, r3
    11c6:	5b 18       	sub	r5, r11
    11c8:	b3 2c       	mov	r11, r3
    11ca:	b3 14       	cp	r11, r3
    11cc:	68 f4       	brcc	.+26     	; 0x11e8 <vfprintf+0x330>
    11ce:	b7 01       	movw	r22, r14
    11d0:	80 e2       	ldi	r24, 0x20	; 32
    11d2:	90 e0       	ldi	r25, 0x00	; 0
    11d4:	3c 87       	std	Y+12, r19	; 0x0c
    11d6:	0e 94 a8 09 	call	0x1350	; 0x1350 <fputc>
    11da:	b3 94       	inc	r11
    11dc:	3c 85       	ldd	r19, Y+12	; 0x0c
    11de:	f5 cf       	rjmp	.-22     	; 0x11ca <vfprintf+0x312>
    11e0:	b3 14       	cp	r11, r3
    11e2:	10 f4       	brcc	.+4      	; 0x11e8 <vfprintf+0x330>
    11e4:	3b 18       	sub	r3, r11
    11e6:	01 c0       	rjmp	.+2      	; 0x11ea <vfprintf+0x332>
    11e8:	31 2c       	mov	r3, r1
    11ea:	34 ff       	sbrs	r19, 4
    11ec:	12 c0       	rjmp	.+36     	; 0x1212 <vfprintf+0x35a>
    11ee:	b7 01       	movw	r22, r14
    11f0:	80 e3       	ldi	r24, 0x30	; 48
    11f2:	90 e0       	ldi	r25, 0x00	; 0
    11f4:	3c 87       	std	Y+12, r19	; 0x0c
    11f6:	0e 94 a8 09 	call	0x1350	; 0x1350 <fputc>
    11fa:	3c 85       	ldd	r19, Y+12	; 0x0c
    11fc:	32 ff       	sbrs	r19, 2
    11fe:	17 c0       	rjmp	.+46     	; 0x122e <vfprintf+0x376>
    1200:	31 fd       	sbrc	r19, 1
    1202:	03 c0       	rjmp	.+6      	; 0x120a <vfprintf+0x352>
    1204:	88 e7       	ldi	r24, 0x78	; 120
    1206:	90 e0       	ldi	r25, 0x00	; 0
    1208:	02 c0       	rjmp	.+4      	; 0x120e <vfprintf+0x356>
    120a:	88 e5       	ldi	r24, 0x58	; 88
    120c:	90 e0       	ldi	r25, 0x00	; 0
    120e:	b7 01       	movw	r22, r14
    1210:	0c c0       	rjmp	.+24     	; 0x122a <vfprintf+0x372>
    1212:	83 2f       	mov	r24, r19
    1214:	86 78       	andi	r24, 0x86	; 134
    1216:	59 f0       	breq	.+22     	; 0x122e <vfprintf+0x376>
    1218:	31 ff       	sbrs	r19, 1
    121a:	02 c0       	rjmp	.+4      	; 0x1220 <vfprintf+0x368>
    121c:	8b e2       	ldi	r24, 0x2B	; 43
    121e:	01 c0       	rjmp	.+2      	; 0x1222 <vfprintf+0x36a>
    1220:	80 e2       	ldi	r24, 0x20	; 32
    1222:	37 fd       	sbrc	r19, 7
    1224:	8d e2       	ldi	r24, 0x2D	; 45
    1226:	b7 01       	movw	r22, r14
    1228:	90 e0       	ldi	r25, 0x00	; 0
    122a:	0e 94 a8 09 	call	0x1350	; 0x1350 <fputc>
    122e:	a5 14       	cp	r10, r5
    1230:	38 f4       	brcc	.+14     	; 0x1240 <vfprintf+0x388>
    1232:	b7 01       	movw	r22, r14
    1234:	80 e3       	ldi	r24, 0x30	; 48
    1236:	90 e0       	ldi	r25, 0x00	; 0
    1238:	0e 94 a8 09 	call	0x1350	; 0x1350 <fputc>
    123c:	5a 94       	dec	r5
    123e:	f7 cf       	rjmp	.-18     	; 0x122e <vfprintf+0x376>
    1240:	aa 94       	dec	r10
    1242:	f4 01       	movw	r30, r8
    1244:	ea 0d       	add	r30, r10
    1246:	f1 1d       	adc	r31, r1
    1248:	80 81       	ld	r24, Z
    124a:	b7 01       	movw	r22, r14
    124c:	90 e0       	ldi	r25, 0x00	; 0
    124e:	0e 94 a8 09 	call	0x1350	; 0x1350 <fputc>
    1252:	a1 10       	cpse	r10, r1
    1254:	f5 cf       	rjmp	.-22     	; 0x1240 <vfprintf+0x388>
    1256:	33 20       	and	r3, r3
    1258:	09 f4       	brne	.+2      	; 0x125c <vfprintf+0x3a4>
    125a:	51 ce       	rjmp	.-862    	; 0xefe <vfprintf+0x46>
    125c:	b7 01       	movw	r22, r14
    125e:	80 e2       	ldi	r24, 0x20	; 32
    1260:	90 e0       	ldi	r25, 0x00	; 0
    1262:	0e 94 a8 09 	call	0x1350	; 0x1350 <fputc>
    1266:	3a 94       	dec	r3
    1268:	f6 cf       	rjmp	.-20     	; 0x1256 <vfprintf+0x39e>
    126a:	f7 01       	movw	r30, r14
    126c:	86 81       	ldd	r24, Z+6	; 0x06
    126e:	97 81       	ldd	r25, Z+7	; 0x07
    1270:	02 c0       	rjmp	.+4      	; 0x1276 <vfprintf+0x3be>
    1272:	8f ef       	ldi	r24, 0xFF	; 255
    1274:	9f ef       	ldi	r25, 0xFF	; 255
    1276:	2c 96       	adiw	r28, 0x0c	; 12
    1278:	cd bf       	out	0x3d, r28	; 61
    127a:	de bf       	out	0x3e, r29	; 62
    127c:	df 91       	pop	r29
    127e:	cf 91       	pop	r28
    1280:	1f 91       	pop	r17
    1282:	0f 91       	pop	r16
    1284:	ff 90       	pop	r15
    1286:	ef 90       	pop	r14
    1288:	df 90       	pop	r13
    128a:	cf 90       	pop	r12
    128c:	bf 90       	pop	r11
    128e:	af 90       	pop	r10
    1290:	9f 90       	pop	r9
    1292:	8f 90       	pop	r8
    1294:	7f 90       	pop	r7
    1296:	6f 90       	pop	r6
    1298:	5f 90       	pop	r5
    129a:	4f 90       	pop	r4
    129c:	3f 90       	pop	r3
    129e:	2f 90       	pop	r2
    12a0:	08 95       	ret

000012a2 <__ctype_isfalse>:
    12a2:	99 27       	eor	r25, r25
    12a4:	88 27       	eor	r24, r24

000012a6 <__ctype_istrue>:
    12a6:	08 95       	ret

000012a8 <strnlen_P>:
    12a8:	fc 01       	movw	r30, r24
    12aa:	05 90       	lpm	r0, Z+
    12ac:	61 50       	subi	r22, 0x01	; 1
    12ae:	70 40       	sbci	r23, 0x00	; 0
    12b0:	01 10       	cpse	r0, r1
    12b2:	d8 f7       	brcc	.-10     	; 0x12aa <strnlen_P+0x2>
    12b4:	80 95       	com	r24
    12b6:	90 95       	com	r25
    12b8:	8e 0f       	add	r24, r30
    12ba:	9f 1f       	adc	r25, r31
    12bc:	08 95       	ret

000012be <strnlen>:
    12be:	fc 01       	movw	r30, r24
    12c0:	61 50       	subi	r22, 0x01	; 1
    12c2:	70 40       	sbci	r23, 0x00	; 0
    12c4:	01 90       	ld	r0, Z+
    12c6:	01 10       	cpse	r0, r1
    12c8:	d8 f7       	brcc	.-10     	; 0x12c0 <strnlen+0x2>
    12ca:	80 95       	com	r24
    12cc:	90 95       	com	r25
    12ce:	8e 0f       	add	r24, r30
    12d0:	9f 1f       	adc	r25, r31
    12d2:	08 95       	ret

000012d4 <fgetc>:
    12d4:	cf 93       	push	r28
    12d6:	df 93       	push	r29
    12d8:	ec 01       	movw	r28, r24
    12da:	2b 81       	ldd	r18, Y+3	; 0x03
    12dc:	20 ff       	sbrs	r18, 0
    12de:	33 c0       	rjmp	.+102    	; 0x1346 <fgetc+0x72>
    12e0:	26 ff       	sbrs	r18, 6
    12e2:	0a c0       	rjmp	.+20     	; 0x12f8 <fgetc+0x24>
    12e4:	2f 7b       	andi	r18, 0xBF	; 191
    12e6:	2b 83       	std	Y+3, r18	; 0x03
    12e8:	8e 81       	ldd	r24, Y+6	; 0x06
    12ea:	9f 81       	ldd	r25, Y+7	; 0x07
    12ec:	01 96       	adiw	r24, 0x01	; 1
    12ee:	8e 83       	std	Y+6, r24	; 0x06
    12f0:	9f 83       	std	Y+7, r25	; 0x07
    12f2:	8a 81       	ldd	r24, Y+2	; 0x02
    12f4:	90 e0       	ldi	r25, 0x00	; 0
    12f6:	29 c0       	rjmp	.+82     	; 0x134a <fgetc+0x76>
    12f8:	22 ff       	sbrs	r18, 2
    12fa:	0f c0       	rjmp	.+30     	; 0x131a <fgetc+0x46>
    12fc:	e8 81       	ld	r30, Y
    12fe:	f9 81       	ldd	r31, Y+1	; 0x01
    1300:	80 81       	ld	r24, Z
    1302:	08 2e       	mov	r0, r24
    1304:	00 0c       	add	r0, r0
    1306:	99 0b       	sbc	r25, r25
    1308:	00 97       	sbiw	r24, 0x00	; 0
    130a:	19 f4       	brne	.+6      	; 0x1312 <fgetc+0x3e>
    130c:	20 62       	ori	r18, 0x20	; 32
    130e:	2b 83       	std	Y+3, r18	; 0x03
    1310:	1a c0       	rjmp	.+52     	; 0x1346 <fgetc+0x72>
    1312:	31 96       	adiw	r30, 0x01	; 1
    1314:	e8 83       	st	Y, r30
    1316:	f9 83       	std	Y+1, r31	; 0x01
    1318:	0e c0       	rjmp	.+28     	; 0x1336 <fgetc+0x62>
    131a:	ea 85       	ldd	r30, Y+10	; 0x0a
    131c:	fb 85       	ldd	r31, Y+11	; 0x0b
    131e:	19 95       	eicall
    1320:	97 ff       	sbrs	r25, 7
    1322:	09 c0       	rjmp	.+18     	; 0x1336 <fgetc+0x62>
    1324:	2b 81       	ldd	r18, Y+3	; 0x03
    1326:	01 96       	adiw	r24, 0x01	; 1
    1328:	11 f0       	breq	.+4      	; 0x132e <fgetc+0x5a>
    132a:	80 e2       	ldi	r24, 0x20	; 32
    132c:	01 c0       	rjmp	.+2      	; 0x1330 <fgetc+0x5c>
    132e:	80 e1       	ldi	r24, 0x10	; 16
    1330:	82 2b       	or	r24, r18
    1332:	8b 83       	std	Y+3, r24	; 0x03
    1334:	08 c0       	rjmp	.+16     	; 0x1346 <fgetc+0x72>
    1336:	2e 81       	ldd	r18, Y+6	; 0x06
    1338:	3f 81       	ldd	r19, Y+7	; 0x07
    133a:	2f 5f       	subi	r18, 0xFF	; 255
    133c:	3f 4f       	sbci	r19, 0xFF	; 255
    133e:	2e 83       	std	Y+6, r18	; 0x06
    1340:	3f 83       	std	Y+7, r19	; 0x07
    1342:	99 27       	eor	r25, r25
    1344:	02 c0       	rjmp	.+4      	; 0x134a <fgetc+0x76>
    1346:	8f ef       	ldi	r24, 0xFF	; 255
    1348:	9f ef       	ldi	r25, 0xFF	; 255
    134a:	df 91       	pop	r29
    134c:	cf 91       	pop	r28
    134e:	08 95       	ret

00001350 <fputc>:
    1350:	0f 93       	push	r16
    1352:	1f 93       	push	r17
    1354:	cf 93       	push	r28
    1356:	df 93       	push	r29
    1358:	fb 01       	movw	r30, r22
    135a:	23 81       	ldd	r18, Z+3	; 0x03
    135c:	21 fd       	sbrc	r18, 1
    135e:	03 c0       	rjmp	.+6      	; 0x1366 <fputc+0x16>
    1360:	8f ef       	ldi	r24, 0xFF	; 255
    1362:	9f ef       	ldi	r25, 0xFF	; 255
    1364:	28 c0       	rjmp	.+80     	; 0x13b6 <fputc+0x66>
    1366:	22 ff       	sbrs	r18, 2
    1368:	16 c0       	rjmp	.+44     	; 0x1396 <fputc+0x46>
    136a:	46 81       	ldd	r20, Z+6	; 0x06
    136c:	57 81       	ldd	r21, Z+7	; 0x07
    136e:	24 81       	ldd	r18, Z+4	; 0x04
    1370:	35 81       	ldd	r19, Z+5	; 0x05
    1372:	42 17       	cp	r20, r18
    1374:	53 07       	cpc	r21, r19
    1376:	44 f4       	brge	.+16     	; 0x1388 <fputc+0x38>
    1378:	a0 81       	ld	r26, Z
    137a:	b1 81       	ldd	r27, Z+1	; 0x01
    137c:	9d 01       	movw	r18, r26
    137e:	2f 5f       	subi	r18, 0xFF	; 255
    1380:	3f 4f       	sbci	r19, 0xFF	; 255
    1382:	20 83       	st	Z, r18
    1384:	31 83       	std	Z+1, r19	; 0x01
    1386:	8c 93       	st	X, r24
    1388:	26 81       	ldd	r18, Z+6	; 0x06
    138a:	37 81       	ldd	r19, Z+7	; 0x07
    138c:	2f 5f       	subi	r18, 0xFF	; 255
    138e:	3f 4f       	sbci	r19, 0xFF	; 255
    1390:	26 83       	std	Z+6, r18	; 0x06
    1392:	37 83       	std	Z+7, r19	; 0x07
    1394:	10 c0       	rjmp	.+32     	; 0x13b6 <fputc+0x66>
    1396:	eb 01       	movw	r28, r22
    1398:	09 2f       	mov	r16, r25
    139a:	18 2f       	mov	r17, r24
    139c:	00 84       	ldd	r0, Z+8	; 0x08
    139e:	f1 85       	ldd	r31, Z+9	; 0x09
    13a0:	e0 2d       	mov	r30, r0
    13a2:	19 95       	eicall
    13a4:	89 2b       	or	r24, r25
    13a6:	e1 f6       	brne	.-72     	; 0x1360 <fputc+0x10>
    13a8:	8e 81       	ldd	r24, Y+6	; 0x06
    13aa:	9f 81       	ldd	r25, Y+7	; 0x07
    13ac:	01 96       	adiw	r24, 0x01	; 1
    13ae:	8e 83       	std	Y+6, r24	; 0x06
    13b0:	9f 83       	std	Y+7, r25	; 0x07
    13b2:	81 2f       	mov	r24, r17
    13b4:	90 2f       	mov	r25, r16
    13b6:	df 91       	pop	r29
    13b8:	cf 91       	pop	r28
    13ba:	1f 91       	pop	r17
    13bc:	0f 91       	pop	r16
    13be:	08 95       	ret

000013c0 <__ultoa_invert>:
    13c0:	fa 01       	movw	r30, r20
    13c2:	aa 27       	eor	r26, r26
    13c4:	28 30       	cpi	r18, 0x08	; 8
    13c6:	51 f1       	breq	.+84     	; 0x141c <__ultoa_invert+0x5c>
    13c8:	20 31       	cpi	r18, 0x10	; 16
    13ca:	81 f1       	breq	.+96     	; 0x142c <__ultoa_invert+0x6c>
    13cc:	e8 94       	clt
    13ce:	6f 93       	push	r22
    13d0:	6e 7f       	andi	r22, 0xFE	; 254
    13d2:	6e 5f       	subi	r22, 0xFE	; 254
    13d4:	7f 4f       	sbci	r23, 0xFF	; 255
    13d6:	8f 4f       	sbci	r24, 0xFF	; 255
    13d8:	9f 4f       	sbci	r25, 0xFF	; 255
    13da:	af 4f       	sbci	r26, 0xFF	; 255
    13dc:	b1 e0       	ldi	r27, 0x01	; 1
    13de:	3e d0       	rcall	.+124    	; 0x145c <__ultoa_invert+0x9c>
    13e0:	b4 e0       	ldi	r27, 0x04	; 4
    13e2:	3c d0       	rcall	.+120    	; 0x145c <__ultoa_invert+0x9c>
    13e4:	67 0f       	add	r22, r23
    13e6:	78 1f       	adc	r23, r24
    13e8:	89 1f       	adc	r24, r25
    13ea:	9a 1f       	adc	r25, r26
    13ec:	a1 1d       	adc	r26, r1
    13ee:	68 0f       	add	r22, r24
    13f0:	79 1f       	adc	r23, r25
    13f2:	8a 1f       	adc	r24, r26
    13f4:	91 1d       	adc	r25, r1
    13f6:	a1 1d       	adc	r26, r1
    13f8:	6a 0f       	add	r22, r26
    13fa:	71 1d       	adc	r23, r1
    13fc:	81 1d       	adc	r24, r1
    13fe:	91 1d       	adc	r25, r1
    1400:	a1 1d       	adc	r26, r1
    1402:	20 d0       	rcall	.+64     	; 0x1444 <__ultoa_invert+0x84>
    1404:	09 f4       	brne	.+2      	; 0x1408 <__ultoa_invert+0x48>
    1406:	68 94       	set
    1408:	3f 91       	pop	r19
    140a:	2a e0       	ldi	r18, 0x0A	; 10
    140c:	26 9f       	mul	r18, r22
    140e:	11 24       	eor	r1, r1
    1410:	30 19       	sub	r19, r0
    1412:	30 5d       	subi	r19, 0xD0	; 208
    1414:	31 93       	st	Z+, r19
    1416:	de f6       	brtc	.-74     	; 0x13ce <__ultoa_invert+0xe>
    1418:	cf 01       	movw	r24, r30
    141a:	08 95       	ret
    141c:	46 2f       	mov	r20, r22
    141e:	47 70       	andi	r20, 0x07	; 7
    1420:	40 5d       	subi	r20, 0xD0	; 208
    1422:	41 93       	st	Z+, r20
    1424:	b3 e0       	ldi	r27, 0x03	; 3
    1426:	0f d0       	rcall	.+30     	; 0x1446 <__ultoa_invert+0x86>
    1428:	c9 f7       	brne	.-14     	; 0x141c <__ultoa_invert+0x5c>
    142a:	f6 cf       	rjmp	.-20     	; 0x1418 <__ultoa_invert+0x58>
    142c:	46 2f       	mov	r20, r22
    142e:	4f 70       	andi	r20, 0x0F	; 15
    1430:	40 5d       	subi	r20, 0xD0	; 208
    1432:	4a 33       	cpi	r20, 0x3A	; 58
    1434:	18 f0       	brcs	.+6      	; 0x143c <__ultoa_invert+0x7c>
    1436:	49 5d       	subi	r20, 0xD9	; 217
    1438:	31 fd       	sbrc	r19, 1
    143a:	40 52       	subi	r20, 0x20	; 32
    143c:	41 93       	st	Z+, r20
    143e:	02 d0       	rcall	.+4      	; 0x1444 <__ultoa_invert+0x84>
    1440:	a9 f7       	brne	.-22     	; 0x142c <__ultoa_invert+0x6c>
    1442:	ea cf       	rjmp	.-44     	; 0x1418 <__ultoa_invert+0x58>
    1444:	b4 e0       	ldi	r27, 0x04	; 4
    1446:	a6 95       	lsr	r26
    1448:	97 95       	ror	r25
    144a:	87 95       	ror	r24
    144c:	77 95       	ror	r23
    144e:	67 95       	ror	r22
    1450:	ba 95       	dec	r27
    1452:	c9 f7       	brne	.-14     	; 0x1446 <__ultoa_invert+0x86>
    1454:	00 97       	sbiw	r24, 0x00	; 0
    1456:	61 05       	cpc	r22, r1
    1458:	71 05       	cpc	r23, r1
    145a:	08 95       	ret
    145c:	9b 01       	movw	r18, r22
    145e:	ac 01       	movw	r20, r24
    1460:	0a 2e       	mov	r0, r26
    1462:	06 94       	lsr	r0
    1464:	57 95       	ror	r21
    1466:	47 95       	ror	r20
    1468:	37 95       	ror	r19
    146a:	27 95       	ror	r18
    146c:	ba 95       	dec	r27
    146e:	c9 f7       	brne	.-14     	; 0x1462 <__ultoa_invert+0xa2>
    1470:	62 0f       	add	r22, r18
    1472:	73 1f       	adc	r23, r19
    1474:	84 1f       	adc	r24, r20
    1476:	95 1f       	adc	r25, r21
    1478:	a0 1d       	adc	r26, r0
    147a:	08 95       	ret

0000147c <__mulsi3>:
    147c:	db 01       	movw	r26, r22
    147e:	8f 93       	push	r24
    1480:	9f 93       	push	r25
    1482:	0e 94 7e 05 	call	0xafc	; 0xafc <__muluhisi3>
    1486:	bf 91       	pop	r27
    1488:	af 91       	pop	r26
    148a:	a2 9f       	mul	r26, r18
    148c:	80 0d       	add	r24, r0
    148e:	91 1d       	adc	r25, r1
    1490:	a3 9f       	mul	r26, r19
    1492:	90 0d       	add	r25, r0
    1494:	b2 9f       	mul	r27, r18
    1496:	90 0d       	add	r25, r0
    1498:	11 24       	eor	r1, r1
    149a:	08 95       	ret

0000149c <_exit>:
    149c:	f8 94       	cli

0000149e <__stop_program>:
    149e:	ff cf       	rjmp	.-2      	; 0x149e <__stop_program>
