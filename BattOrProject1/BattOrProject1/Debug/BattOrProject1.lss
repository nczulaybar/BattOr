
BattOrProject1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000404  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00802000  00802000  00000478  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000014  00802000  00802000  00000478  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000478  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000004a8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000080  00000000  00000000  000004e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000010fa  00000000  00000000  00000568  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000002a2  00000000  00000000  00001662  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000028d  00000000  00000000  00001904  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000134  00000000  00000000  00001b94  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006da  00000000  00000000  00001cc8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000004c4  00000000  00000000  000023a2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000070  00000000  00000000  00002866  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
   8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
   c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  10:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  14:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  18:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  1c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  20:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  24:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  28:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  2c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  30:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  34:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  38:	0c 94 54 01 	jmp	0x2a8	; 0x2a8 <__vector_14>
  3c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  40:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  44:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  48:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  4c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  50:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  54:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  58:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  5c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  60:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  64:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  68:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  6c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  70:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  74:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  78:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  7c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  80:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  84:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  88:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  8c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  90:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  94:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  98:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  9c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  a0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  a4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  a8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  ac:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  b0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  b4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  b8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  bc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  c0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  c4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  c8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  cc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  d0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  d4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  d8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  dc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  e0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  e4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  e8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  ec:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  f0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  f4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  f8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
  fc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 100:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 104:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 108:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 10c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 110:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 114:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 118:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 11c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 120:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 124:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 128:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 12c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 130:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 134:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 138:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 13c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 140:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 144:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 148:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 14c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 150:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 154:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 158:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 15c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 160:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 164:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 168:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 16c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 170:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 174:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 178:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 17c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 180:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 184:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 188:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 18c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 190:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 194:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 198:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 19c:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1a0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1a4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1a8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1ac:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1b0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1b4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1b8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1bc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1c0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1c4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1c8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1cc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1d0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1d4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1d8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1dc:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1e0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1e4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1e8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1ec:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1f0:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1f4:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>
 1f8:	0c 94 12 01 	jmp	0x224	; 0x224 <__bad_interrupt>

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e5       	ldi	r29, 0x5F	; 95
 206:	de bf       	out	0x3e, r29	; 62
 208:	00 e0       	ldi	r16, 0x00	; 0
 20a:	0c bf       	out	0x3c, r16	; 60

0000020c <__do_clear_bss>:
 20c:	20 e2       	ldi	r18, 0x20	; 32
 20e:	a0 e0       	ldi	r26, 0x00	; 0
 210:	b0 e2       	ldi	r27, 0x20	; 32
 212:	01 c0       	rjmp	.+2      	; 0x216 <.do_clear_bss_start>

00000214 <.do_clear_bss_loop>:
 214:	1d 92       	st	X+, r1

00000216 <.do_clear_bss_start>:
 216:	a4 31       	cpi	r26, 0x14	; 20
 218:	b2 07       	cpc	r27, r18
 21a:	e1 f7       	brne	.-8      	; 0x214 <.do_clear_bss_loop>
 21c:	0e 94 e5 01 	call	0x3ca	; 0x3ca <main>
 220:	0c 94 00 02 	jmp	0x400	; 0x400 <_exit>

00000224 <__bad_interrupt>:
 224:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000228 <led_off>:
  port->DIR =  setBit(port->DIR, pin, out_or_in);
}

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
  if(getBit(port->DIR, pin))
 228:	90 91 40 06 	lds	r25, 0x0640
  }
}

//returns value of bit at a specified position in a specified uint8_t
inline uint8_t getBit(uint8_t target, uint8_t requestedBit){
  return (target & requestedBit);
 22c:	98 23       	and	r25, r24
  port->DIR =  setBit(port->DIR, pin, out_or_in);
}

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
  if(getBit(port->DIR, pin))
 22e:	29 f0       	breq	.+10     	; 0x23a <led_off+0x12>
    port->OUT = setBit(port->OUT, pin, on_or_off);
 230:	e0 e4       	ldi	r30, 0x40	; 64
 232:	f6 e0       	ldi	r31, 0x06	; 6
 234:	94 81       	ldd	r25, Z+4	; 0x04
}

//sets value of bit at a specified position in a specified uint8_t and returns changed uint8_t
inline uint8_t setBit(uint8_t target, uint8_t requestedBit, uint8_t requestedValue){
	uint8_t setValue = (requestedValue == 0) ? requestedBit : 0;
  return (target | requestedBit) & (0b11111111 ^ setValue); //could we do ~setValue
 236:	89 2b       	or	r24, r25
}

//If the specified pin on the specified port is in output mode, set the output of that pin to be on (1) or off (0).
inline void gpio_set_out(PORT_t* port, uint8_t pin, uint8_t on_or_off){
  if(getBit(port->DIR, pin))
    port->OUT = setBit(port->OUT, pin, on_or_off);
 238:	84 83       	std	Z+4, r24	; 0x04
 23a:	08 95       	ret

0000023c <led_init>:
//Set the specified pin on the specified port to be in output (1) or input (0) mode.
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in){
  port->DIR =  setBit(port->DIR, pin, out_or_in);
 23c:	e0 e4       	ldi	r30, 0x40	; 64
 23e:	f6 e0       	ldi	r31, 0x06	; 6
 240:	80 81       	ld	r24, Z
}

//sets value of bit at a specified position in a specified uint8_t and returns changed uint8_t
inline uint8_t setBit(uint8_t target, uint8_t requestedBit, uint8_t requestedValue){
	uint8_t setValue = (requestedValue == 0) ? requestedBit : 0;
  return (target | requestedBit) & (0b11111111 ^ setValue); //could we do ~setValue
 242:	81 60       	ori	r24, 0x01	; 1
//Set the specified pin on the specified port to be in output (1) or input (0) mode.
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in){
  port->DIR =  setBit(port->DIR, pin, out_or_in);
 244:	80 83       	st	Z, r24
 246:	80 81       	ld	r24, Z
}

//sets value of bit at a specified position in a specified uint8_t and returns changed uint8_t
inline uint8_t setBit(uint8_t target, uint8_t requestedBit, uint8_t requestedValue){
	uint8_t setValue = (requestedValue == 0) ? requestedBit : 0;
  return (target | requestedBit) & (0b11111111 ^ setValue); //could we do ~setValue
 248:	82 60       	ori	r24, 0x02	; 2
//Set the specified pin on the specified port to be in output (1) or input (0) mode.
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in){
  port->DIR =  setBit(port->DIR, pin, out_or_in);
 24a:	80 83       	st	Z, r24
 24c:	80 81       	ld	r24, Z
}

//sets value of bit at a specified position in a specified uint8_t and returns changed uint8_t
inline uint8_t setBit(uint8_t target, uint8_t requestedBit, uint8_t requestedValue){
	uint8_t setValue = (requestedValue == 0) ? requestedBit : 0;
  return (target | requestedBit) & (0b11111111 ^ setValue); //could we do ~setValue
 24e:	84 60       	ori	r24, 0x04	; 4
//Set the specified pin on the specified port to be in output (1) or input (0) mode.
void gpio_set_mode(PORT_t* port, uint8_t pin, uint8_t out_or_in){
  port->DIR =  setBit(port->DIR, pin, out_or_in);
 250:	80 83       	st	Z, r24
//Setup all of the LEDs so they are in output mode and off.
void led_init(){
	gpio_set_mode(&PORTC, LED_GREEN_bm, 1);
	gpio_set_mode(&PORTC, LED_YELLOW_bm, 1);
	gpio_set_mode(&PORTC, LED_RED_bm, 1);
	led_off(LED_GREEN_bm);
 252:	81 e0       	ldi	r24, 0x01	; 1
 254:	0e 94 14 01 	call	0x228	; 0x228 <led_off>
	led_off(LED_YELLOW_bm);
 258:	82 e0       	ldi	r24, 0x02	; 2
 25a:	0e 94 14 01 	call	0x228	; 0x228 <led_off>
	led_off(LED_RED_bm);
 25e:	84 e0       	ldi	r24, 0x04	; 4
 260:	0e 94 14 01 	call	0x228	; 0x228 <led_off>
 264:	08 95       	ret

00000266 <led_toggle>:
    port->OUT = setBit(port->OUT, pin, on_or_off);
}

//If the specified pin on the specified port is in output mode, toggle the pin’s state (if 1 then 0, if 0 then 1).
inline void gpio_toggle_out(PORT_t* port, uint8_t pin){
  if(getBit(port->DIR, pin)) {
 266:	90 91 40 06 	lds	r25, 0x0640
  }
}

//returns value of bit at a specified position in a specified uint8_t
inline uint8_t getBit(uint8_t target, uint8_t requestedBit){
  return (target & requestedBit);
 26a:	98 23       	and	r25, r24
    port->OUT = setBit(port->OUT, pin, on_or_off);
}

//If the specified pin on the specified port is in output mode, toggle the pin’s state (if 1 then 0, if 0 then 1).
inline void gpio_toggle_out(PORT_t* port, uint8_t pin){
  if(getBit(port->DIR, pin)) {
 26c:	71 f0       	breq	.+28     	; 0x28a <led_toggle+0x24>
    port->OUT = setBit(port->OUT, pin, !getBit(port->OUT, pin));
 26e:	e0 e4       	ldi	r30, 0x40	; 64
 270:	f6 e0       	ldi	r31, 0x06	; 6
 272:	24 81       	ldd	r18, Z+4	; 0x04
 274:	94 81       	ldd	r25, Z+4	; 0x04
  }
}

//returns value of bit at a specified position in a specified uint8_t
inline uint8_t getBit(uint8_t target, uint8_t requestedBit){
  return (target & requestedBit);
 276:	28 23       	and	r18, r24
}

//sets value of bit at a specified position in a specified uint8_t and returns changed uint8_t
inline uint8_t setBit(uint8_t target, uint8_t requestedBit, uint8_t requestedValue){
	uint8_t setValue = (requestedValue == 0) ? requestedBit : 0;
 278:	11 f0       	breq	.+4      	; 0x27e <led_toggle+0x18>
 27a:	28 2f       	mov	r18, r24
 27c:	01 c0       	rjmp	.+2      	; 0x280 <led_toggle+0x1a>
 27e:	20 e0       	ldi	r18, 0x00	; 0
  return (target | requestedBit) & (0b11111111 ^ setValue); //could we do ~setValue
 280:	20 95       	com	r18
 282:	89 2b       	or	r24, r25
 284:	82 23       	and	r24, r18
}

//If the specified pin on the specified port is in output mode, toggle the pin’s state (if 1 then 0, if 0 then 1).
inline void gpio_toggle_out(PORT_t* port, uint8_t pin){
  if(getBit(port->DIR, pin)) {
    port->OUT = setBit(port->OUT, pin, !getBit(port->OUT, pin));
 286:	80 93 44 06 	sts	0x0644, r24
 28a:	08 95       	ret

0000028c <blink_init>:
//Setup the specified timer peripheral. Clear out any timer state and reset all counters. Set it to have the specified interrupt_level.
void timer_init(TC0_t* timer, uint8_t int_level){
	timer->CTRLFSET = timer->CTRLFSET | 0b1000; //Executes reset command on CTRLFSet, see p179
 28c:	e0 e0       	ldi	r30, 0x00	; 0
 28e:	f8 e0       	ldi	r31, 0x08	; 8
 290:	81 85       	ldd	r24, Z+9	; 0x09
 292:	88 60       	ori	r24, 0x08	; 8
 294:	81 87       	std	Z+9, r24	; 0x09
	timer->INTCTRLA = 0b11 & int_level; //Enables overflow interrupt. Sets to high. See p134.
 296:	83 e0       	ldi	r24, 0x03	; 3
 298:	86 83       	std	Z+6, r24	; 0x06
	setBit(timer->CTRLFSET, 0b1000, 1); //Executes restart command on CTRLFSet, see p179
}

//Takes in period as time in microseconds between every overflow interrupt.
void timer_set(TC0_t* timer, uint8_t prescaler, uint16_t period){
	timer->CTRLA = (0b00000111 & prescaler); //Set prescaler by setting lower 3 bits of CLKSel;
 29a:	81 e0       	ldi	r24, 0x01	; 1
 29c:	80 83       	st	Z, r24
	timer->PER = period;
 29e:	8a ef       	ldi	r24, 0xFA	; 250
 2a0:	90 e0       	ldi	r25, 0x00	; 0
 2a2:	86 a3       	std	Z+38, r24	; 0x26
 2a4:	97 a3       	std	Z+39, r25	; 0x27
 2a6:	08 95       	ret

000002a8 <__vector_14>:
	//Disable blinks
	timer_init(&TCC0, 0b11);
	timer_set(&TCC0, 0b1, 250); //250 ticks corresponds to 1ms, thanks to the 2MHz peripheral clock
}

ISR(TCC0_OVF_vect){
 2a8:	1f 92       	push	r1
 2aa:	0f 92       	push	r0
 2ac:	0f b6       	in	r0, 0x3f	; 63
 2ae:	0f 92       	push	r0
 2b0:	11 24       	eor	r1, r1
 2b2:	8f 93       	push	r24
 2b4:	9f 93       	push	r25
 2b6:	af 93       	push	r26
 2b8:	bf 93       	push	r27
	globalTime++;
 2ba:	80 91 0c 20 	lds	r24, 0x200C
 2be:	90 91 0d 20 	lds	r25, 0x200D
 2c2:	a0 91 0e 20 	lds	r26, 0x200E
 2c6:	b0 91 0f 20 	lds	r27, 0x200F
 2ca:	01 96       	adiw	r24, 0x01	; 1
 2cc:	a1 1d       	adc	r26, r1
 2ce:	b1 1d       	adc	r27, r1
 2d0:	80 93 0c 20 	sts	0x200C, r24
 2d4:	90 93 0d 20 	sts	0x200D, r25
 2d8:	a0 93 0e 20 	sts	0x200E, r26
 2dc:	b0 93 0f 20 	sts	0x200F, r27
}
 2e0:	bf 91       	pop	r27
 2e2:	af 91       	pop	r26
 2e4:	9f 91       	pop	r25
 2e6:	8f 91       	pop	r24
 2e8:	0f 90       	pop	r0
 2ea:	0f be       	out	0x3f, r0	; 63
 2ec:	0f 90       	pop	r0
 2ee:	1f 90       	pop	r1
 2f0:	18 95       	reti

000002f2 <blink_ms_timer_update>:
void blink_set(uint8_t led, uint16_t interval_ms){
	LEDArray[led].blinkInterval = interval_ms;
}

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
 2f2:	8f 92       	push	r8
 2f4:	9f 92       	push	r9
 2f6:	af 92       	push	r10
 2f8:	bf 92       	push	r11
 2fa:	ff 92       	push	r15
 2fc:	0f 93       	push	r16
 2fe:	1f 93       	push	r17
 300:	cf 93       	push	r28
 302:	df 93       	push	r29
 304:	c0 e0       	ldi	r28, 0x00	; 0
 306:	d0 e2       	ldi	r29, 0x20	; 32
 308:	00 e0       	ldi	r16, 0x00	; 0
 30a:	10 e0       	ldi	r17, 0x00	; 0
				LEDArray[i].counter += (globalTime - lastTime); 
				}
			lastTime = globalTime;
			if (LEDArray[i].counter >= LEDArray[i].blinkInterval) {
				LEDArray[i].counter = 0;
				led_toggle(0b1 << (i));
 30c:	ff 24       	eor	r15, r15
 30e:	f3 94       	inc	r15
 310:	fe 01       	movw	r30, r28
}

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
	for (int i = 0; i < sizeof(LEDArray)/sizeof(LEDArray[0]); ++i) {
		if (LEDArray[i].blinkInterval != 0) {
 312:	88 81       	ld	r24, Y
 314:	99 81       	ldd	r25, Y+1	; 0x01
 316:	00 97       	sbiw	r24, 0x00	; 0
 318:	09 f4       	brne	.+2      	; 0x31c <blink_ms_timer_update+0x2a>
 31a:	46 c0       	rjmp	.+140    	; 0x3a8 <blink_ms_timer_update+0xb6>
			if (lastTime < globalTime) {
 31c:	80 90 10 20 	lds	r8, 0x2010
 320:	90 90 11 20 	lds	r9, 0x2011
 324:	a0 90 12 20 	lds	r10, 0x2012
 328:	b0 90 13 20 	lds	r11, 0x2013
 32c:	40 91 0c 20 	lds	r20, 0x200C
 330:	50 91 0d 20 	lds	r21, 0x200D
 334:	60 91 0e 20 	lds	r22, 0x200E
 338:	70 91 0f 20 	lds	r23, 0x200F
 33c:	84 16       	cp	r8, r20
 33e:	95 06       	cpc	r9, r21
 340:	a6 06       	cpc	r10, r22
 342:	b7 06       	cpc	r11, r23
 344:	90 f4       	brcc	.+36     	; 0x36a <blink_ms_timer_update+0x78>
				LEDArray[i].counter += (globalTime - lastTime); 
 346:	40 91 0c 20 	lds	r20, 0x200C
 34a:	50 91 0d 20 	lds	r21, 0x200D
 34e:	60 91 0e 20 	lds	r22, 0x200E
 352:	70 91 0f 20 	lds	r23, 0x200F
 356:	48 19       	sub	r20, r8
 358:	59 09       	sbc	r21, r9
 35a:	6a 09       	sbc	r22, r10
 35c:	7b 09       	sbc	r23, r11
 35e:	2a 81       	ldd	r18, Y+2	; 0x02
 360:	3b 81       	ldd	r19, Y+3	; 0x03
 362:	42 0f       	add	r20, r18
 364:	53 1f       	adc	r21, r19
 366:	4a 83       	std	Y+2, r20	; 0x02
 368:	5b 83       	std	Y+3, r21	; 0x03
				}
			lastTime = globalTime;
 36a:	40 91 0c 20 	lds	r20, 0x200C
 36e:	50 91 0d 20 	lds	r21, 0x200D
 372:	60 91 0e 20 	lds	r22, 0x200E
 376:	70 91 0f 20 	lds	r23, 0x200F
 37a:	40 93 10 20 	sts	0x2010, r20
 37e:	50 93 11 20 	sts	0x2011, r21
 382:	60 93 12 20 	sts	0x2012, r22
 386:	70 93 13 20 	sts	0x2013, r23
			if (LEDArray[i].counter >= LEDArray[i].blinkInterval) {
 38a:	22 81       	ldd	r18, Z+2	; 0x02
 38c:	33 81       	ldd	r19, Z+3	; 0x03
 38e:	28 17       	cp	r18, r24
 390:	39 07       	cpc	r19, r25
 392:	50 f0       	brcs	.+20     	; 0x3a8 <blink_ms_timer_update+0xb6>
				LEDArray[i].counter = 0;
 394:	12 82       	std	Z+2, r1	; 0x02
 396:	13 82       	std	Z+3, r1	; 0x03
				led_toggle(0b1 << (i));
 398:	8f 2d       	mov	r24, r15
 39a:	00 2e       	mov	r0, r16
 39c:	01 c0       	rjmp	.+2      	; 0x3a0 <blink_ms_timer_update+0xae>
 39e:	88 0f       	add	r24, r24
 3a0:	0a 94       	dec	r0
 3a2:	ea f7       	brpl	.-6      	; 0x39e <blink_ms_timer_update+0xac>
 3a4:	0e 94 33 01 	call	0x266	; 0x266 <led_toggle>
	LEDArray[led].blinkInterval = interval_ms;
}

//Update the state of the LEDs when a timer interrupt has occurred. This is the lower half handler for the timer interrupt, and should only be called if there was an unhandled timer interrupt that has occurred.
void blink_ms_timer_update(){
	for (int i = 0; i < sizeof(LEDArray)/sizeof(LEDArray[0]); ++i) {
 3a8:	0f 5f       	subi	r16, 0xFF	; 255
 3aa:	1f 4f       	sbci	r17, 0xFF	; 255
 3ac:	24 96       	adiw	r28, 0x04	; 4
 3ae:	03 30       	cpi	r16, 0x03	; 3
 3b0:	11 05       	cpc	r17, r1
 3b2:	09 f0       	breq	.+2      	; 0x3b6 <blink_ms_timer_update+0xc4>
 3b4:	ad cf       	rjmp	.-166    	; 0x310 <blink_ms_timer_update+0x1e>
				LEDArray[i].counter = 0;
				led_toggle(0b1 << (i));
			}
		}
	}
}
 3b6:	df 91       	pop	r29
 3b8:	cf 91       	pop	r28
 3ba:	1f 91       	pop	r17
 3bc:	0f 91       	pop	r16
 3be:	ff 90       	pop	r15
 3c0:	bf 90       	pop	r11
 3c2:	af 90       	pop	r10
 3c4:	9f 90       	pop	r9
 3c6:	8f 90       	pop	r8
 3c8:	08 95       	ret

000003ca <main>:
#include "../../blink.c"

int main(void)
{
	//SREG = SREG | 0b10000000;
	sei(); //Enables interrupts
 3ca:	78 94       	sei
	PMIC.CTRL = PMIC.CTRL | 0b111;
 3cc:	e0 ea       	ldi	r30, 0xA0	; 160
 3ce:	f0 e0       	ldi	r31, 0x00	; 0
 3d0:	82 81       	ldd	r24, Z+2	; 0x02
 3d2:	87 60       	ori	r24, 0x07	; 7
 3d4:	82 83       	std	Z+2, r24	; 0x02
	
	led_init();
 3d6:	0e 94 1e 01 	call	0x23c	; 0x23c <led_init>
	
	//led_on(LED_RED_bm);
	//led_on(LED_GREEN_bm);
	//led_on(LED_YELLOW_bm);
	
	blink_init();
 3da:	0e 94 46 01 	call	0x28c	; 0x28c <blink_init>
//Exactly what we're supposed to do with this is unclear
//Interrupt handler for the timer that you specify [A or B or C or D]. Note that variables that are modified in interrupt handlers must be declared as volatile. For more information about the volatile keyword check out this tutorial.

//Set the specified led to blink at the specified interval_ms.
void blink_set(uint8_t led, uint16_t interval_ms){
	LEDArray[led].blinkInterval = interval_ms;
 3de:	e0 e0       	ldi	r30, 0x00	; 0
 3e0:	f0 e2       	ldi	r31, 0x20	; 32
 3e2:	82 e3       	ldi	r24, 0x32	; 50
 3e4:	90 e0       	ldi	r25, 0x00	; 0
 3e6:	80 83       	st	Z, r24
 3e8:	91 83       	std	Z+1, r25	; 0x01
 3ea:	8d e7       	ldi	r24, 0x7D	; 125
 3ec:	90 e0       	ldi	r25, 0x00	; 0
 3ee:	84 83       	std	Z+4, r24	; 0x04
 3f0:	95 83       	std	Z+5, r25	; 0x05
 3f2:	8a ef       	ldi	r24, 0xFA	; 250
 3f4:	90 e0       	ldi	r25, 0x00	; 0
 3f6:	80 87       	std	Z+8, r24	; 0x08
 3f8:	91 87       	std	Z+9, r25	; 0x09
	blink_set(1, 250/2);
	blink_set(2, 500/2);

    while (1) 
    {
		blink_ms_timer_update();
 3fa:	0e 94 79 01 	call	0x2f2	; 0x2f2 <blink_ms_timer_update>
    }
 3fe:	fd cf       	rjmp	.-6      	; 0x3fa <main+0x30>

00000400 <_exit>:
 400:	f8 94       	cli

00000402 <__stop_program>:
 402:	ff cf       	rjmp	.-2      	; 0x402 <__stop_program>
